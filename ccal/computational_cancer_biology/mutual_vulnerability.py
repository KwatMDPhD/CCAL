"""
Computational Cancer Analysis Library

Authors:
    Huwate (Kwat) Yeerna (Medetgul-Ernar)
        kwat.medetgul.ernar@gmail.com
        Computational Cancer Analysis Laboratory, UCSD Cancer Center

    Pablo Tamayo
        ptamayo@ucsd.edu
        Computational Cancer Analysis Laboratory, UCSD Cancer Center
"""

from os.path import join

from matplotlib.gridspec import GridSpec
from matplotlib.pyplot import clf, close, figure, show, subplot
from numpy import argmin, asarray, empty, histogram, linspace, sign
from pandas import DataFrame, Index, Series, concat
from seaborn import despine, distplot, rugplot, set_style
from statsmodels.sandbox.distributions.extras import ACSkewT_gen

from ..mathematics.equation import (define_cumulative_area_ratio_function,
                                    define_x_coordinates_for_reflection)
from ..support.d1 import normalize_1d
from ..support.d2 import split_dataframe
from ..support.file import establish_filepath
from ..support.log import print_log
from ..support.parallel_computing import parallelize
from ..support.plot import FIGURE_SIZE, save_plot


def fit_essentiality(feature_x_sample, filepath_prefix, features=(), n_jobs=1):
    """
    Fit skew-t PDF to the distribution of each feature, gene.
    :param feature_x_sample: DataFrame; (n_features, n_samples)
    :param filepath_prefix: str;
    :param features: iterable; selected features to fit
    :param n_jobs: int; number of jobs for parallel computing
    :return: DataFrame; (n_features, 5 [N, DF, Shape, Location, Scale])
    """

    if len(features):  # Fit selected features
        is_ = Index(features) & feature_x_sample.index
        if len(is_):
            print_log('Fitting selected features: {} ...'.format(is_))
            feature_x_sample = feature_x_sample.ix[is_, :]
        else:
            raise ValueError('Selected features are not in indices.')

    else:  # Fit all features
        print_log('Fitting all features ...')

    print_log('Fitting with {} jobs ...'.format(n_jobs))
    f_x_f = concat(
        parallelize(_fit_essentiality,
                    split_dataframe(feature_x_sample, n_jobs), n_jobs))

    # Sort by shape
    f_x_f.sort_values('Shape', inplace=True)

    filepath = '{}skew_t_fit.txt'.format(filepath_prefix)
    establish_filepath(filepath)
    f_x_f.to_csv(filepath, sep='\t')

    return f_x_f


def _fit_essentiality(f_x_s):
    f_x_f = DataFrame(
        index=f_x_s.index, columns=['N', 'DF', 'Shape', 'Location', 'Scale'])

    for i, (f_i, f_v) in enumerate(f_x_s.iterrows()):
        print_log('Fitting {} (@{}/{}) ...'.format(f_i, i, f_x_s.shape[0]))

        # Fit skew-t PDF and save
        skew_t = ACSkewT_gen()
        f_v.dropna(inplace=True)
        df, shape, location, scale = skew_t.fit(f_v)
        f_x_f.ix[f_i, :] = f_v.size, df, shape, location, scale

    return f_x_f


def plot_essentiality(feature_x_fit,
                      feature_x_sample,
                      bar_df,
                      directory_path,
                      features=(),
                      figure_size=FIGURE_SIZE,
                      n_bins=50,
                      plot_fits=True,
                      overwrite=False,
                      show_plot=True,
                      dpi=100):
    """
    Make essentiality plot for each gene.
    :param feature_x_fit: DataFrame or str; (n_features, 5 (n, df, shape, location, scale)) or a filepath to a file
    :param feature_x_sample: DataFrame or str; (n_features, n_samples) or a filepath to a file
    :param bar_df: dataframe;
    :param features: iterable; (n_selected_features)
    :param n_x_grids: int;
    :param plot_fits: bool;
    :param pdf_color:
    :param pdf_reversed_color:
    :param essentiality_index_color:
    :param directory_path: str; directory_path/essentiality_plots/feature<id>.pdf will be saved
    :param overwrite: bool; overwrite the existing figure or not
    :param show_plot: bool; show plot or not
    :return: None
    """

    if len(features):  # Fit selected features
        is_ = Index(features) & feature_x_fit.index
        if len(is_):
            print_log('Plotting selected features: {} ...'.format(is_))
            feature_x_fit = feature_x_fit.ix[is_, :]
        else:
            raise ValueError('Selected features are not in indices.')

    else:  # Fit all features
        print_log('Plotting all features ...')

    # Plot each feature
    for i, (f_i, fit) in enumerate(feature_x_fit.iterrows()):
        print_log(
            'Plotting {} (@{}/{}) ...'.format(f_i, i, feature_x_fit.shape[0]))

        # Make an output filepath
        filepath = join(directory_path,
                        'essentiality_plots/{}.png'.format(f_i))

        # Parse fitted parameters
        n, df, shape, location, scale = fit
        vector = feature_x_sample.ix[f_i, :]
        bars = get_amp_mut_del(bar_df, f_i)

        # ======================================================================
        # Set up figure
        # ======================================================================
        # Initialize a figure
        fig = figure(figsize=figure_size)

        # Set figure styles
        set_style('ticks')
        despine(offset=9)

        # Set figure grids
        n_rows = 10
        n_rows_graph = 5
        gridspec = GridSpec(n_rows, 1)

        # Make graph ax
        ax_graph = subplot(gridspec[:n_rows_graph, :])

        # Set bar axes
        ax_bar0 = subplot(gridspec[n_rows_graph + 1:n_rows_graph + 2, :])
        ax_bar1 = subplot(gridspec[n_rows_graph + 2:n_rows_graph + 3, :])
        ax_bar2 = subplot(gridspec[n_rows_graph + 3:n_rows_graph + 4, :])
        for ax in [ax_bar1, ax_bar0, ax_bar2]:
            ax.spines['top'].set_visible(False)
            ax.spines['bottom'].set_visible(False)
            ax.spines['left'].set_visible(False)
            ax.spines['right'].set_visible(False)
            for t in ax.get_xticklines():
                t.set_visible(False)
            for t in ax.get_xticklabels():
                t.set_visible(False)
            for t in ax.get_yticklines():
                t.set_visible(False)
            for t in ax.get_yticklabels():
                t.set_visible(False)

        # ======================================================================
        # Plot histogram
        # ======================================================================
        distplot(
            vector,
            hist=True,
            bins=n_bins,
            kde=False,
            hist_kws={'linewidth': 0.92,
                      'alpha': 0.24,
                      'color': '#20d9ba'},
            ax=ax_graph)

        if plot_fits:
            # ==================================================================
            # Plot skew-t fit PDF
            # ==================================================================
            # Initialize a skew-t generator
            skew_t = ACSkewT_gen()

            # Set up x-grids
            x_grids = linspace(vector.min(), vector.max(), 3000)

            # Generate skew-t PDF
            skew_t_pdf = skew_t.pdf(
                x_grids, df, shape, loc=location, scale=scale)

            # Scale skew-t PDF
            histogram_max = histogram(vector, bins=n_bins)[0].max()
            scale_factor = histogram_max / skew_t_pdf.max()
            skew_t_pdf *= scale_factor

            # Plot skew-t PDF
            line_kwargs = {'linestyle': '-', 'linewidth': 2.6}
            ax_graph.plot(x_grids, skew_t_pdf, color='#20d9ba', **line_kwargs)

            # Extend plot vertically
            ax_graph.axis(
                [vector.min(), vector.max(), 0, histogram_max * 1.26])

            # ==================================================================
            # Plot reflected skew-t PDF
            # ==================================================================
            # Get the x-grids to get the reflecting PDF
            x_grids_for_reflection = define_x_coordinates_for_reflection(
                skew_t_pdf, x_grids)

            # Generate skew-t PDF over reflected x-grids, and scale
            skew_t_pdf_reflected = skew_t.pdf(
                x_grids_for_reflection, df, shape, loc=location,
                scale=scale) * scale_factor

            # Plot over the original x-grids
            ax_graph.plot(
                x_grids, skew_t_pdf_reflected, color='#4e41d9', **line_kwargs)

            # ==================================================================
            # Plot essentiality indices
            # ==================================================================
            essentiality_indices = define_cumulative_area_ratio_function(
                skew_t_pdf,
                skew_t_pdf_reflected,
                x_grids,
                direction=['+', '-'][shape > 0])
            essentiality_indices = normalize_1d(essentiality_indices, '0-1')
            if plot_fits:
                ax_graph.plot(
                    x_grids,
                    essentiality_indices * skew_t_pdf.max(),
                    color='#fc154f',
                    **line_kwargs)

        # ======================================================================
        # Decorate
        # ======================================================================
        # Set title
        fig.text(
            0.5,
            0.96,
            vector.name,
            fontsize=30,
            weight='bold',
            horizontalalignment='center')
        if plot_fits:
            fig.text(
                0.5,
                0.92,
                'N={:.2f}    DF={:.2f}    Shape={:.2f}    Location={:.2f}    Scale={:.2f}'.
                format(n, df, shape, location, scale),
                fontsize=16,
                weight='bold',
                horizontalalignment='center')

        # Set labels
        label_kwargs = {'weight': 'bold', 'fontsize': 22}
        ax_graph.set_xlabel('RNAi Score', **label_kwargs)
        ax_graph.set_ylabel('Frequency', **label_kwargs)

        # Set ticks
        tick_kwargs = {'size': 20, 'weight': 'normal'}
        for t in ax_graph.get_xticklabels():
            t.set(**tick_kwargs)
        for t in ax_graph.get_yticklabels():
            t.set(**tick_kwargs)

        # ======================================================================
        # Plot bars
        # ======================================================================
        bar_kwargs = {'rotation': 90, 'weight': 'bold', 'fontsize': 20}
        bar_specifications = {
            0: {
                'vector': bars.iloc[0, :],
                'ax': ax_bar0,
                'color': '#9017e6',
            },
            1: {
                'vector': bars.iloc[1, :],
                'ax': ax_bar1,
                'color': '#6410a0',
            },
            2: {
                'vector': bars.iloc[2, :],
                'ax': ax_bar2,
                'color': '#470b72',
            }
        }

        for i, spec in bar_specifications.items():
            v = spec['vector']
            ax = spec['ax']
            c = spec['color']
            rugplot(v * vector, height=1, color=c, ax=ax, linewidth=2.4)
            ax.set_ylabel(v.name[-3:], **bar_kwargs)

        # ======================================================================
        # Save
        # ======================================================================
        if filepath:
            save_plot(filepath, dpi=dpi, overwrite=overwrite)

        if show_plot:
            show()

        clf()
        close()


def get_amp_mut_del(gene_x_samples, gene):
    """
    Get AMP, MUT, and DEL information for a gene in the CCLE mutation file.
    :param gene_x_samples: dataframe; (n_genes, n_samplesa)
    :param gene: str; gene index used in gene_x_sample
    :return: dataframe; (3 (AMP, MUT, DEL), n_samples)
    """

    null = Series(index=gene_x_samples.columns)

    # Amplification
    try:
        amplifications = gene_x_samples.ix['{}_AMP'.format(gene), :]
    except KeyError:
        print_log('No amplification data for {}.'.format(gene))
        amplifications = null
        amplifications.name = '{}_AMP'.format(gene)

    # Mutation
    try:
        mutations = gene_x_samples.ix['{}_MUT'.format(gene), :]
    except KeyError:
        print_log('No mutation data for {}.'.format(gene))
        mutations = null
        mutations.name = '{}_MUT'.format(gene)

    # Deletion
    try:
        deletions = gene_x_samples.ix['{}_DEL'.format(gene), :]
    except KeyError:
        print_log('No deletion data for {}.'.format(gene))
        deletions = null
        deletions.name = '{}_DEL'.format(gene)

    return concat([amplifications, mutations, deletions], axis=1).T


def make_essentiality_matrix(feature_x_sample,
                             feature_x_fit,
                             n_x_grids=10000,
                             function='log-ratio',
                             normalization=None,
                             factor=1):
    """

    :param feature_x_sample: DataFrame; (n_features, n_samples)
    :param feature_x_fit: DataFrame;
    :param n_x_grids: int;
    :param function: str;
    :param normalization: str;
    :param factor: number;
    :return: DataFrame; (n_features, n_samples)
    """

    common_indices = feature_x_sample.index & feature_x_fit.index
    if len(common_indices):
        print_log('{} common features (indices).'.format(common_indices.size))
    else:
        print_log('No common features (indices).')
    print_log('Essentiality-index: function={} & normalization={}.'.format(
        function, normalization))

    gene_x_sample = feature_x_sample.ix[common_indices, :]
    gene_x_fit = feature_x_fit.ix[common_indices, :]

    skew_t = ACSkewT_gen()
    essentiality_matrix = empty(gene_x_sample.shape)

    for i, (g, (n, df, shape, location,
                scale)) in enumerate(gene_x_fit.iterrows()):
        # Skew-t PDF
        vector = asarray(gene_x_sample.ix[g, :])
        x_grids = linspace(vector.min(), vector.max(), n_x_grids)
        skew_t_pdf = skew_t.pdf(x_grids, df, shape, loc=location, scale=scale)

        # Reflected Skew-t PDF
        x_grids_for_reflection = define_x_coordinates_for_reflection(
            skew_t_pdf, x_grids)
        skew_t_pdf_reflected = skew_t.pdf(
            x_grids_for_reflection, df, shape, loc=location, scale=scale)

        # Essentiality indices
        essentiality_indices = define_cumulative_area_ratio_function(
            skew_t_pdf,
            skew_t_pdf_reflected,
            x_grids,
            direction=['+', '-'][shape > 0],
            function=function)

        if normalization == '0-1':
            essentiality_indices = normalize_1d(essentiality_indices, '0-1')
        essentiality_matrix[i, :] = [
            factor * sign(shape) *
            essentiality_indices[argmin(abs(x_grids - v))] for v in vector
        ]

    return DataFrame(
        essentiality_matrix,
        index=gene_x_sample.index,
        columns=gene_x_sample.columns)
