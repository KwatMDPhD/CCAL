# Check if all neccessary packages are installed and if not install those missing

 list.of.packages <- c("scatterplot3d", "MASS", "RColorBrewer", "rgl", "bpca", "smacof", "NMF", "maptools", "tensor", "fastcluster")
 new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
 if(length(new.packages)) install.packages(new.packages)

   library(scatterplot3d)
   library(MASS)
   library(RColorBrewer)
   library(rgl)
   library(bpca)
   library(smacof)
   library(NMF)
#   library(maptools)
   library(tensor)
   library(fastcluster)

DISSECTOR_read_tensor_dataset.v1 <- function(filename = "NULL") { 

   # Reads a tensor dataset in gct format

   temp <- readLines(filename)
   sizes <- as.numeric(unlist(strsplit(temp[[2]], "\t"))[1:3])
   print(sizes)
   x.names <- rep(NA, sizes[1])
   y.names <- rep(NA, sizes[2])
   z.names <- rep(NA, sizes[3])

   A <- array(data = NA, dim = c(sizes[1], sizes[2], sizes[3]))
   for (k in 1:sizes[3]) {
      z.names[k] <- unlist(strsplit(temp[[(k - 1) * (sizes[1] + 2)  + 3]], "\t"))[1]
      if (k == 1) {
         y.names <- unlist(strsplit(temp[[(k - 1) * (sizes[1] + 2) + 4]], "\t"))[3:(sizes[2] + 2)]
      }
      for (i in 1:sizes[1]) {
         if (k == 1) x.names[i] <- unlist(strsplit(temp[[(k - 1) * (sizes[1] + 2) + 4 + i]], "\t"))[1] 
         A[i, , k] <- as.numeric(unlist(strsplit(temp[[(k - 1) * (sizes[1] + 2) + 4 + i]], "\t"))[3:(sizes[2] + 2)])
      }
   }
   dimnames(A) <- list(x.names, y.names, z.names)
   return(A)
}

   DISSECTOR_write_tensor_dataset.v1 <- function(A, filename)
   {
   sizes <- dim(A)
   write("#1.2", file = filename, ncolumns = 1, append = FALSE, sep = "")
   write(sizes, file = filename, ncolumns = 3, append =TRUE, sep = "\t")

   for (k in 1:sizes[3]) {

       write(dimnames(A)[[3]][k], file = filename, ncolumns = 1, append = TRUE, sep = "")
       line <- c("Accession", "Description", dimnames(A)[[2]][1:sizes[2]])
       write(line, file = filename, ncolumns = length(line), append = TRUE, sep = "\t")
       for (i in 1:sizes[1]) {
           line <- c(dimnames(A)[[1]][i], dimnames(A)[[1]][i],  A[i, , k])
           write(line, file = filename, ncolumns = length(line), append = TRUE, sep = "\t")
         }
      }
   }

   DISSECTOR_tensor_decomposition.v1 <- function(
      #
      #  Project an input dataset into components using tensor decomposition                                            
      #
      input_tensor_dataset,             # Input GCTT dataset A where the tensor decomposition will take place (A ~ W x H x O)
      input_normalization = "rank",     # Normalization for the input dataset: "rank"
      number_of_gene_comp,              # Number of gene components to use in the tensor decomposition
      number_of_context_comp,           # Number of context components to use in the tensor decomposition       
      method = "NMF-SA",                # Method for tensor factorization: NTF-SA (Non-negative tensor factorisation by simulated annealing
      gene_subset = "all-genes",        # Universe of genes to consider for matrix decomposition: "gene-sets", "all-genes"
      gene_sets_files = NULL,           # If gene_subset = "gene-sets" GMT files with gene sets
      gene_sets = NULL,                 # If gene_subset = "gene-sets" then name of the specific gene set(s) in gene_sets_file to use
      normalize_after_selection = T,    # If gene_subset = "gene-sets," normalize after selection the gene subset
      preprojection_dataset = NULL,     # Save pre-projection input dataset in this file
      output_plots,                     # Output PDF file with W and H plots
      output_W_dataset,                 # Output GCT file with W tensor
      output_H_dataset,                 # Output GCT file with H tensor
      output_O_dataset,                 # Output GCT file with O tensor 
      output_A_dataset = NULL)          # Output GCT file with sorted and normalized A matrix
  {
   set.seed(5209761)
   
   mycol <- vector(length=512, mode = "numeric")   # Red/Blue "pinkogram" color map
   for (k in 1:256) mycol[k] <- rgb(255, k - 1, k - 1, maxColorValue=255)
   for (k in 257:512) mycol[k] <- rgb(511 - (k - 1), 511 - (k - 1), 255, maxColorValue=255)
   mycol <- rev(mycol)
   ncolors <- length(mycol)

   pdf(file=output_plots, height=8.5, width=11)
    
   # Read tensor dataset

   A <- DISSECTOR_read_tensor_dataset.v1(filename = "~/CGP2014/TA/TA_Pathways/tensor_toy.gctt")
   print(dim(A))
   n.genes <- dim(A)[1]
   n.pert <- dim(A)[2]
   n.context <- dim(A)[3]
   gene.names <- dimnames(A)[1]
   pert.names <- dimnames(A)[2]
   context.names <- dimnames(A)[3]
   n.gene.comp <- number_of_gene_comp
   n.context.comp <- number_of_context_comp
   gene.comp.names <- paste("GC_", 1:n.gene.comp)
   context.comp.names <- paste("CC_", 1:n.context.comp)   

   eps <- .Machine$double.eps   
   if (method == "NTF-SA") {

      # Randomly initalize W, H and O tensors

      W <- array(runif(n.genes * n.gene.comp) + .Machine$double.eps,
                 dim = c(n.genes, n.gene.comp),
                 dimnames = list(gene.names, gene.comp.names))

      H <- array(runif(n.gene.comp * n.pert * n.context.comp) + .Machine$double.eps,
                 dim = c(n.gene.comp * n.pert * n.context.comp),
                 dimnames = list(gene.comp.names, pert.names, context.comp.names))
      
      O <- array(runif(n.context.comp * n.context) + .Machine$double.eps,
                 dim = c(n.context.comp * n.context),
                 dimnames = list(context.comp.names, context.names))

      WHO <- tensor(W, tensor(H, O, alongA = 3, alongB = 1), alongA = 2, alongB = 1) 

      diver <- sum(A * log((A + eps)/(WHO + eps)) - A + WHO)

      print(paste("Initial divergence=", diver))

#      a.rate <- 0
#      init.beta <- 1000
#      final.beta <- 10000
#      max.iter <- 10
#      sd.delta <- 0.1
#      div.vs.time <- NULL
#      init.delta.ift <- sd.delta * sd(ift)
#      for (k in 1:max.iter) {
#         beta <- init.beta + (k/max.iter)*(final.beta - init.beta)
#         delta.ift <- (1 - (k/max.iter))*init.delta.ift
#         new.ift <- ift
      
         # Choose a tensor and location at random and propose a change 
         
#      loc <- floor(runif(1, min=1, max=n+1))
#      new.ift[loc] <- rnorm(1, mean = ift[loc], sd = delta.ift)
#      metric <- 1 - (sum((ift - x)^2)/n + sum((ift - y)^2)/n)/(2*sigma)
#      new.metric <- 1 - (sum((new.ift - x)^2)/n + sum((new.ift - y)^2)/n)/(2*sigma)
#      Metric.vs.time <- c(Metric.vs.time, metric)
#      delta.metric <- new.metric - metric
#      prob <- exp(beta * delta.metric)
#      print(paste("t:", k, " metric:", metric, " new.metric:", new.metric, " delta metric:", delta.metric, " prob:", prob, " beta:", beta))
#      if (runif(1) <= prob) {
#        ift <- new.ift
#        a.rate <- a.rate + 1
#      }
#    }
      
   } else {
      stop(paste("ERROR: Unknown method:", method))
   }

   # end of tensor factorization
   
   # Save W, H  and O tensors

   DISSECTOR_write_tensor_dataset.v1(W, output_W_dataset)
   DISSECTOR_write_tensor_dataset.v1(H, output_W_dataset)   
   DISSECTOR_write_tensor_dataset.v1(0, )

   dev.off()
  
 }


DISSECTOR_preprocess_dataset <- function(
   input.ds, 
   output.ds,
   thres = NULL, 
   ceil = NULL, 
   shift = NULL,
   fold = NULL, 
   delta = NULL, 
   normalization = NULL,
   cntrl.genes = NULL) {

   print(c("Running Preprocess Dataset... on:", input.ds))
   print(c("output file:", output.ds))
   print(c("normalization =", normalization))
   
# Read dataset

   dataset <- MSIG.Gct2Frame(filename = input.ds)
   m <- data.matrix(dataset$ds)
   gs.names <- dataset$row.names
   gs.descs <- dataset$descs
   sample.names <- dataset$names

   print(paste("dimensions initial dataset:", dim(m)))

# threshold, ceiling and shift

   if (!is.null(thres)) {
     m[m < thres] <- thres
   }
   if (!is.null(ceil)) {
      m[m > ceil] <- ceil
   }
   if (!is.null(shift)) {
      m <- m + shift
   }

   # identify and save control genes

   if (!is.null(cntrl.genes)) {
      gene.names2 <- intersect(cntrl.genes, gs.names)
      locs <- match(gene.names2, gs.names, nomatch=0)
      msig.cntrl <- m[locs, ]
      msig.cntrl.genes <- gs.names[locs]
      msig.cntrl.descs <- gs.descs[locs]
      m <- m[-locs, ]
      gs.names <- gs.names[-locs]
      gs.descs <- gs.descs[-locs]
    }

   # variation filter

   if ((!is.null(fold)) && (!is.null(delta))) {
      temp <- MSIG.VarFilter(V = m, fold = fold, delta = delta, gene.names = gs.names, gene.descs = gs.descs) 
      m <- temp$V
      gs.names <- temp$new.gene.names
      gs.descs <- temp$new.gene.descs
      dim(m) 
   }

   # restore control genes

   if (!is.null(cntrl.genes)) {
      m <- rbind(m, msig.cntrl)
      gs.names <- c(gs.names, msig.cntrl.genes)
      gs.descs <- c(gs.descs, msig.cntrl.descs)
    }

# normalization

   if (!is.null(normalization)) {
      if (normalization == 1) {
         m <- MSIG.NormalizeCols.Rank(m)
      } else if (normalization == 2) {
         m <- MSIG.NormalizeCols.Rank(m)/length(m[,1])
      } else if (normalization == 3) {
         m <- GSEA.NormalizeCols(m) + 3
         m <- GSEA.Threshold(m, 0.001, 100000) 
      } else if (normalization == 4) {
         m <- MSIG.NormalizeCols.Rank(m)/length(m[,1])
      } else if (normalization == 5) {
         m <- MSIG.NormalizeCols.Rescale(m)
      } else if (normalization == 6) {
         cols <- length(m[1,])
         for (j in 1:cols) {  # column rank normalization from 0 to N - 1
            m[,j] <- rank(m[,j], ties.method = "average") - 1
         }
         m <- 10000*m/(length(m[,1]) - 1)
      } else if (normalization == 7) {
         m <- ((100*MSIG.NormalizeCols.Rank(m))%/%length(m[,1]) + 1)
      } else if (normalization == 8) { 
          row.mean <- apply(m, MARGIN=1, FUN=mean)
          for (i in 1:length(m[,1])) {
             m[i,] <- m[i,] / row.mean[i]
          }
      }
   }
   print(paste("dimensions final dataset:", dim(m)))
   
   V <- data.frame(m)
   names(V) <- sample.names
   row.names(V) <- gs.names
   write.gct(gct.data.frame = V, descs = gs.descs, filename = output.ds)  

 }

  DISSECTOR_explore_component_creation.v1 <- function(
      #
      #  Obtain statistics to choose number of components
      #
      input_dataset,                    # Input GCT dataset A where the matrix decomposition takes place (A ~ W x H)
      input_normalization = "rank",     # Normalization for the input dataset: "rank"
      k.min = 2,                        # Range of components: minimum
      k.max = 5,                        # Range of components: maximum
      k.incr = 1,                       # Range of components: increment                                         
      number_of_runs = 20,              # Number of runs to explore in the matrix decomposition
      method = "NMF",                   # Method for matrix factorization: NMF, nsNMF or NMF_offset (IMF under construction)
      theta = 0.5,                      # For method = nsNMF value of smoothing parameter theta       
      gene_subset = "all-genes",        # Universe of genes to consider for matrix decomposition: "gene-sets", "all-genes"
      gene_sets_files = NULL,           # If gene_subset = "gene-sets" GMT files with gene sets
      gene_sets = NULL,                 # If gene_subset = "gene-sets" then name of the specific gene set(s) in gene_sets_file to use
      normalize_after_selection = T,    # If gene_subset = "gene-sets," normalize after selection the gene subset
      output_plots)                     # Output PDF file with NMF plots
 {
   set.seed(5209761)
   
   mycol <- vector(length=512, mode = "numeric")   # Red/Blue "pinkogram" color map
   for (k in 1:256) mycol[k] <- rgb(255, k - 1, k - 1, maxColorValue=255)
   for (k in 257:512) mycol[k] <- rgb(511 - (k - 1), 511 - (k - 1), 255, maxColorValue=255)
   mycol <- rev(mycol)
   ncolors <- length(mycol)

#   comp.names <- paste("C", seq(1, number_of_comp), "_", number_of_comp, sep="")
    
   # Read expression dataset

   dataset.1 <- MSIG.Gct2Frame(filename = input_dataset)
   m.1 <- data.matrix(dataset.1$ds)
   print(paste("Dimensions matrix A:", nrow(m.1), ncol(m.1)))

  # heatmap(m.1, scale="row", col=mycol, margins=c(15, 15), cexRow=0.10, cexCol=0.5, main="Sorted A Matrix", xlab = "Components", ylab= "Genes")   

   if (normalize_after_selection == F) {  # Normalize input data here before selection
     if (input_normalization == "rank") {

         max.n <- 10000
         for (i in 1:ncol(m.1)) m.1[,i] <- (max.n - 1) * (rank(m.1[,i]) - 1) /(nrow(m.1) - 1) + 1
   
      } else if (input_normalization == "none") {   

      } else {
         stop(paste("ERROR: unknown input normalization:", input_normalization))  
      }
   }
   
   if (gene_subset == "gene-sets") {  # select relevant genes from gene sets

        print("Selecting relevant genes from gene sets")

	max.G <- 0
	max.N <- 0
	for (gsdb in gene_sets_files) {
		GSDB <- Read.GeneSets.db(gsdb, thres.min = 2, thres.max = 2000, gene.names = NULL)
		max.G <- max(max.G, max(GSDB$size.G))
		max.N <- max.N +  GSDB$N.gs
	}
	N.gs <- 0
	gs <- matrix("null", nrow=max.N, ncol=max.G)
	gs.names <- vector(length=max.N, mode="character")
	gs.descs <- vector(length=max.N, mode="character")
	size.G <- vector(length=max.N, mode="numeric")
	start <- 1
	for (gsdb in gene_sets_files) {  # Read all the gene sets from gene set files
		GSDB <- Read.GeneSets.db(gsdb, thres.min = 2, thres.max = 2000, gene.names = NULL)
		N.gs <- GSDB$N.gs 
		gs.names[start:(start + N.gs - 1)] <- GSDB$gs.names
		gs.descs[start:(start + N.gs - 1)] <- GSDB$gs.desc
		size.G[start:(start + N.gs - 1)] <- GSDB$size.G
		gs[start:(start + N.gs - 1), 1:max(GSDB$size.G)] <- GSDB$gs[1:N.gs, 1:max(GSDB$size.G)]
		start <- start + N.gs
	}
	N.gs <- max.N
	
	# Select desired gene sets
	
	locs <- match(gene_sets, gs.names)
        print(rbind(gene_sets, locs))
	N.gs <- sum(!is.na(locs))
	if(N.gs > 1) { 
           gs <- gs[locs,]
	} else { 
           gs <- t(as.matrix(gs[locs,]))   # Force vector to matrix if only one gene set specified
        }
	gs.names <- gs.names[locs]
	gs.descs <- gs.descs[locs]
	size.G <- size.G[locs]

        genes <- NULL
       	for (gs.i in 1:N.gs) {
   	   gene.set <- gs[gs.i, 1:size.G[gs.i]]
           genes <- c(genes, gene.set)
         }
        print(paste("Number of selected genes:", length(genes)))
        genes <- unique(genes)
        print(paste("Number of unique selected genes:", length(genes)))        
        genes <- intersect(genes, row.names(m.1))
        print(paste("Number of overlapping genes (final set):", length(genes)))        
        m.2 <- m.1[genes,]
        print("Dimensions of selected input data:")
        print(dim(m.2))

   } else if (gene_subset == "all-genes") {

        print("Using all genes from gene sets")
        
      m.2 <- m.1
   } else {
      stop(paste("ERROR: unknown gene subset selection:", gene_subset))
   }

   if (normalize_after_selection == T) {  # Normalize input data here after selection
   
      if (input_normalization == "rank") {

         max.n <- 10000
         for (i in 1:ncol(m.2)) m.2[,i] <- (max.n - 1) * (rank(m.2[,i]) - 1) /(nrow(m.2) - 1) + 1

       } else if (input_normalization == "none") {   

       } else {
         stop(paste("ERROR: unknown input normalization:", input_normalization))  
       }
    }
   
   # Perform Matrix Factorization to find components

   if (method == "NMF") {
     NMF.models <- nmf(m.2, seq(k.min, k.max + 1, k.incr), nrun = number_of_runs, method="brunet", seed=9876)
     
   } else if (method == "IMF") {

     # To be added

   } else if (method == "NMF_offset") {

     nmf(m.2, seq(k.min, k.max + 1, k.incr), nrun = number_of_runs, method="offset", seed=9876)
     
   } else if (method == "nsNMF") {

    nmf(m.2, seq(k.min, k.max + 1, k.incr), nrun = number_of_runs, method="nsNMF", theta=theta, seed=9876)

   }
   
#   quartz()
#   plot(NMF.models)

   NMF.sum <- summary(NMF.models)
   k.vec <- seq(k.min, k.max + 1, 1)
   cophen <- NMF.sum[, "cophenetic"]
   peak <- rep(0, length(k.vec))

   pdf(file=output_plots, height=8.5, width=11)

   plot(k.vec, cophen, type="n")
   points(k.vec, cophen, type="l")
   points(k.vec, cophen, type="p", pch=20)          

   for (h in 2:(length(cophen) - 1)) if (cophen[h - 1] < cophen[h] & cophen[h] > cophen[h + 1]) peak[h] <- 1
   k.peaks <- k.vec[peak == 1]
   k <- rev(k.peaks)[1]
   k
   print(paste("Suggested number of components:", k))

   consensusmap(NMF.models)
   
   # end of matrix factorization

   dev.off()

 }

   DISSECTOR_produce_MDS_and_network.v1 <- function(
      #
      # Make MDS projection and network from a GCT file
      #
      input_dataset,                      # Input dataset (GCT). This is e.g. the original dataset A or the H matrix
      col_annot_file         = NULL,      # Columns annotation file (TXT, optional) in format c(file, name_column, annot_column, use_prefix)
      row_annot_file         = NULL,      # Rows annotation file (TXT, optional) in format c(file, name_column, annot_column, use_prefix)
      transpose_data         = F,         # Transpose input matrix
      append_col_annot       = F,         # Append annotation to column names
      append_row_annot       = F,         # Append annotation to column names
      plot_row_objects       = T,
      plot_row_objects_names = F,
      plot_row_dimensions    = F,
      plot_col_objects       = T,
      plot_col_objects_names = T,
      plot_col_dimensions    = T,
      col_object_size        = "auto",
      row_object_size        = "auto",
      output_plot,                                                    
      MDS_movie_file         = NULL)

  {
      set.seed(5209761)
       
      # Read input dataset

      dataset.1 <- MSIG.Gct2Frame(filename = input_dataset)
      H <- data.matrix(dataset.1$ds)
      print(dim(H))

      if (transpose_data == T) H <- t(H)

      width <- ceiling(ncol(H)/100)
      if (width < 11) width <- 11
      pdf(file=output_plot, height=8.5, width=width)
   
      # Read column annotation file
 
      if (!is.null(col_annot_file)) {
         annot.table <- read.table(col_annot_file[[1]], header=T, sep="\t", skip=0, colClasses = "character")
         column.list <- annot.table[, col_annot_file[[2]]]
         annot.list <- annot.table[, col_annot_file[[3]]]
         column.set <- vector(length=ncol(H), mode="character")
         if (col_annot_file[[4]] == T) {
            for (i in 1:ncol(H)) {
               column.set[i] <- strsplit(colnames(H)[i], split="_")[[1]]
            }
         } else {
            column.set <- colnames(H)
         }
         locs <- match(column.set, column.list)
         column.class <- annot.list[locs]
         column.class[is.na(column.class)] <- ""
         for (k in 1:length(column.class)) column.class[k] <- substr(column.class[k], 1, 20)
         all.col.classes <- unique(column.class)
         if (append_col_annot == T) colnames(H) <- paste(colnames(H), " (", column.class, ") ", sep="")
      } else {
         column.class <- rep(" ", ncol(H))
         all.col.classes <- " "
      }

      # Read row annotation file
 
      if (!is.null(row_annot_file)) {
         annot.table <- read.table(row_annot_file[[1]], header=T, sep="\t", skip=0, colClasses = "character")
         column.list <- annot.table[, row_annot_file[[2]]]
         annot.list <- annot.table[, row_annot_file[[3]]]
         row.set <- vector(length=nrow(H), mode="character")
         if (row_annot_file[[4]] == T) {
            for (i in 1:nrow(H)) {
               row.set[i] <- strsplit(row.names(H)[i], split="_")[[1]]
            }
         } else {
            row.set <- row.names(H)
         }
         locs <- match(row.set, column.list)
         row.class <- annot.list[locs]
         row.class[is.na(row.class)] <- ""
         for (k in 1:length(row.class)) row.class[k] <- substr(row.class[k], 1, 20)
         all.row.classes <- unique(row.class)
         if (append_row_annot == T) row.names(H) <- paste(row.names(H), " (", row.class, ") ", sep="")
      } else {
         row.class <- rep(" ", nrow(H))
         all.row.classes <- " "
      }
 
      # Color map
 
      mycol <- vector(length=512, mode = "numeric")
      for (k in 1:256) mycol[k] <- rgb(255, k - 1, k - 1, maxColorValue=255)
      for (k in 257:512) mycol[k] <- rgb(511 - (k - 1), 511 - (k - 1), 255, maxColorValue=255)
      mycol <- rev(mycol)
      max.cont.color <- 511
      mycol <- c(mycol,
              "black",  # brewer.pal(9, "YlGn")[1],     # Missing feature color (light yellow)
              mycol[256 - 75],                          # Binary feature's 0's color (blue)
              mycol[256 + 220])                         # Binary feature's 1's color (red)
      cex.axis <- 1

      phen.col <- # c("darkseagreen2", "mediumorchid2", brewer.pal(7, "Set1"), brewer.pal(7, "Dark2"),]
               c(brewer.pal(7, "Dark2"), brewer.pal(7, "Set1"), 
                 brewer.pal(7, "Paired"), brewer.pal(8, "Accent"), brewer.pal(8, "Set2"), brewer.pal(11, "Spectral"), brewer.pal(12, "Set3"),
                 sample(c(brewer.pal(9, "Blues"), brewer.pal(9, "Reds"), brewer.pal(9, "Oranges"), brewer.pal(9, "Greys"),
                          brewer.pal(9, "Purples"), brewer.pal(9, "Greens"))))

      row.names <- row.names(H)
      col.names <- colnames(H)
      row.names(H) <- paste("    ", row.names, sep="")
      colnames(H) <- paste("    ", col.names, sep="")

      bpca.1 <- bpca(t(H), method='hj', lambda.end=3)

      col.objects <- bpca.1$coord$objects
      row.objects <- bpca.1$coord$variables
      row.objects <- 1.10 * (max(col.objects)/ max(row.objects)) * row.objects

      open3d(windowRect = c(10, 10, 1200, 1200), zoom=0.75)

      if (col_object_size == "auto") {
         col.radius <- 0.15 + 7.5 / nrow(col.objects) 
      } else {
         col.radius <- col_object_size
      }
      for (i in 1:nrow(col.objects)) {
         obj.col <- phen.col[match(column.class, all.col.classes)]
         if (plot_col_objects == T) spheres3d(col.objects[i,1], col.objects[i,2], col.objects[i,3], radius= col.radius, color=obj.col[i])
         if (plot_col_objects_names == T) text3d(1.2*col.objects[i,1], 1.2*col.objects[i,2], 1.2* col.objects[i,3],
                                              texts=row.names(col.objects)[i], color=obj.col[i], cex=1.5)
         if (plot_col_dimensions == T)  lines3d(c(0,col.objects[i,1]), c(0, col.objects[i,2]), c(0, col.objects[i,3]), lwd=1, color="blue")
     }
      if (row_object_size == "auto") {
        row.radius <- 0.15 + 7.5 / nrow(row.objects) 
      } else {
        row.radius <- row_object_size
      }
      for (i in 1:nrow(row.objects)) {
         row.col <- phen.col[match(row.class, all.row.classes)]
         if (plot_row_objects == T) spheres3d(row.objects[i,1], row.objects[i,2], row.objects[i,3], radius= row.radius, color=row.col[i])
         if (plot_row_objects_names == T)  text3d(1.075*row.objects[i,1], 1.075*row.objects[i,2], 1.075*row.objects[i,3],
                                               texts=row.names(row.objects)[i], color="red", cex=1.5) 
         if (plot_row_dimensions == T)  lines3d(c(0,row.objects[i,1]), c(0, row.objects[i,2]), c(0, row.objects[i,3]), lwd = 1, color="red")
      }
     
#      s <- strsplit(MDS_movie_file, split="/")
#      movie.name <- s[[1]][length(s[[1]])]
#      dir <- paste(s[[1]][seq(1, length(s[[1]])-1)], collapse="/")
#      dir <- paste(dir, "/", sep="")
#   my.movie3d(spin3d(axis=c(1,1,1), rpm=2), duration=5, fps = 10, movie = movie_file, dir = dir,
#          convert = TRUE, clean = TRUE, verbose=TRUE, top = TRUE, type = "gif", startTime = 0)

      dev.off()
  }

   DISSECTOR_produce_biplot_from_dataset.v1 <- function(
      #
      # Makes a MDS projection 
      #
      input_dataset,                      # Input dataset (GCT). This is e.g. the original dataset A or the H matrix
      col_annot_file         = NULL,      # Columns annotation file (TXT, optional) in format c(file, name_column, annot_column, use_prefix)
      row_annot_file         = NULL,      # Rows annotation file (TXT, optional) in format c(file, name_column, annot_column, use_prefix)
      transpose_data         = F,         # Transpose input matrix
      append_col_annot       = F,         # Append annotation to column names
      append_row_annot       = F,         # Append annotation to column names
      plot_row_objects       = T,
      plot_row_objects_names = F,
      plot_row_dimensions    = F,
      plot_col_objects       = T,
      plot_col_objects_names = T,
      plot_col_dimensions    = T,
      col_object_size        = "auto",
      row_object_size        = "auto",
      output_plot)
  {
      set.seed(5209761)
       
      # Read input dataset

      dataset.1 <- MSIG.Gct2Frame(filename = input_dataset)
      H <- data.matrix(dataset.1$ds)
      print(dim(H))

      if (transpose_data == T) H <- t(H)

      width <- ceiling(ncol(H)/100)
      if (width < 11) width <- 11
      pdf(file=output_plot, height=8.5, width=width)
   
      # Read column annotation file
 
      if (!is.null(col_annot_file)) {
         annot.table <- read.table(col_annot_file[[1]], header=T, sep="\t", skip=0, colClasses = "character")
         column.list <- annot.table[, col_annot_file[[2]]]
         annot.list <- annot.table[, col_annot_file[[3]]]
         column.set <- vector(length=ncol(H), mode="character")
         if (col_annot_file[[4]] == T) {
            for (i in 1:ncol(H)) {
               column.set[i] <- strsplit(colnames(H)[i], split="_")[[1]]
            }
         } else {
            column.set <- colnames(H)
         }
         locs <- match(column.set, column.list)
         column.class <- annot.list[locs]
         column.class[is.na(column.class)] <- ""
         for (k in 1:length(column.class)) column.class[k] <- substr(column.class[k], 1, 20)
         all.col.classes <- unique(column.class)
         if (append_col_annot == T) colnames(H) <- paste(colnames(H), " (", column.class, ") ", sep="")
      } else {
         column.class <- rep(" ", ncol(H))
         all.col.classes <- " "
      }

      # Read row annotation file
 
      if (!is.null(row_annot_file)) {
         annot.table <- read.table(row_annot_file[[1]], header=T, sep="\t", skip=0, colClasses = "character")
         column.list <- annot.table[, row_annot_file[[2]]]
         annot.list <- annot.table[, row_annot_file[[3]]]
         row.set <- vector(length=nrow(H), mode="character")
         if (row_annot_file[[4]] == T) {
            for (i in 1:nrow(H)) {
               row.set[i] <- strsplit(row.names(H)[i], split="_")[[1]]
            }
         } else {
            row.set <- row.names(H)
         }
         locs <- match(row.set, column.list)
         row.class <- annot.list[locs]
         row.class[is.na(row.class)] <- ""
         for (k in 1:length(row.class)) row.class[k] <- substr(row.class[k], 1, 20)
         all.row.classes <- unique(row.class)
         if (append_row_annot == T) row.names(H) <- paste(row.names(H), " (", row.class, ") ", sep="")
      } else {
         row.class <- rep(" ", nrow(H))
         all.row.classes <- " "
      }
 
      # Color map
 
      mycol <- vector(length=512, mode = "numeric")
      for (k in 1:256) mycol[k] <- rgb(255, k - 1, k - 1, maxColorValue=255)
      for (k in 257:512) mycol[k] <- rgb(511 - (k - 1), 511 - (k - 1), 255, maxColorValue=255)
      mycol <- rev(mycol)
      max.cont.color <- 511
      mycol <- c(mycol,
              "black",  # brewer.pal(9, "YlGn")[1],     # Missing feature color (light yellow)
              mycol[256 - 75],                          # Binary feature's 0's color (blue)
              mycol[256 + 220])                         # Binary feature's 1's color (red)
      cex.axis = 1

      phen.col <- # c("darkseagreen2", "mediumorchid2", brewer.pal(7, "Set1"), brewer.pal(7, "Dark2"),]
               c(brewer.pal(7, "Dark2"), brewer.pal(7, "Set1"), 
                 brewer.pal(7, "Paired"), brewer.pal(8, "Accent"), brewer.pal(8, "Set2"), brewer.pal(11, "Spectral"), brewer.pal(12, "Set3"),
                 sample(c(brewer.pal(9, "Blues"), brewer.pal(9, "Reds"), brewer.pal(9, "Oranges"), brewer.pal(9, "Greys"),
                          brewer.pal(9, "Purples"), brewer.pal(9, "Greens"))))

      row.names <- row.names(H)
      col.names <- colnames(H)
      row.names(H) <- paste("    ", row.names, sep="")
      colnames(H) <- paste("    ", col.names, sep="")

      bpca.1 <- bpca(t(H), method='hj', lambda.end=3)
      col.objects <- bpca.1$coord$objects
      row.objects <- bpca.1$coord$variables
      row.objects <- 1.10 * (max(col.objects)/ max(row.objects)) * row.objects

      open3d(windowRect = c(10, 10, 1200, 1200), zoom=0.75)

      plot(col.objects[,1], col.objects[,2], xlim = 1.5*range(col.objects[,1]), ylim = 1.5*range(col.objects[,2]), type="n")

      if (col_object_size == "auto") {
         max.all <- max(abs(c(col.objects[,1], col.objects[,2], col.objects[,3])))
         col.radius <- max.all * (0.02 +  1.5 / nrow(col.objects))
      } else {
         col.radius <- col_object_size
      }
      for (i in 1:nrow(col.objects)) {
         obj.col <- phen.col[match(column.class, all.col.classes)]
         if (plot_col_objects == T) {
             spheres3d(col.objects[i,1], col.objects[i,2], col.objects[i,3], radius= col.radius, color=obj.col[i])
             points(col.objects[i,1], col.objects[i,2], pch=20, cex= 20*col.radius, col=obj.col[i])
         }
         if (plot_col_objects_names == T) {
             text3d(1.2*col.objects[i,1], 1.2*col.objects[i,2], 1.2*col.objects[i,3], texts=row.names(col.objects)[i], color=obj.col[i], cex=1.5)
             pointLabel(1.2*col.objects[i,1], 1.2*col.objects[i,2], labels=row.names(col.objects)[i], col="blue", cex=1.2)
             
         }
         if (plot_col_dimensions == T)  {
             lines3d(c(0,col.objects[i,1]), c(0, col.objects[i,2]), c(0, col.objects[i,3]), lwd=1, color="blue")
             lines(c(0,col.objects[i,1]), c(0, col.objects[i,2]), lwd=2, col="blue")
         }
      }
      title3d("Biplot Projection", cex=2)
      if (row_object_size == "auto") {
         max.all <- max(abs(c(row.objects[,1], row.objects[,2], row.objects[,3])))
         row.radius <- max.all * (0.01 +  1.5 / nrow(col.objects))
      } else {
        row.radius <- row_object_size
      }
      for (i in 1:nrow(row.objects)) {
         row.col <- phen.col[match(row.class, all.row.classes)]
         if (plot_row_objects == T) {
             spheres3d(row.objects[i,1], row.objects[i,2], row.objects[i,3], radius= row.radius, color=row.col[i])
             points(row.objects[i,1], row.objects[i,2], pch=20, cex= 20*row.radius, col=row.col[i])
         }
         if (plot_row_objects_names == T)  {
             text3d(1.075*row.objects[i,1], 1.075*row.objects[i,2], 1.075*row.objects[i,3], texts=row.names(row.objects)[i], color="red", cex=1.5)
             pointLabel(1.2*row.objects[i,1], 1.2*row.objects[i,2], labels=row.names(row.objects)[i], col="red", cex=1.2)             
         }
         if (plot_row_dimensions == T) {
             lines3d(c(0,row.objects[i,1]), c(0, row.objects[i,2]), c(0, row.objects[i,3]), lwd = 1, color="red")
             lines(c(0,row.objects[i,1]), c(0, row.objects[i,2]), lwd=2, col="red")
         }
     }
#      s <- strsplit(MDS_movie_file, split="/")
#      movie.name <- s[[1]][length(s[[1]])]
#      dir <- paste(s[[1]][seq(1, length(s[[1]])-1)], collapse="/")
#      dir <- paste(dir, "/", sep="")
#   my.movie3d(spin3d(axis=c(1,1,1), rpm=2), duration=5, fps = 10, movie = movie_file, dir = dir,
#          convert = TRUE, clean = TRUE, verbose=TRUE, top = TRUE, type = "gif", startTime = 0)

      dev.off()
  }


   DISSECTOR_produce_biplot_from_dataset.v2 <- function(
      #
      # Makes a MDS projection. This version can take indovidual points color and sizes for each row/column
      #
      input_dataset,                      # Input dataset (GCT). This is e.g. the original dataset A or the H matrix
      col_annot_file         = NULL,      # Columns annotation file (TXT, optional) in format c(file, name_column, annot_column, use_prefix, color, point size)
      row_annot_file         = NULL,      # Rows annotation file (TXT, optional) in format c(file, name_column, annot_column, use_prefix, color, point size)
      transpose_data         = F,         # Transpose input matrix
      append_col_annot       = F,         # Append annotation to column names
      append_row_annot       = F,         # Append annotation to column names
      plot_row_objects       = T,
      plot_row_objects_names = F,
      plot_row_dimensions    = F,
      plot_col_objects       = T,
      plot_col_objects_names = T,
      plot_col_dimensions    = T,
      col_object_size        = "auto",
      row_object_size        = "auto",
      output_plot,
      movie_file)
  {
      set.seed(5209761)
       
      # Read input dataset

      dataset.1 <- MSIG.Gct2Frame(filename = input_dataset)
      H <- data.matrix(dataset.1$ds)
      print(dim(H))

      if (transpose_data == T) H <- t(H)

      width <- ceiling(ncol(H)/100)
      if (width < 11) width <- 11
      pdf(file=output_plot, height=8.5, width=width)
   
      # Read column annotation file
 
      if (!is.null(col_annot_file)) {
         annot.table <- read.table(col_annot_file[[1]], header=T, sep="\t", skip=0, colClasses = "character")
         column.list <- annot.table[, col_annot_file[[2]]]
         annot.list <- annot.table[, col_annot_file[[3]]]
         column.set <- vector(length=ncol(H), mode="character")
         if (col_annot_file[[4]] == T) {
            for (i in 1:ncol(H)) {
               column.set[i] <- strsplit(colnames(H)[i], split="_")[[1]]
            }
         } else {
            column.set <- colnames(H)
         }
         locs <- match(column.set, column.list)
         column.class <- annot.list[locs]
         column.class[is.na(column.class)] <- ""
         for (k in 1:length(column.class)) column.class[k] <- substr(column.class[k], 1, 20)
         all.col.classes <- unique(column.class)
         if (append_col_annot == T) colnames(H) <- paste(colnames(H), " (", column.class, ") ", sep="")

         if (!is.null(col_annot_file[[5]])) col.color.list <- annot.table[, col_annot_file[[5]]]
         if (!is.null(col_annot_file[[6]])) col.size.list <- as.numeric(annot.table[, col_annot_file[[6]]])
         if (!is.null(col_annot_file[[7]])) {
             col.name.list <- annot.table[, col_annot_file[[7]]]         
         } else {
             col.name.list <- column.set
         }
         print(col.color.list)
         print(col.size.list)

      } else {
         col.color.list <- col.size.list <- NULL
         column.class <- rep(" ", ncol(H))
         all.col.classes <- " "
         col.name.list <- colnames(H)
     }

      # Read row annotation file
 
      if (!is.null(row_annot_file)) {
         annot.table <- read.table(row_annot_file[[1]], header=T, sep="\t", skip=0, colClasses = "character")
         column.list <- annot.table[, row_annot_file[[2]]]
         annot.list <- annot.table[, row_annot_file[[3]]]
         row.set <- vector(length=nrow(H), mode="character")
         if (row_annot_file[[4]] == T) {
            for (i in 1:nrow(H)) {
               row.set[i] <- strsplit(row.names(H)[i], split="_")[[1]]
            }
         } else {
            row.set <- row.names(H)
         }
         locs <- match(row.set, column.list)
         row.class <- annot.list[locs]
         row.class[is.na(row.class)] <- ""
         for (k in 1:length(row.class)) row.class[k] <- substr(row.class[k], 1, 20)
         all.row.classes <- unique(row.class)
         if (append_row_annot == T) row.names(H) <- paste(row.names(H), " (", row.class, ") ", sep="")
         if (!is.null(row_annot_file[[5]])) row.color.list <- annot.table[, row_annot_file[[5]]]
         if (!is.null(row_annot_file[[6]])) row.size.list <- as.numeric(annot.table[, row_annot_file[[6]]])
         if (!is.null(row_annot_file[[7]])) {
             row.name.list <- annot.table[, row_annot_file[[7]]]
         } else {
            row.name.list <- row.set
         }
      } else {
         row.color.list <- row.size.list <- NULL
         row.class <- rep(" ", nrow(H))
         all.row.classes <- " "
         row.name.list <- row.names(H)
      }
 
      # Color map
 
      mycol <- vector(length=512, mode = "numeric")
      for (k in 1:256) mycol[k] <- rgb(255, k - 1, k - 1, maxColorValue=255)
      for (k in 257:512) mycol[k] <- rgb(511 - (k - 1), 511 - (k - 1), 255, maxColorValue=255)
      mycol <- rev(mycol)
      max.cont.color <- 511
      mycol <- c(mycol,
              "black",  # brewer.pal(9, "YlGn")[1],     # Missing feature color (light yellow)
              mycol[256 - 75],                          # Binary feature's 0's color (blue)
              mycol[256 + 220])                         # Binary feature's 1's color (red)
      cex.axis = 1
      phen.col <- # c("darkseagreen2", "mediumorchid2", brewer.pal(7, "Set1"), brewer.pal(7, "Dark2"),]
               c(brewer.pal(7, "Dark2"), brewer.pal(7, "Set1"), 
                 brewer.pal(7, "Paired"), brewer.pal(8, "Accent"), brewer.pal(8, "Set2"), brewer.pal(11, "Spectral"), brewer.pal(12, "Set3"),
                 sample(c(brewer.pal(9, "Blues"), brewer.pal(9, "Reds"), brewer.pal(9, "Oranges"), brewer.pal(9, "Greys"),
                          brewer.pal(9, "Purples"), brewer.pal(9, "Greens"))))

      row.names <- row.names(H)
      col.names <- colnames(H)
      row.names(H) <- paste("    ", row.names, sep="")
      colnames(H) <- paste("    ", col.names, sep="")

      bpca.1 <- bpca(t(H), method='hj', lambda.end=3)

      col.objects <- bpca.1$coord$objects
      row.objects <- bpca.1$coord$variables
      row.objects <- 1.10 * (max(col.objects)/ max(row.objects)) * row.objects

      open3d(windowRect = c(10, 10, 1200, 1200), zoom=0.75)

      plot(col.objects[,1], col.objects[,2], xlim = 1.5*range(col.objects[,1]), ylim = 1.5*range(col.objects[,2]), type="n")

      if (!is.null(col.size.list)) {
         col.radius <- col.size.list          
      } else if (col_object_size == "auto") {
         max.all <- max(abs(c(col.objects[,1], col.objects[,2], col.objects[,3])))
         col.radius <- rep(max.all * (0.02 +  1.5 / nrow(col.objects)), nrow(col.objects))
      } else {
         col.radius <- rep(col_object_size, nrow(col.objects))
      }

      if (!is.null(col.color.list)) {
         obj.col <- col.color.list
      } else {
         obj.col <- phen.col[match(column.class, all.col.classes)]
      }
      for (i in 1:nrow(col.objects)) {

         if (plot_col_objects == T) {
             spheres3d(col.objects[i,1], col.objects[i,2], col.objects[i,3], radius= col.radius[i], color=obj.col[i])
             points(col.objects[i,1], col.objects[i,2], pch=20, cex= col.radius[i], col=obj.col[i])
         }
         if (plot_col_objects_names == T) {
             text3d(1.2*col.objects[i,1], 1.2*col.objects[i,2], 1.2*col.objects[i,3], texts=col.name.list[i], color=obj.col[i], cex=10*col.radius[i])
             pointLabel(1.2*col.objects[i,1], 1.2*col.objects[i,2], labels=col.name.list[i], col="blue", cex=10*col.radius[i])
             
         }
         if (plot_col_dimensions == T)  {
             lines3d(c(0,col.objects[i,1]), c(0, col.objects[i,2]), c(0, col.objects[i,3]), lwd=1, color="blue")
             lines(c(0,col.objects[i,1]), c(0, col.objects[i,2]), lwd=2, col="blue")
         }
      }
         
      title3d("Biplot Projection", cex=2)

     if (!is.null(row.size.list)) {
         row.radius <- row.size.list          
     } else if (row_object_size == "auto") {
         max.all <- max(abs(c(row.objects[,1], row.objects[,2], row.objects[,3])))
         row.radius <- rep(max.all * (0.01 +  1.5 / nrow(row.objects)), nrow(row.objects))
      } else {
        row.radius <- rep(row_object_size, nrow(row.objects))
      }
      if (!is.null(row.color.list)) {
         row.col <- row.color.list
      } else {
         row.col <- phen.col[match(row.class, all.row.classes)]
      }
         
      for (i in 1:nrow(row.objects)) {

         if (plot_row_objects == T) {
             spheres3d(row.objects[i,1], row.objects[i,2], row.objects[i,3], radius= row.radius[i], color=row.col[i])
             points(row.objects[i,1], row.objects[i,2], pch=20, cex= row.radius[i], col=row.col[i])
         }
         if (plot_row_objects_names == T)  {
             text3d(1.075*row.objects[i,1], 1.075*row.objects[i,2], 1.075*row.objects[i,3], texts=row.name.list[i], color="red", cex=row.radius[i])
             pointLabel(1.2*row.objects[i,1], 1.2*row.objects[i,2], labels=row.name.list[i], col="red", cex=row.radius[i])             
         }
         if (plot_row_dimensions == T) {
             lines3d(c(0,row.objects[i,1]), c(0, row.objects[i,2]), c(0, row.objects[i,3]), lwd = 1, color="red")
             lines(c(0,row.objects[i,1]), c(0, row.objects[i,2]), lwd=2, col="red")
         }
     }

      
#      s <- strsplit(movie_file, split="/")
#      movie.name <- s[[1]][length(s[[1]])]
#      dir <- paste(s[[1]][seq(1, length(s[[1]])-1)], collapse="/")
#      dir <- paste(dir, "/", sep="")

#      print(dir)
#      print(movie.name)
#       movie3d(spin3d(axis=c(1,1,1), rpm=2), duration=10, fps = 20, movie = movie.name, dir = dir,
#          convert = TRUE, clean = TRUE, verbose=TRUE, top = TRUE, type = "gif", startTime = 0)

      dev.off()
  }

   DISSECTOR_produce_landscape_plot.v1 <- function(
      #
      # Makes a MDS projection 
      #
      input_dataset,                      # Input dataset (GCT). This is e.g. the original dataset A or the H matrix
      type_of_input          = "dataset", # Type of input dataset: "dataset" or "association_matrix"
      col_annot_file         = NULL,      # Columns annotation file (TXT, optional) in format c(file, name_column, annot_column, use_prefix)
      transpose_data         = F,         # Transpose input matrix
      association_metric     = "IC",      # Association metric to make association matrix between column objects
      center_col_object      = NULL,      # A center col object (column from input dataset) modifies the landcape projection to be specifically around that object
      append_col_annot       = F,         # Append annotation to column names
      plot_col_objects       = T,
      plot_col_objects_names = T,
      plot_col_dimensions    = T,
      col_object_size        = "auto",
      output_plot)

  {
      set.seed(5209761)
       
      # Read input dataset

      dataset.1 <- MSIG.Gct2Frame(filename = input_dataset)
      H <- data.matrix(dataset.1$ds)
      print(dim(H))
      if (transpose_data == T) H <- t(H)

      # Read column annotation file
 
      if (!is.null(col_annot_file)) {

         col.names <- colnames(H)
         for (i in 1:ncol(H)) {  # Remove dots in column names (produced by parenthesis or spaces)
            temp <- unlist(strsplit(col.names[i], split="\\."))
            col.names[i] <- temp[1]
         }
         colnames(H) <- col.names
         
         annot.table <- read.table(col_annot_file[[1]], header=T, sep="\t", skip=0, colClasses = "character")
         column.list <- annot.table[, col_annot_file[[2]]]
         annot.list <- annot.table[, col_annot_file[[3]]]
         column.set <- vector(length=ncol(H), mode="character")
         if (col_annot_file[[4]] == T) {
            for (i in 1:ncol(H)) {
               column.set[i] <- strsplit(colnames(H)[i], split="_")[[1]]
            }
         } else {
            column.set <- colnames(H)
         }
         locs <- match(column.set, column.list)
         column.class <- annot.list[locs]
         column.class[is.na(column.class)] <- ""
         for (k in 1:length(column.class)) column.class[k] <- substr(column.class[k], 1, 20)
         all.col.classes <- unique(column.class)
         if (append_col_annot == T) colnames(H) <- paste(colnames(H), " (", column.class, ") ", sep="")
       } else {
         column.class <- rep(" ", ncol(H))
         all.col.classes <- " "
      }
      row.names <- row.names(H)
      col.names <- colnames(H)
      row.names(H) <- paste("    ", row.names, sep="")
      colnames(H) <- paste("    ", col.names, sep="")

      width <- ceiling(ncol(H)/100)
      if (width < 11) width <- 11
      pdf(file=output_plot, height=8.5, width=width)

      if (type_of_input == "dataset") {
      
         # Generate association matrix and distance matrix
         
         assoc.matrix <- dist.matrix <- matrix(0, nrow=ncol(H), ncol=ncol(H), dimnames = list(colnames(H), colnames(H)))
         for (i in 1:ncol(H)) {
            for (j in 1:ncol(H)) {
               if (association_metric == "IC") {
                   assoc.matrix[i, j] <- IC.v1(H[,i], H[,j])
               } else if (association_metric == "ICR") {
                  assoc.matrix[i, j] <- IC.v1(rank(H[,i]), rank(2[,j]))
               } else if (association_metric == "COR") {
                  assoc.matrix[i, j] <- cor(H[,i], H[,j], method = "pearson")
               } else if (association_metric == "SPEAR") {
                  assoc.matrix[i, j] <- cor(H[,i], H[,j], method = "spearman")
               } else {
                  stop(paste("ERROR: unknown association metric:", association_metric))
               }
           }
         }

      } else if (type_of_input == "association_matrix") {
         assoc.matrix <- H
      }
 
      dist.matrix <- 1 - assoc.matrix
      assoc.matrix <- (assoc.matrix + t(assoc.matrix))/2  # Simmetrize matrix for smacof
      for (i in 1:nrow(assoc.matrix)) assoc.matrix[i, i] <- 1            
      
      if (is.null(center_col_object)) {  # Global landscape plot
   
         smacof.proj <- smacofSym(dist.matrix, ndim = 3, weightmat = NULL, init = NULL, metric = TRUE, ties = "primary",
                            verbose = FALSE, relax = FALSE, modulus = 1, itmax = 1000, eps = 1e-06)

         x <- smacof.proj$conf[,1]
         y <- smacof.proj$conf[,2]
         z <- smacof.proj$conf[,3]

        # Color map
       phen.col <- # c("darkseagreen2", "mediumorchid2", brewer.pal(7, "Set1"), brewer.pal(7, "Dark2"),]
               c(brewer.pal(7, "Dark2"), brewer.pal(7, "Set1"), 
                 brewer.pal(7, "Paired"), brewer.pal(8, "Accent"), brewer.pal(8, "Set2"), brewer.pal(11, "Spectral"), brewer.pal(12, "Set3"),
                 sample(c(brewer.pal(9, "Blues"), brewer.pal(9, "Reds"), brewer.pal(9, "Oranges"), brewer.pal(9, "Greys"),
                          brewer.pal(9, "Purples"), brewer.pal(9, "Greens"))))

         open3d(windowRect = c(10, 10, 1200, 1200), zoom=0.75)

         plot(x, y, xlim = 1.5*range(x), ylim = 1.5*range(y), type="n")

         if (col_object_size == "auto") {
             max.all <- max(abs(c(x, y, z)))
             col.radius <- max.all * (0.02 +  1.5 / length(x))
         } else {
            col.radius <- col_object_size
         }
         for (i in 1:length(x)) {
            obj.col <- phen.col[match(column.class, all.col.classes)]
            if (plot_col_objects == T) {
                spheres3d(x[i], y[i], z[i], radius= col.radius, color=obj.col[i])
                points(x[i], y[i], pch=20, cex= 40*col.radius, col=obj.col[i])
            }
            if (plot_col_objects_names == T) {
                text3d(1.2*x[i], 1.2*y[i], 1.2*z[i], texts=row.names(dist.matrix)[i], color=obj.col[i], cex=1.5)
                pointLabel(1.2*x[i], 1.2*y[i], labels=row.names(dist.matrix)[i], col=obj.col[i], cex=1.2)
            }
            if (plot_col_dimensions == T)  {
                lines3d(c(0, x[i]), c(0, y[i]), c(0, z[i]), lwd=1, color="blue")
                lines(c(0, x[i]), c(0, y[i]), lwd=2, col="blue")
            }
         }
         lines3d(c(0, 1), c(0, 0), c(0, 0), lwd = 1, color="red") # x axis
         text3d(1.2, 0, 0, texts="X", color="red", cex=1.5)         
         lines3d(c(0, 0), c(0, 1), c(0, 0), lwd = 1, color="red") # y axis
         text3d(0, 1.2, 0, texts="Y", color="red", cex=1.5)         
         lines3d(c(0, 0), c(0, 0), c(0, 1), lwd = 1, color="red") # z axis         
         text3d(0, 0, 1.2, texts="Z", color="red", cex=1.5)

         if (type_of_input == "dataset") {
              title3d("Landcape Projection from Dataset", cex=2)
          } else {
              title3d("Landcape Projection from Association Matrix", cex=2)
          }
         
    } # if center_col_object

    dev.off()
   }

   DISSECTOR_match_features_to_target_profile.v1 <- function(
      #
      #  Match multiple genomic features to a given profile
      #
      input_dataset,                           # Input dataset (GCT) containing the target profile
      target,
      target.dir = "positive",
      directory,                               # Directory where to produce results                                          
      identifier            = "match_to_target_profile.v1", # string or prefix to identify this analysis
      feature.type.files,                      # List of feature typers and correponding file e.g.
                                               # list("ACHILLES"     = "~/CGP2013/Distiller/Achilles_v2.4.1.rnai.Gs.gct",
                                               #  "MUT_CNA"      = "~/CGP2013/Distiller/RNAseqMUTs_CNA_20130729.gct",  
                                               #  "EXP_PATHWAYS" = "~/CGP2013/Distiller/CCLE_MSigDB_plus_oncogenic.PATHWAYS.v2.gct",
                                               #  "EXP_GENES"    = "~/CGP2013/CCLE/rnaseq.v3.gct",
                                               #  "RPPA"         = "~/CGP2013/Distiller/RPPA.dat.gct")
       feature.dir,                            # e.g. c(0, 1, 1, 1, 1),                                         
       n.markers            = 25,                         # Number of top hits shown in the heatmaps
       metric               = "IC",
       n.boot               = 100,
       n.perm               = 10,                                         
       locs.table.file      = NULL,
       log.table.file,
       missing.value.color  = "wheat",     # Missing feature color
       target.style = "color.bar",          # "color.bar" or "bar.graph"       
       min.thres            = 10,
       character.scaling    = 0.65,
       phen.table           = NULL,
       phenotypes           = NULL)            # list(list("ALL"))
     
   {
      version <- identifier
      target.file <- input_dataset
      dataset.1 <- MSIG.Gct2Frame(filename = target.file)
      
      H <- data.matrix(dataset.1$ds)
      feature.types <- names(feature.type.files)
      n.f.types <- length(feature.types)
      
      if (!is.null(phen.table)) {
         samples.table <- read.delim(phen.table, header=T, row.names=1, sep="\t", skip=0)
         table.names <- row.names(samples.table)
       }
      log.table <- NULL

         target.dir.name <- paste(directory, target, sep="")
         dir.create(target.dir.name, showWarnings=FALSE)

         target.dir <- as.numeric(ifelse(target.dir == "positive", 1, 0) )
      
         for (f in 1:n.f.types) {   # loop over feature types
            n.markers.feature <- n.markers
             
            dir <- ifelse(xor(target.dir, feature.dir[[f]]), "negative", "positive")
           
            print(paste("Reading target file:", target.file))
            dataset.1 <- MSIG.Gct2Frame(filename = target.file)
            sample.names.1 <- dataset.1$names
            
            print(paste("Reading features file:", feature.type.files[[f]]))
            dataset.2 <- MSIG.Gct2Frame(filename = feature.type.files[[f]])
            ds2 <- data.matrix(dataset.2$ds)
            sample.names.2 <- dataset.2$names

            if (nrow(ds2) < 2*n.markers.feature) n.markers.feature <- floor(nrow(ds2)/2)

            if (is.null(phen.table)) {
               phen.set <- 1
               phen.selected <- NULL
               results.file.pdf <- paste(directory, target, "/", target, "_vs_", feature.types[[f]], "_", version, ".pdf", sep="")
               results.file.txt <- paste(directory, target, "/", target, "_vs_", feature.types[[f]], "_", version, ".txt", sep="")               
            } else {
              results.file.pdf <- paste(directory, target, "/", "_", target, "_vs_", feature.types[[f]], "_", version, ".pdf", sep="")
              results.file.txt <- paste(directory, target, "/", "_", target, "_vs_", feature.types[[f]], "_", version, ".txt", sep="")               
              if (length(phenotypes) == 1) {
                  phen.set <- unlist(phenotypes[[1]])
                  phen.selected <- "1"
               } else {
                  phen.set <- unlist(phenotypes[[d]])
                  phen.selected <- "1"
               }
             }
            for (p in 1:length(phen.set)) {  # loop over phenotypes
               if (phen.set == 1) {
                  phen <- NULL
                  print(paste("Working on:  feature=", f))
                  overlap <- intersect(sample.names.1, sample.names.2)
                  doc.string <- c(ifelse(length(overlap) < min.thres, "NO", "YES"), length(overlap), target, dir, feature.types[[f]],
                                  version, target.file, feature.type.files[[f]])
                } else {
                  phen <- phen.set[p]
                  print(paste("Working on: feature=", f, " phen=", phen))
                  sample.names.3 <- table.names[samples.table[,  phen] == "1"]
                  overlap <- intersect(sample.names.1, intersect(sample.names.2, sample.names.3))
                  doc.string <- c(ifelse(length(overlap) < min.thres, "NO", "YES"), length(overlap), phen, target, dir, feature.types[[f]],
                                  version, target.file, feature.type.files[[f]])
               }

               log.table <- rbind(log.table, doc.string)
               
               # Only run analysis if there are at least min.thres samples
         
               if (length(overlap) < min.thres) next
             
               SCREENER.v2(
                  ds1 =                            target.file,
                  target.name =                    target,
                  ds2 =                            feature.type.files[[f]],
                  n.markers =                      n.markers.feature,             
                  n.perm =                         n.perm,           
                  permutation.test.type =          "standard",  
                  n.boot =                         n.boot,
                  seed =                           2345971, 
                  assoc.metric.type =              metric,
                  direction =                      dir,
                  sort.target =                    TRUE,           
                  results.file.pdf =               results.file.pdf,
                  results.file.txt =               results.file.txt,
                  sort.columns.inside.classes =    F,
                  locs.table.file =                locs.table.file,
                  consolidate.identical.features = "identical",
                  cons.features.hamming.thres =    0,   
                  save.matched.dataset =           F,  
                  produce.aux.histograms =         F,
                  produce.heat.map =               T,
                  produce.mds.plots =              T,
                  character.scaling =              character.scaling,
                  mds.plot.type =                  "smacof",
                  n.grid =                         25,
                  target.style = target.style,          # "color.bar" or "bar.graph"                   
                  missing.value.color  =           missing.value.color,     # Missing feature color                   
                  phen.table =                     phen.table,
                  phen.column =                    phen,
                  phen.selected =                  phen.selected)
            
              } # loop over phenotypes
  
          } # loop over feature types

       # Save log records
      
       if (phen.set == 1) {
          header <- c("Run:", "Samples:", "target:", "Direction:", "Feature.type:", "Version:", "target.file:", "Feature.type.file:")
        } else {
          header <- c("Run:", "Samples:", "Phenotype:", "target:", "Direction:", "Feature.type:", "Version:", "target.file:", "Feature.type.file:")
        }
        colnames(log.table) <- header
        write.table(log.table, file=log.table.file, quote=F, col.names = T, row.names = F, append = F, sep="\t")
  }

       


   DISSECTOR_annotate_components.v1 <- function(
      #
      #  Match genomic features to each components profile
      #
      input_dataset,                           # Input dataset (GCT). This is e.g. the H matrix
      directory,                               # Directory where to produce results                                          
      identifier            = "Comp_annot.v1", # string or prefix to identify this analysis
      feature.type.files,                      # List of feature typers and correponding file e.g.
                                               # list("ACHILLES"     = "~/CGP2013/Distiller/Achilles_v2.4.1.rnai.Gs.gct",
                                               #  "MUT_CNA"      = "~/CGP2013/Distiller/RNAseqMUTs_CNA_20130729.gct",  
                                               #  "EXP_PATHWAYS" = "~/CGP2013/Distiller/CCLE_MSigDB_plus_oncogenic.PATHWAYS.v2.gct",
                                               #  "EXP_GENES"    = "~/CGP2013/CCLE/rnaseq.v3.gct",
                                               #  "RPPA"         = "~/CGP2013/Distiller/RPPA.dat.gct")
       feature.dir,                            # c(0, 1, 1, 1, 1),                                         
       n.markers            = 25,                         # Number of top hits shown in the heatmaps
       n.perm               = 10,                                         
       char.scaling         = 0.575,                   # Character scaling for heatmaps
       locs.table.file      = NULL,
       log.table.file,
       min.thres            = 10,
       character.scaling    = 0.65,
       phen.table           = NULL,
       phenotypes           = NULL)            # list(list("ALL"))
     
   {
      version <- identifier
      target.file <- input_dataset
      dataset.1 <- MSIG.Gct2Frame(filename = target.file)
      
      H <- data.matrix(dataset.1$ds)
      targets <- row.names(H)
      target.types <- rep("COMP", length(targets))
      target.dir <- rep(1, length(targets))
      feature.types <- names(feature.type.files)
      n.targets <- length(targets)
      n.f.types <- length(feature.types)
      
      if (!is.null(phen.table)) {
         samples.table <- read.delim(phen.table, header=T, row.names=1, sep="\t", skip=0)
         table.names <- row.names(samples.table)
       }
      log.table <- NULL

      for (d in 1:n.targets) {  # loop over targets

         target.dir.name <- paste(directory, targets[d], sep="")
         dir.create(target.dir.name, showWarnings=FALSE)

         for (f in 1:n.f.types) {   # loop over feature types
        
            t.dir <- ifelse (length(target.dir) == 1, target.dir[[1]], target.dir[[d]])
           
            dir <- ifelse(xor(t.dir, feature.dir[[f]]), "negative", "positive")

            print(paste("Reading target file:", target.file))
            dataset.1 <- MSIG.Gct2Frame(filename = target.file)
            sample.names.1 <- dataset.1$names
            
            print(paste("Reading features file:", feature.type.files[[f]]))
            dataset.2 <- MSIG.Gct2Frame(filename = feature.type.files[[f]])
            sample.names.2 <- dataset.2$names

            if (is.null(phen.table)) {
               phen.set <- 1
               phen.selected <- NULL
            } else {
              if (length(phenotypes) == 1) {
                  phen.set <- unlist(phenotypes[[1]])
                  phen.selected <- "1"
               } else {
                  phen.set <- unlist(phenotypes[[d]])
                  phen.selected <- "1"
               }
             }
            for (p in 1:length(phen.set)) {  # loop over phenotypes
               if (phen.set == 1) {
                  phen <- NULL
                  print(paste("Working on: target=", d, " feature=", f))
                  overlap <- intersect(sample.names.1, sample.names.2)
                  doc.string <- c(ifelse(length(overlap) < min.thres, "NO", "YES"), length(overlap), targets[d], dir, feature.types[[f]],
                                  version, target.file, feature.type.files[[f]])
                  results.file.pdf <- paste(directory, targets[d], "/", targets[d], "_vs_", feature.types[[f]], "_", version, ".pdf", sep="")
                  results.file.txt <- paste(directory, targets[d], "/", targets[d], "_vs_", feature.types[[f]], "_", version, ".txt", sep="")               

                } else {
                  phen <- phen.set[p]
                  print(paste("Working on: target=", d, " feature=", f, " phen=", phen))
                  sample.names.3 <- table.names[samples.table[,  phen] == "1"]
                  overlap <- intersect(sample.names.1, intersect(sample.names.2, sample.names.3))
                  doc.string <- c(ifelse(length(overlap) < min.thres, "NO", "YES"), length(overlap), phen, targets[d], dir, feature.types[[f]],
                                  version, target.file, feature.type.files[[f]])
                  results.file.pdf <- paste(directory, targets[d], "/", phen, "_", targets[d], "_vs_", feature.types[[f]], "_", version, ".pdf", sep="")
                  results.file.txt <- paste(directory, targets[d], "/", phen, "_", targets[d], "_vs_", feature.types[[f]], "_", version, ".txt", sep="")               
               }

               log.table <- rbind(log.table, doc.string)
               
               # Only run analysis if there are at least min.thres samples
         
               if (length(overlap) < min.thres) next
             
               SCREENER.v1(
                  ds1 =                            target.file,
                  target.name =                    targets[d],
                  ds2 =                            feature.type.files[[f]],
                  n.markers =                      n.markers,             
                  n.perm =                         n.perm,           
                  permutation.test.type =          "standard",  
                  n.boot =                         200,         
                  seed =                           2345971, 
                  assoc.metric.type =              "IC",      
                  direction =                      dir,
                  sort.target =                    TRUE,           
                  results.file.pdf =               results.file.pdf,
                  results.file.txt =               results.file.txt,
                  sort.columns.inside.classes =    F,
                  locs.table.file =                locs.table.file,
                  consolidate.identical.features = "identical",
                  cons.features.hamming.thres =    0,   
                  save.matched.dataset =           F,  
                  produce.aux.histograms =         F,
                  produce.heat.map =               T,
                  produce.mds.plots =              T,
                  character.scaling =              character.scaling,
                  mds.plot.type =                  "smacof",
                  n.grid =                         25,
                  phen.table =                     phen.table,
                  phen.column =                    phen,
                  phen.selected =                  phen.selected)
            
              } # loop over phenotypes
  
          } # loop over feature types
    
       } # loop over targets

       # Save log records
      
       if (phen.set == 1) {
          header <- c("Run:", "Samples:", "target:", "Direction:", "Feature.type:", "Version:", "target.file:", "Feature.type.file:")
        } else {
          header <- c("Run:", "Samples:", "Phenotype:", "target:", "Direction:", "Feature.type:", "Version:", "target.file:", "Feature.type.file:")
        }
        colnames(log.table) <- header
        write.table(log.table, file=log.table.file, quote=F, col.names = T, row.names = F, append = F, sep="\t")
    }

   DISSECTOR_fitop_associations.v1 <- function(
      #
      #  Find top associations to each column state 
      #
      input_dataset,                    # Input dataset (GCT). This is e.g. the original dataset A or the H matrix
      transpose_data = F,               # Transpose input matrix       
      annot_file = NULL,                # Gene nnotation file (TXT, optional) in format c(file, name_column, annot_column, use_prefix)
      n.top = 35,                       # Number of top (UP) matches to display
      n.bottom = 10,                    # Number of top (DOWN) matches to display
      output_top_assocs_plot)           # Output (PDF) file with top associations
   {

   set.seed(5209761)
            
   # Read input dataset

   dataset.1 <- MSIG.Gct2Frame(filename = input_dataset)
   H <- data.matrix(dataset.1$ds)
   print(dim(H))

   if (transpose_data == T) H <- t(H)
   
   k.comp <- nrow(H)

   # Read annotation file

   if (!is.null(annot_file)) {
      annot.table <- read.table(annot_file[[1]], header=T, sep="\t", skip=0, colClasses = "character")
      gene.list <- annot.table[, annot_file[[2]]]
      annot.list <- annot.table[, annot_file[[3]]]
      gene.set <- vector(length=ncol(H), mode="character")
      if (annot_file[[4]] == T) {
         for (i in 1:ncol(H)) {
            gene.set[i] <- strsplit(colnames(H)[i], split="_")[[1]]
         }
      } else {
         gene.set <- colnames(H)
      }
      locs <- match(gene.set, gene.list)
      gene.class <- annot.list[locs]
      for (k in 1:length(gene.class)) gene.class[k] <- substr(gene.class[k], 1, 10)
      all.classes <- sort(unique(gene.class))
      colnames(H) <- paste(colnames(H), " (", gene.class, ") ", sep="")
    } else {
      gene.class <- rep(" ", ncol(H))
      all.classes <- " "
   }

   mycol <- vector(length=512, mode = "numeric")
   for (k in 1:256) mycol[k] <- rgb(255, k - 1, k - 1, maxColorValue=255)
   for (k in 257:512) mycol[k] <- rgb(511 - (k - 1), 511 - (k - 1), 255, maxColorValue=255)
   mycol <- rev(mycol)
   ncolors <- length(mycol)

   cutoff <- 2
   for (i in 1:nrow(H)) {
      x <- H[i,]
      x <- (x - mean(x))/sd(x)         
      x[x > cutoff] <- cutoff
      x[x < - cutoff] <- - cutoff      
      H[i, ] <- x
      H[i,] <- ceiling(ncolors * (x + cutoff)/(2*cutoff))
      H[i,] <- ifelse (H[i, ] > ncolors, ncolors, H[i, ])
    }

   pdf(file=output_top_assocs_plot, height=8.5, width=11)

   Ht <- t(H)
   
   for (i in 1:nrow(Ht)) {
      nf <- layout(matrix(c(1, 2, 3, 4), 4, 1, byrow=T), 1, c(g4, ceiling(n.top/2) + 2, ceiling(n.bottom/2) + 2, 3),  FALSE)
      ind <- order(Ht[i,], decreasing=T)
      Ht.temp <- Ht[, ind]
      mutinf.m <- NULL
      for (k in 1:nrow(Ht.temp)) mutinf.m <- c(mutinf.m, IC.v1(Ht.temp[i,], Ht.temp[k,]))
      ind <- order(mutinf.m, decreasing=T)
      mutinf.m <- signif(mutinf.m[ind], 3)
      Ht.temp <- Ht.temp[ind,]
      gene.class.temp <- gene.class[ind]
     
      # Target profile
    
      V <- Ht.temp[1,]

      par(mar = c(1, 20, 4, 6))    
      image(1:length(V), 1:1, as.matrix(V), zlim = c(0, ncolors), col=mycol, axes=FALSE, main=row.names(Ht.temp)[1], sub = "",
            cex.main = 2, xlab= "", ylab="")
      
      col.classes <- c("darkseagreen2", "mediumorchid2", brewer.pal(7, "Set1"), brewer.pal(7, "Dark2"),
                 brewer.pal(7, "Paired"), brewer.pal(8, "Accent"), brewer.pal(8, "Set2"), brewer.pal(11, "Spectral"), brewer.pal(12, "Set3"),
                 sample(c(brewer.pal(9, "Blues"), brewer.pal(9, "Reds"), brewer.pal(9, "Oranges"), brewer.pal(9, "Greys"),
                          brewer.pal(9, "Purples"), brewer.pal(9, "Greens"))))

      if (!is.null(annot_file)) {
         gc <- gene.class.temp[1]
         cols <- col.classes[match(gc, all.classes)]
      } else {
         cols = "black"
      }
      mtext(row.names(Ht.temp)[1], at=1, side = 2, cex=0.50, col=cols, line=0, las=1, font=2, family="")
      axis(4, at=1+0.2, labels="        IC  ", adj= 0.5, tick=FALSE, las = 1, cex.axis=0.85, line=-1, font=2, family="")
      axis(4, at=1, labels="   (Information ", adj= 0.5, tick=FALSE, las = 1, cex.axis=0.75, line=-1, font=2, family="")
      axis(4, at=1-0.2, labels="    Coefficient) ", adj= 0.5, tick=FALSE, las = 1, cex.axis=0.75, line=-1, font=2, family="")     
      axis(3, at=1:length(V), labels=colnames(Ht.temp), adj= 0.5, tick=FALSE, las = 1, cex.axis=ifelse(k.comp >= 25, 0.6, 0.85),
           font.axis=1, line=-1, font=2, family="")
     
      # HIGHEST IC ASSOCIATIONS

      V <- Ht.temp[2:(n.top+1),]
      gc <- gene.class.temp[2:(n.top+1)]
#      row.names(V) <- paste(row.names(V), " (", gc, ") ", sep="")
      muti <- mutinf.m[2:(n.top+1)]

      V <- apply(V, MARGIN=2, FUN=rev)
      gc <- rev(gc)
      muti <- rev(muti)
      par(mar = c(1, 20, 3, 6))
      image(1:dim(V)[2], 1:dim(V)[1], t(V), zlim = c(0, ncolors), col=mycol, axes=FALSE, main="HIGHEST IC ASSOCIATIONS", sub = "", xlab= "", ylab="")     
      mtext(row.names(V), at=1:nrow(V), side = 2, cex=0.50, col=col.classes[match(gc, all.classes)], line=0, las=1, font=2, family="")
      axis(4, at=1:nrow(V), labels=muti, adj= 0.5, tick=FALSE, las = 1, cex.axis=0.85, font.axis=1, line=0, font=2, family="")
      axis(3, at=1:ncol(V), labels=colnames(V), adj= 0.5, tick=FALSE, las = 1, cex.axis=ifelse(k.comp >= 25, 0.6, 0.85),
           font.axis=1, line=-1, font=2, family="")

      # LOWEST IC ASSOCIATIONS
     
      V <- Ht.temp[seq(nrow(Ht.temp) - n.bottom + 1, nrow(Ht.temp)),]
      gc <- gene.class.temp[seq(nrow(Ht.temp) - n.bottom + 1, nrow(Ht.temp))]
#      row.names(V) <- paste(row.names(V), " (", gc, ") ", sep="")
      muti <- mutinf.m[seq(nrow(Ht.temp) - n.bottom + 1, nrow(Ht.temp))]

      V <- apply(V, MARGIN=2, FUN=rev)
      gc <- rev(gc)
      muti <- rev(muti)     
      par(mar = c(2, 20, 3, 6))     
      image(1:dim(V)[2], 1:dim(V)[1], t(V), zlim = c(0, ncolors), col=mycol, axes=FALSE, main="LOWEST IC ASSOCIATIONS", sub = "", xlab= "", ylab="")     
      mtext(row.names(V), at=1:nrow(V), side = 2, cex=0.50, col=col.classes[match(gc, all.classes)], line=0, las=1, font=2, family="")    
      axis(4, at=1:nrow(V), labels=muti, adj= 0.5, tick=FALSE, las = 1, cex.axis=0.85, font.axis=1, line=0, font=2, family="")
      axis(3, at=1:ncol(V), labels=colnames(V), adj= 0.5, tick=FALSE, las = 1, cex.axis=ifelse(k.comp >= 25, 0.6, 0.85),
           font.axis=1, line=-1, font=2, family="")

      par.mar <- par("mar")
      par(mar = c(4, 45, 1, 5))
      leg.set <- seq(0, 1, 0.01)
      image(1:length(leg.set), 1:1, as.matrix(leg.set), zlim=c(0, 1), col=mycol, axes=FALSE, main=paste("Legend"), font=2, sub ="", family="")
      ticks <- seq(0, 1, 0.1)
      tick.cols <- rep("black", 5)
      tick.lwd <- 2
      locs <- NULL
      for (k in 1:length(ticks)) locs <- c(locs, which.min(abs(ticks[k] - leg.set)))
      axis(1, at=locs, labels=ticks, adj= 0.5, tick=T, cex=0.7, cex.axis=1, line=0, font=2, family="")
      mtext("Stardardized (Across Samples) Component Amplitude", cex=0.85, side = 1, line = 2.5, outer=F)     
      par(mar = par.mar)

   }
   dev.off()
 }

DISSECTOR_make_heatmap_of_matrix.v1 <- function(
      #
      # Make heatmap of matrix from GCT file
      #
      input_dataset,           # Input dataset (GCT). This is e.g. the original dataset A or the H matrix
      annot_file = NULL,       # Phenotype annotation file (TXT, optional) in format c(file, name_column, annot_column, use_prefix)
      transpose_data = F,      # Transpose input matrix
      append_annot = F,        # Append annotation to column names
      sorting_method = "MDS",  # Sorting method for columns inside a phenotype: MDS (Multi_dimensional Scaling) or HC (Hiererachical Clustering)
      cex.rows = "auto",       # Character size for row names
      cex.cols = "auto",       # Character size for col names
      cex.phen = "auto",       # Character size for phenotype names
      str.phen = "90",         # Degrees: orientation of phenotype labels                                                  
      output_plot_landscape,   # Output (PDF) plot in landscape format
      output_plot_portrait)    # Output (PDF) plot in portrait format
  {

   set.seed(5209761)
       
   # Read input dataset

   dataset.1 <- MSIG.Gct2Frame(filename = input_dataset)
   H <- data.matrix(dataset.1$ds)
   print(dim(H))

   if (transpose_data == T) H <- t(H)

   width <- ceiling(ncol(H)/100)
   if (width < 11) width <- 14
   pdf(file=output_plot_landscape, height=8.5, width=width)
   
   # Read annotation file
 
   if (!is.null(annot_file)) {
      annot.table <- read.table(annot_file[[1]], header=T, sep="\t", skip=0, colClasses = "character")
      column.list <- annot.table[, annot_file[[2]]]
      annot.list <- annot.table[, annot_file[[3]]]
      column.set <- vector(length=ncol(H), mode="character")
      if (annot_file[[4]] == T) {
         for (i in 1:ncol(H)) {
            column.set[i] <- strsplit(colnames(H)[i], split="_")[[1]]
         }
      } else {
         column.set <- colnames(H)
      }
      locs <- match(column.set, column.list)
      column.class <- annot.list[locs]
      column.class[is.na(column.class)] <- "UNLABELED"
      for (k in 1:length(column.class)) column.class[k] <- substr(column.class[k], 1, 20)
      all.classes <- unique(column.class)
      if (append_annot == T) colnames(H) <- paste(colnames(H), " (", column.class, ") ", sep="")
   } else {
      column.class <- rep(" ", ncol(H))
      all.classes <- " "
   }
  
   # Color map
 
   mycol <- vector(length=512, mode = "numeric")
   for (k in 1:256) mycol[k] <- rgb(255, k - 1, k - 1, maxColorValue=255)
   for (k in 257:512) mycol[k] <- rgb(511 - (k - 1), 511 - (k - 1), 255, maxColorValue=255)
   mycol <- rev(mycol)
   max.cont.color <- 511
   mycol <- c(mycol,
              "black",  # brewer.pal(9, "YlGn")[1],     # Missing feature color (light yellow)
              mycol[256 - 75],                          # Binary feature's 0's color (blue)
              mycol[256 + 220])                         # Binary feature's 1's color (red)
   cex.axis = 1

   # demo("colors")
      phen.col <- # c("darkseagreen2", "mediumorchid2", brewer.pal(7, "Set1"), brewer.pal(7, "Dark2"),]
               c(brewer.pal(7, "Dark2"), brewer.pal(7, "Set1"), 
                 brewer.pal(7, "Paired"), brewer.pal(8, "Accent"), brewer.pal(8, "Set2"), brewer.pal(11, "Spectral"), brewer.pal(12, "Set3"),
                 sample(c(brewer.pal(9, "Blues"), brewer.pal(9, "Reds"), brewer.pal(9, "Oranges"), brewer.pal(9, "Greys"),
                          brewer.pal(9, "Purples"), brewer.pal(9, "Greens"))))

  # Normalize and apply color map

   cutoff <- 2
   for (i in 1:nrow(H)) {
      x <- H[i,]
      locs.non.na <- !is.na(x)
      x.nonzero <- x[locs.non.na]
      x.nonzero2 <- (x.nonzero - mean(x.nonzero))/sd(x.nonzero)         
      x.nonzero2[x.nonzero2 > cutoff] <- cutoff
      x.nonzero2[x.nonzero2 < - cutoff] <- - cutoff      
      s <- strsplit(row.names(H)[i], "_")[[1]]
      suffix <- s[length(s)]
      if (suffix == "MUT" | suffix == "AMP" | suffix == "DEL" | suffix == "AMP_2" | suffix == "AMP_3" | suffix == "DEL_2" | suffix == "DEL_3" |
          suffix == "all" | length(table(x.nonzero)) == 2) {  # Binary feature
         H[i,locs.non.na] <- x.nonzero + max.cont.color + 2   # binary feature colors
       } else {
         H[i, locs.non.na] <- x.nonzero2
         H[i, locs.non.na] <- ceiling(max.cont.color * (H[i,locs.non.na] + cutoff)/(2*cutoff))
         H[i, locs.non.na] <- ifelse (H[i, locs.non.na] > max.cont.color, max.cont.color, H[i, locs.non.na])
       }
      H[i, is.na(x)] <- max.cont.color + 1 # missing feature color 
    }

   # Horizontal/Landscape versions
   
   # Plot sorted by phenotype ------------------------------------------------------------------------------

   nf <- layout(matrix(c(1, 2, 3), nrow=3, ncol=1, byrow=T), 1, c(1, 6.5, 0.75), FALSE)

   H_orig <- H
   column.class_orig <- column.class
   ind <- order(column.class, decreasing=F)
   H <- H[, ind]
   column.class <- column.class[ind]
   all.classes <- sort(unique(column.class))
   
   V1.phen <- match(column.class, all.classes)
   par(mar = c(1, 10, 2, 6))
   image(1:length(V1.phen), 1:1, as.matrix(V1.phen), col=phen.col[1:max(V1.phen)], axes=FALSE, main="Phenotype", sub = "", xlab= "", ylab="")
   axis(2, at=1:1, labels="Phenotype", adj= 0.5, tick=FALSE, las = 1, cex.axis=1, font.axis=1, line=-1)

   if (!is.null(annot_file)) {
      leg.txt <- all.classes
      for (i in 1:length(leg.txt)) leg.txt[i] <- substr(leg.txt[i], 1, 25)
      boundaries <- NULL
      for (i in 2:length(column.class)) {
         if (column.class[i] != column.class[i-1]) boundaries <- c(boundaries, i-1)
      }
      boundaries <- c(boundaries, length(column.class))    
      locs.bound <- c(boundaries[1]/2, boundaries[2:length(boundaries)] - (boundaries[2:length(boundaries)] - boundaries[1:(length(boundaries)-1)])/2)
      for (i in 1:length(leg.txt)) {
         if (cex.phen == "auto") cex.phen <- 0.05 + 7/ifelse(nchar(leg.txt[i]) < 6, 6, nchar(leg.txt[i]))
#        text(locs.bound[i], 1, labels=leg.txt[i], adj=c(0.5, 1), srt=str.phen, cex=cex.phen)
         text(locs.bound[i], 1, labels=leg.txt[i], adj=c(0, 0), srt=str.phen, cex=cex.phen)      
       }
    }
   
  # Sort columns inside each phenotypic class 
   
   for (k in all.classes) {
      if (sum(column.class == k) <= 1) next;
      V1 <- H[, column.class == k]
      col.names.V1 <- colnames(H)[column.class == k]
      dist.matrix <- dist(t(V1))
      if (sorting_method == "MDS") {
         s <- smacofSym(dist.matrix, ndim=1)
         ind <- order(s$conf, decreasing=T)
       } else if (sorting_method == "HC") {
         HC <- hclust(dist.matrix, method="ward")
         ind <- HC$order
       } else {
          stop(paste("ERROR: unknown sorting method:", sorting_method))
       }
      V1 <- V1[ , ind]
      H[, column.class == k] <- V1
      col.names.V1 <- col.names.V1[ind]
      colnames(H)[column.class == k] <- col.names.V1 
   }
 
   V2 <- apply(H, MARGIN=2, FUN=rev)

   lower.space <-  ceiling(4 + 100/nrow(H))
   par(mar = c(lower.space, 10, 2, 6))

   image(1:ncol(V2), 1:nrow(V2), t(V2), zlim = c(0, max.cont.color + 3), col=mycol, axes=FALSE, main="Matrix Sorted by Phenotype",
         sub = "", xlab= "", ylab="", cex.main=1)
   if (cex.rows == "auto") cex.rows <- 0.20 + 200/(nrow(V2) * max(nchar(row.names(V2))) + 200)

   axis(2, at=1:nrow(V2), labels=row.names(V2), adj= 0.5, tick=FALSE, las = 1, cex.axis=cex.rows, font.axis=1, line=-1)
   if (!is.null(annot_file)) {   
      for (i in 1:(length(boundaries)-1)) lines(c(boundaries[i]+0.5, boundaries[i]+0.5), c(0.5, nrow(V2) + 0.5), lwd=2, lty=1, col="black")
    }
   if (!is.null(annot_file)) {
      cols2 <- phen.col[match(column.class, all.classes)]
   } else {
      cols2 = "black"
   }
   if (cex.cols == "auto") cex.cols <- 0.20 + 200/(ncol(V2) * max(nchar(colnames(V2))) + 200)
   mtext(colnames(V2), at=1:ncol(V2), side = 1, cex=cex.cols, col=cols2, line=0, las=3, font=2, family="")
   
   # Legend

   par(mar = c(3, 35, 1, 6))
   leg.set <- seq(-cutoff, cutoff, 0.05)
   image(1:length(leg.set), 1:1, as.matrix(leg.set), zlim=c(-cutoff, cutoff), col=mycol, axes=FALSE, main="Matrix Standardized Profile",
       sub = "", xlab= "", ylab="",font=2, family="", mgp = c(0, 0, 0), cex.main=0.8)
   ticks <- seq(-cutoff, cutoff, 0.5)
   tick.cols <- rep("black", 5)
   tick.lwd <- 1
   locs <- NULL
   for (k in 1:length(ticks)) locs <- c(locs, which.min(abs(ticks[k] - leg.set)))
   axis(1, at=locs, labels=ticks, adj= 0.5, tick=T, cex=0.6, cex.axis=0.6, line=0, font=2, family="", mgp = c(0.1, 0.1, 0.1))

   # Plot sorted by columns and rows ------------------------------------------------------------------------------

   nf <- layout(matrix(c(1, 2), 2, 1, byrow=T), 1, c(8, 1), FALSE)

   H <- H_orig
   column.class <- column.class_orig

   hc <- hclust(dist(t(H)), "complete")
   ind1 <- hc$order
   hc2 <- hclust(dist(H), "complete")
   ind2 <- hc2$order
   H <- H[ind2, ind1]
   column.class <- column.class[ind1]

   V3 <- apply(H, MARGIN=2, FUN=rev)
   lower.space <-  ceiling(3 + 100/nrow(H))
#   par(mar = c(lower.space, 12, 2, 4))
      par(mar = c(3, 10, 2, 4))
   image(1:ncol(V3), 1:nrow(V3), t(V3), zlim = c(0, max.cont.color + 3), col=mycol, axes=FALSE, main="Matrix Sorted (Rows and Columns)",
         sub = "", xlab= "", ylab="", cex.main=1)
   if (cex.rows == "auto")  cex.rows <- 0.20 + 200/(nrow(V3) * max(nchar(row.names(V3))) + 200)
   axis(2, at=1:nrow(V3), labels=row.names(V3), adj= 0.5, tick=FALSE, las = 1, cex.axis=cex.rows, font.axis=1, line=-1)   
#   axis(1, at=1:ncol(V), labels=colnames(V), adj= 0.5, tick=FALSE, las = 3, cex.axis=cex.cols, font.axis=1, line=-1) # Add sample names        

   if (!is.null(annot_file)) {
      cols.V3 <- phen.col[match(column.class, all.classes)]
   } else {
      cols.V3 = "black"
   }
   if (cex.cols == "auto") cex.cols <- 0.20 + 200/(ncol(V3) * max(nchar(colnames(V3))) + 200)
   mtext(colnames(V3), at=1:ncol(V3), side = 1, cex=cex.cols, col=cols.V3, line=0, las=3, font=2, family="")

   # Legend

   par(mar = c(3, 35, 1, 6))
   leg.set <- seq(-cutoff, cutoff, 0.05)
   image(1:length(leg.set), 1:1, as.matrix(leg.set), zlim=c(-cutoff, cutoff), col=mycol, axes=FALSE, main="Matrix Standardized Profile",
       sub = "", xlab= "", ylab="",font=2, family="", mgp = c(0, 0, 0), cex.main=0.8)
   ticks <- seq(-cutoff, cutoff, 0.5)
   tick.cols <- rep("black", 5)
   tick.lwd <- 1
   locs <- NULL
   for (k in 1:length(ticks)) locs <- c(locs, which.min(abs(ticks[k] - leg.set)))
   axis(1, at=locs, labels=ticks, adj= 0.5, tick=T, cex=0.6, cex.axis=0.6, line=0, font=2, family="", mgp = c(0.1, 0.1, 0.1))

   # Plot in original order ------------------------------------------------------------------------------

   H <- H_orig
   column.class <- column.class_orig
   
   nf <- layout(matrix(c(1, 2), 2, 1, byrow=T), 1, c(8, 1), FALSE)

   V4 <- apply(H, MARGIN=2, FUN=rev)
   lower.space <-  ceiling(2 + 100/nrow(H))
#   par(mar = c(lower.space, 16, 2, 6))
    par(mar = c(2, 14, 2, 5))
   image(1:ncol(V4), 1:nrow(V4), t(V4), zlim = c(0, max.cont.color + 3), col=mycol, axes=FALSE, main="Matrix in Original Order",
         sub = "", xlab= "", ylab="", cex.main=0.8)
   if (cex.rows == "auto") cex.rows <- 0.20 + 200/(nrow(V4) * max(nchar(row.names(V4))) + 200)   
   axis(2, at=1:nrow(V4), labels=row.names(V4), adj= 0.5, tick=FALSE, las = 1, cex.axis=cex.rows, font.axis=1, line=-1)
   if (cex.cols == "auto") cex.cols <- 0.20 + 200/(ncol(V4) * max(nchar(colnames(V4))) + 200)   

   if (!is.null(annot_file)) {
      cols.V4 <- phen.col[match(column.class, all.classes)]
   } else {
      cols.V4 = "black"
   }
   if (cex.cols == "auto") cex.cols <- 0.20 + 200/(ncol(V4) * max(nchar(colnames(V4))) + 200)
   mtext(colnames(V4), at=1:ncol(V4), side = 1, cex=cex.cols, col=cols.V4, line=0, las=3, font=2, family="")

   # Legend

   par(mar = c(3, 32, 1, 6))
   leg.set <- seq(-cutoff, cutoff, 0.05)
   image(1:length(leg.set), 1:1, as.matrix(leg.set), zlim=c(-cutoff, cutoff), col=mycol, axes=FALSE, main="Matrix Standardized Profile",
       sub = "", xlab= "", ylab="",font=2, family="", mgp = c(0, 0, 0), cex.main=0.8)
   ticks <- seq(-cutoff, cutoff, 0.5)
   tick.cols <- rep("black", 5)
   tick.lwd <- 1
   locs <- NULL
   for (k in 1:length(ticks)) locs <- c(locs, which.min(abs(ticks[k] - leg.set)))
   axis(1, at=locs, labels=ticks, adj= 0.5, tick=T, cex=0.6, cex.axis=0.6, line=0, font=2, family="", mgp = c(0.1, 0.1, 0.1))

   dev.off()

   # Vertical/Portrait versions
   
   # Plot sorted by phenotype ------------------------------------------------------------------------------

   height <- ceiling(ncol(H)/50)
   if (height < 11) height <- 11
   pdf(file=output_plot_portrait, height=height, width=8.5)
   
   nf <- layout(matrix(c(1, 2, 0, 3), nrow=2, ncol=2, byrow=T), c(2, 5), c(12, 1), FALSE)
   par(mar = c(3, 2, 4, 2))
   image(1:1, 1:length(V1.phen), t(as.matrix(V1.phen)), col=phen.col[1:max(V1.phen)], axes=FALSE, main="Phenotype", sub = "", xlab= "", ylab="")
   if (!is.null(annot_file)) {
      for (i in 1:length(leg.txt)) {
         if (cex.phen == "auto") cex.phen <- 0.05 + 7/ifelse(nchar(leg.txt[i]) < 6, 6, nchar(leg.txt[i]))
        text(1, locs.bound[i], labels=leg.txt[i], adj=c(0.5, 0), srt=0, cex=cex.phen)
      }
    }
   right.space <-  ceiling(2 + 70/nrow(H))
   par(mar = c(3, 8, 4, right.space))
   V2 <- apply(V2, MARGIN=2, FUN=rev)
   image(1:nrow(V2), 1:ncol(V2), V2, zlim = c(0, max.cont.color + 3), col=mycol, axes=FALSE, main="Matrix Sorted by Phenotype",
         sub = "", xlab= "", ylab="", cex.main=1)
   if (cex.rows == "auto") cex.rows <- 0.20 + 150/(nrow(V2) * max(nchar(row.names(V2))) + 200)

   if (!is.null(annot_file)) {   
      for (i in 1:(length(boundaries)-1)) lines(c(0.5, ncol(V2) + 0.5), c(boundaries[i]+0.5, boundaries[i]+0.5), lwd=2, lty=1, col="black")   
    }
      axis(3, at=1:nrow(V2), labels=row.names(V2), adj= 0.5, tick=FALSE, las = 1, cex.axis=cex.rows, font.axis=1, line=-1)   
      if (cex.cols == "auto") cex.cols <- 0.20 + 200/(ncol(V2) * max(nchar(colnames(V2))) + 200)
      mtext(colnames(V2), at=1:ncol(V2), side = 2, cex=cex.cols, col=cols2, line=0, las=1, font=2, family="")
   
   # Legend

   par(mar = c(3, 5, 1, 25))
   leg.set <- seq(-cutoff, cutoff, 0.05)
   image(1:length(leg.set), 1:1, as.matrix(leg.set), zlim=c(-cutoff, cutoff), col=mycol, axes=FALSE, main="Matrix Standardized Profile",
       sub = "", xlab= "", ylab="",font=2, family="", mgp = c(0, 0, 0), cex.main=0.8)
   ticks <- seq(-cutoff, cutoff, 0.5)
   tick.cols <- rep("black", 5)
   tick.lwd <- 1
   locs <- NULL
   for (k in 1:length(ticks)) locs <- c(locs, which.min(abs(ticks[k] - leg.set)))
   axis(1, at=locs, labels=ticks, adj= 0.5, tick=T, cex=0.6, cex.axis=0.6, line=0, font=2, family="", mgp = c(0.1, 0.1, 0.1))

   # Plot sorted by columns and rows ------------------------------------------------------------------------------

   nf <- layout(matrix(c(1, 2), nrow=2, ncol=1, byrow=T), 1, c(12, 1), FALSE)
   right.space <-  ceiling(2 + 70/nrow(H))
   par(mar = c(3, 8, 4, right.space))
#   par(mar = c(1, 1, 1, 1))
   V3 <- apply(V3, MARGIN=2, FUN=rev)
   image(1:nrow(V3), 1:ncol(V3), V3, zlim = c(0, max.cont.color + 3), col=mycol, axes=FALSE,  main="Matrix Sorted (Rows and Columns)",
         sub = "", xlab= "", ylab="", cex.main=1)
   if (cex.rows == "auto") cex.rows <- 0.20 + 150/(nrow(V3) * max(nchar(row.names(V3))) + 200)      
   axis(3, at=1:nrow(V3), labels=row.names(V3), adj= 0.5, tick=FALSE, las = 1, cex.axis=cex.rows, font.axis=1, line=-1)
   if (cex.cols == "auto") cex.cols <- 0.20 + 200/(ncol(V3) * max(nchar(colnames(V3))) + 200)   
   mtext(colnames(V3), at=1:ncol(V3), side = 2, cex=cex.cols, col=cols.V3, line=0, las=1, font=2, family="")

   # Legend

   par(mar = c(3, 5, 1, 25))
   leg.set <- seq(-cutoff, cutoff, 0.05)
   image(1:length(leg.set), 1:1, as.matrix(leg.set), zlim=c(-cutoff, cutoff), col=mycol, axes=FALSE, main="Matrix Standardized Profile",
       sub = "", xlab= "", ylab="",font=2, family="", mgp = c(0, 0, 0), cex.main=0.8)
   ticks <- seq(-cutoff, cutoff, 0.5)
   tick.cols <- rep("black", 5)
   tick.lwd <- 1
   locs <- NULL
   for (k in 1:length(ticks)) locs <- c(locs, which.min(abs(ticks[k] - leg.set)))
   axis(1, at=locs, labels=ticks, adj= 0.5, tick=T, cex=0.6, cex.axis=0.6, line=0, font=2, family="", mgp = c(0.1, 0.1, 0.1))

   # Plot in original order ------------------------------------------------------------------------------
   
   nf <- layout(matrix(c(1, 2), nrow=2, ncol=1, byrow=T), 1, c(12, 1), FALSE)
   right.space <-  ceiling(2 + 70/nrow(H))
   par(mar = c(3, 8, 4, right.space))
   V4 <- apply(V4, MARGIN=2, FUN=rev)
   image(1:nrow(V4), 1:ncol(V4), V4, zlim = c(0, max.cont.color + 3), col=mycol, axes=FALSE, main="Matrix in Original Order",
         sub = "", xlab= "", ylab="", cex.main=1)
   if (cex.rows == "auto") cex.rows <- 0.20 + 150/(nrow(V4) * max(nchar(row.names(V4))) + 200)         
   axis(3, at=1:nrow(V4), labels=row.names(V4), adj= 0.5, tick=FALSE, las = 1, cex.axis=cex.rows, font.axis=1, line=-1)
   if (cex.cols == "auto") cex.cols <- 0.20 + 200/(ncol(V4) * max(nchar(colnames(V4))) + 200)      
   mtext(colnames(V4), at=1:ncol(V4), side = 2, cex=cex.cols, col=cols.V4, line=0, las=1, font=2, family="")

   # Legend

   par(mar = c(3, 5, 1, 25))   
   leg.set <- seq(-cutoff, cutoff, 0.05)
   image(1:length(leg.set), 1:1, as.matrix(leg.set), zlim=c(-cutoff, cutoff), col=mycol, axes=FALSE, main="Matrix Standardized Profile",
       sub = "", xlab= "", ylab="",font=2, family="", mgp = c(0, 0, 0), cex.main=0.8)
   ticks <- seq(-cutoff, cutoff, 0.5)
   tick.cols <- rep("black", 5)
   tick.lwd <- 1
   locs <- NULL
   for (k in 1:length(ticks)) locs <- c(locs, which.min(abs(ticks[k] - leg.set)))
   axis(1, at=locs, labels=ticks, adj= 0.5, tick=T, cex=0.6, cex.axis=0.6, line=0, font=2, family="", mgp = c(0.1, 0.1, 0.1))

   dev.off()
   
 }

   DISSECTOR_make_heatmap_of_matrix.v2 <- function(
      #
      # Make heatmap of matrix from GCT file
      #
      input_dataset,                 # Input dataset (GCT). This is e.g. the original dataset A or the H matrix
      annot_file = NULL,             # Phenotype annotation file (TXT, optional) in format c(file, name_column, annot_column, use_prefix, color_column or NULL)
      transpose_data = F,            # Transpose input matrix
      append_annot = F,              # Append annotation to column names
      sort_columns = T,              # Sort columns in heatmap
      sort_rows = T,                 # Sort rows in heatmap
      order_phenotypes_by_size = F,  # Order phenotypes by size
      produce_average_over_phen_heatmap = F, # Produce a heatmap of average values per phenotype
      cex.rows = "auto",             # Character size for row names
      cex.cols = "auto",             # Character size for col names
      cex.phen = "auto",             # Character size for phenotype names
      str.phen = "90",               # Degrees: orientation of phenotype labels                                                  
      output_plot_landscape,         # Output (PDF) plot in landscape format
      output_plot_portrait)          # Output (PDF) plot in portrait format
  {

   set.seed(5209761)
       
   # Read input dataset

   dataset.1 <- MSIG.Gct2Frame(filename = input_dataset)
   H <- data.matrix(dataset.1$ds)
   print(dim(H))

   print("Components (row) sum amplitudes:")
   print(cbind(sort(apply(H, MARGIN=1, FUN=sum), decreasing=T)))

   if (transpose_data == T) H <- t(H)

   width <- ceiling(ncol(H)/100)
   if (width < 11) width <- 14
   pdf(file=output_plot_landscape, height=8.5, width=width)
   
   # Read annotation file
 
   if (!is.null(annot_file)) {
      annot.table <- read.table(annot_file[[1]], header=T, sep="\t", skip=0, colClasses = "character")
      column.list <- annot.table[, annot_file[[2]]]
      annot.list <- annot.table[, annot_file[[3]]]
      column.set <- vector(length=ncol(H), mode="character")
      if (annot_file[[4]] == T) {
         for (i in 1:ncol(H)) {
            column.set[i] <- strsplit(colnames(H)[i], split="_")[[1]]
         }
      } else {
         column.set <- colnames(H)
      }
      locs <- match(column.set, column.list)
      print(length(column.set))
#      print(column.set[1:10])
      print(length(column.list))      
#      print(column.list[1:10])
#      print(column.list[locs[!is.na(locs)]])
      print(paste(length(locs[!is.na(locs)]), " samples match the annotation table"))
      column.class <- annot.list[locs]
      column.class[is.na(column.class)] <- "UNLABELED"
#      for (k in 1:length(column.class)) column.class[k] <- substr(column.class[k], 1, 20)
      all.classes <- unique(column.class)
      print(table(column.class))
      if (append_annot == T) colnames(H) <- paste(colnames(H), " (", column.class, ") ", sep="")

      # is there a color for each annotation

      if (length(annot_file) > 4) {
         if (!is.null(annot.table[, annot_file[[5]]])) {
           phen.col <- annot.table[, annot_file[[5]]]
         }
      } else {  # define general colors
         phen.col <-   c(brewer.pal(7, "Dark2"), brewer.pal(7, "Set1"), brewer.pal(7, "Dark2"), brewer.pal(7, "Set1"), brewer.pal(7, "Paired"),
                         brewer.pal(8, "Accent"), brewer.pal(8, "Set2"), brewer.pal(11, "Spectral"), brewer.pal(12, "Set3"))
      }
      
   } else {
      column.class <- rep(" ", ncol(H))
      all.classes <- " "
      phen.col <-   c(brewer.pal(7, "Dark2"), brewer.pal(7, "Set1"), brewer.pal(7, "Dark2"), brewer.pal(7, "Set1"), brewer.pal(7, "Paired"),
                      brewer.pal(8, "Accent"), brewer.pal(8, "Set2"), brewer.pal(11, "Spectral"), brewer.pal(12, "Set3"))
   }
  
   # Color map
 
   mycol <- vector(length=512, mode = "numeric")
   for (k in 1:256) mycol[k] <- rgb(255, k - 1, k - 1, maxColorValue=255)
   for (k in 257:512) mycol[k] <- rgb(511 - (k - 1), 511 - (k - 1), 255, maxColorValue=255)
   mycol <- rev(mycol)
   max.cont.color <- 511
   mycol <- c(mycol,
              "black",  # brewer.pal(9, "YlGn")[1],     # Missing feature color (light yellow)
              mycol[256 - 75],                          # Binary feature's 0's color (blue)
              mycol[256 + 220])                         # Binary feature's 1's color (red)
   cex.axis = 1

    # Normalize and apply color map

   cutoff <- 2
   for (i in 1:nrow(H)) {
      x <- H[i,]
      locs.non.na <- !is.na(x)
      x.nonzero <- x[locs.non.na]
      x.nonzero2 <- (x.nonzero - mean(x.nonzero))/sd(x.nonzero)         
      x.nonzero2[x.nonzero2 > cutoff] <- cutoff
      x.nonzero2[x.nonzero2 < - cutoff] <- - cutoff      
      s <- strsplit(row.names(H)[i], "_")[[1]]
      suffix <- s[length(s)]
      if (suffix == "MUT" | suffix == "AMP" | suffix == "DEL" | suffix == "AMP_2" | suffix == "AMP_3" | suffix == "DEL_2" | suffix == "DEL_3" |
          suffix == "all" | length(table(x.nonzero)) == 2) {  # Binary feature
         H[i,locs.non.na] <- x.nonzero + max.cont.color + 2   # binary feature colors
       } else {
         H[i, locs.non.na] <- x.nonzero2
         H[i, locs.non.na] <- ceiling(max.cont.color * (H[i,locs.non.na] + cutoff)/(2*cutoff))
         H[i, locs.non.na] <- ifelse (H[i, locs.non.na] > max.cont.color, max.cont.color, H[i, locs.non.na])
       }
      H[i, is.na(x)] <- max.cont.color + 1 # missing feature color 
    }

   # Horizontal/Landscape versions
   
   # Plot sorted by phenotype ------------------------------------------------------------------------------

   nf <- layout(matrix(c(1, 2, 3), nrow=3, ncol=1, byrow=T), 1, c(1, 6.5, 0.75), FALSE)

   H_orig <- H
   column.class_orig <- column.class

   if (order_phenotypes_by_size == T) {

      num.class <- match(column.class, all.classes)
      sizes <- table(num.class)
      ind.sizes <- order(sizes, decreasing=T)
      seq.ind <- seq(1, length(sizes))
      num.class <- match(num.class, ind.sizes)
      ind <- order(num.class, decreasing=F)
      H <- H[, ind]
      column.class <- column.class[ind]
      all.classes <- unique(column.class)

   } else {
      ind <- order(column.class, decreasing=F)
      H <- H[, ind]
      column.class <- column.class[ind]
      all.classes <- sort(unique(column.class))
   }
   
   V1.phen <- match(column.class, all.classes)
   par(mar = c(1, 10, 2, 6))
   image(1:length(V1.phen), 1:1, as.matrix(V1.phen), col=phen.col[1:max(V1.phen)], axes=FALSE, main="Phenotype", sub = "", xlab= "", ylab="")
   axis(2, at=1:1, labels="Phenotype", adj= 0.5, tick=FALSE, las = 1, cex.axis=1, font.axis=1, line=-1)

   if (!is.null(annot_file)) {
      leg.txt <- all.classes
      for (i in 1:length(leg.txt)) leg.txt[i] <- substr(leg.txt[i], 1, 25)
      boundaries <- NULL
      for (i in 2:length(column.class)) {
         if (column.class[i] != column.class[i-1]) boundaries <- c(boundaries, i-1)
      }
      boundaries <- c(boundaries, length(column.class))
      locs.bound <- c(boundaries[1]/2, boundaries[2:length(boundaries)]
                   - (boundaries[2:length(boundaries)] - boundaries[1:(length(boundaries)-1)])/2)
      sizes <- boundaries - c(1, boundaries[1:(length(boundaries) -1)])
      print(sizes)
      for (i in 1:length(leg.txt)) {
         if (cex.phen == "auto") {
             cex <- 0.05 + 7/ifelse(nchar(leg.txt[i]) < 6, 6, nchar(leg.txt[i]))
         } else if (cex.phen == "auto2") {
             cex <- 0.40 + 0.125*sizes[i]/nchar(leg.txt[i])
             print(cex)
         } else {
            cex <- cex.phen
        }
        text(locs.bound[i], 1, labels=leg.txt[i], adj=c(0.25, 0.5), srt=str.phen, cex=cex)
#         text(locs.bound[i], 1, labels=leg.txt[i], adj=c(0, 0), srt=str.phen, cex=cex)      
       }
    }
   
  # Sort columns inside each phenotypic class 
   
   for (k in all.classes) {
      if (sum(column.class == k) <= 1) next;
      V1 <- H[, column.class == k]
      col.names.V1 <- colnames(H)[column.class == k]
      dist.matrix <- DISSECTOR_compute_assoc_or_dist.v1(input_matrix1 = V1, input_matrix2 = V1, object_type = "columns",
                                                     assoc_metric = "IC", distance = T)

      HC <- hclust(dist.matrix, method="ward")
      ind <- HC$order
      V1 <- V1[ , ind]
      H[, column.class == k] <- V1
      col.names.V1 <- col.names.V1[ind]
      colnames(H)[column.class == k] <- col.names.V1 
   }
 
   V2 <- apply(H, MARGIN=2, FUN=rev)

   lower.space <-  ceiling(4 + 100/nrow(H))
   par(mar = c(lower.space, 10, 2, 6))

   image(1:ncol(V2), 1:nrow(V2), t(V2), zlim = c(0, max.cont.color + 3), col=mycol, axes=FALSE, main="Matrix Sorted by Phenotype",
         sub = "", xlab= "", ylab="", cex.main=1)
   if (cex.rows == "auto") cex.rows <- 0.20 + 200/(nrow(V2) * max(nchar(row.names(V2))) + 200)

   axis(2, at=1:nrow(V2), labels=row.names(V2), adj= 0.5, tick=FALSE, las = 1, cex.axis=cex.rows, font.axis=1, line=-1)
   if (!is.null(annot_file)) {   
      for (i in 1:(length(boundaries)-1)) lines(c(boundaries[i]+0.5, boundaries[i]+0.5), c(0.5, nrow(V2) + 0.5), lwd=2, lty=1, col="black")
    }
   if (!is.null(annot_file)) {
      cols2 <- phen.col[match(column.class, all.classes)]
   } else {
      cols2 = "black"
   }
   if (cex.cols == "auto") cex.cols <- 0.20 + 200/(ncol(V2) * max(nchar(colnames(V2))) + 200)
   mtext(colnames(V2), at=1:ncol(V2), side = 1, cex=cex.cols, col=cols2, line=0, las=3, font=2, family="")
   
   # Legend

   par(mar = c(3, 35, 1, 6))
   leg.set <- seq(-cutoff, cutoff, 0.05)
   image(1:length(leg.set), 1:1, as.matrix(leg.set), zlim=c(-cutoff, cutoff), col=mycol, axes=FALSE, main="Matrix Standardized Profile",
       sub = "", xlab= "", ylab="",font=2, family="", mgp = c(0, 0, 0), cex.main=0.8)
   ticks <- seq(-cutoff, cutoff, 0.5)
   tick.cols <- rep("black", 5)
   tick.lwd <- 1
   locs <- NULL
   for (k in 1:length(ticks)) locs <- c(locs, which.min(abs(ticks[k] - leg.set)))
   axis(1, at=locs, labels=ticks, adj= 0.5, tick=T, cex=0.6, cex.axis=0.6, line=0, font=2, family="", mgp = c(0.1, 0.1, 0.1))


   if (produce_average_over_phen_heatmap == T) {

     H.mean <- NULL
     for (k in 1:nrow(H)) {
        H.row <- unlist(lapply(split(H[k,], V1.phen), mean))
        H.mean <- rbind(H.mean, H.row)
     }
     row.names(H.mean) <- row.names(H)
     colnames(H.mean) <- all.classes

     nf <- layout(matrix(c(1, 2, 3), nrow=3, ncol=1, byrow=T), 1, c(1, 6.5, 0.75), FALSE)
     par(mar = c(1, 10, 2, 6))

     image(1:ncol(H.mean), 1:1, as.matrix(1:ncol(H.mean)), col=phen.col[1:ncol(H.mean)], axes=FALSE, main="Phenotype", sub = "", xlab= "", ylab="")
     axis(2, at=1:1, labels="Phenotype", adj= 0.5, tick=FALSE, las = 1, cex.axis=1, font.axis=1, line=-1)

     for (i in 1:ncol(H.mean))  text(i, 1, labels=all.classes[i], adj=c(0.25, 0.5), srt=str.phen, cex=cex)
     
     VX <- apply(H.mean, MARGIN=2, FUN=rev)
     lower.space <-  ceiling(4 + 100/nrow(H.mean))
     par(mar = c(lower.space, 10, 2, 6))

     image(1:ncol(VX), 1:nrow(VX), t(VX), zlim = c(0, max.cont.color + 3), col=mycol, axes=FALSE, main="Matrix Averaged by Phenotype",
         sub = "", xlab= "", ylab="", cex.main=1)

     axis(2, at=1:nrow(VX), labels=row.names(VX), adj= 0.5, tick=FALSE, las = 1, cex.axis=cex.rows, font.axis=1, line=-1)

   # Legend

     par(mar = c(3, 35, 1, 6))
     leg.set <- seq(-cutoff, cutoff, 0.05)
     image(1:length(leg.set), 1:1, as.matrix(leg.set), zlim=c(-cutoff, cutoff), col=mycol, axes=FALSE, main="Matrix Standardized Profile",
       sub = "", xlab= "", ylab="",font=2, family="", mgp = c(0, 0, 0), cex.main=0.8)
     ticks <- seq(-cutoff, cutoff, 0.5)
     tick.cols <- rep("black", 5)
     tick.lwd <- 1
     locs <- NULL
     for (k in 1:length(ticks)) locs <- c(locs, which.min(abs(ticks[k] - leg.set)))
     axis(1, at=locs, labels=ticks, adj= 0.5, tick=T, cex=0.6, cex.axis=0.6, line=0, font=2, family="", mgp = c(0.1, 0.1, 0.1))
 }
   
   # Plot sorted by columns and rows ------------------------------------------------------------------------------

   nf <- layout(matrix(c(1, 2), 2, 1, byrow=T), 1, c(8, 1), FALSE)

   H <- H_orig
   column.class <- column.class_orig 

   if (sort_columns == T) {
      dist.matrix <- DISSECTOR_compute_assoc_or_dist.v1(input_matrix1 = H, input_matrix2 = H, object_type = "columns",
                                                     assoc_metric = "IC", distance = T)
      hc <- hclust(dist.matrix, method="ward")
      ind1 <- hc$order
      H <- H[, ind1]
      column.class <- column.class[ind1]
   }
   if (sort_rows == T) {
      dist.matrix <- DISSECTOR_compute_assoc_or_dist.v1(input_matrix1 = H, input_matrix2 = H, object_type = "rows",
                                                     assoc_metric = "IC", distance = T)
      hc2 <- hclust(dist.matrix, method="ward")
      ind2 <- hc2$order
      H <- H[ind2,]
   }
   V3 <- apply(H, MARGIN=2, FUN=rev)
#   lower.space <-  ceiling(3 + 100/nrow(H))
   lower.space <-  ceiling(3 + 50/nrow(H))   
#   par(mar = c(lower.space, 12, 2, 4))
      par(mar = c(3, 12, 2, 4))
   image(1:ncol(V3), 1:nrow(V3), t(V3), zlim = c(0, max.cont.color + 3), col=mycol, axes=FALSE, main="Matrix Sorted (Rows and Columns)",
         sub = "", xlab= "", ylab="", cex.main=1)
   if (cex.rows == "auto")  cex.rows <- 0.20 + 200/(nrow(V3) * max(nchar(row.names(V3))) + 200)
   axis(2, at=1:nrow(V3), labels=row.names(V3), adj= 0.5, tick=FALSE, las = 1, cex.axis=cex.rows, font.axis=1, line=-1)   
#   axis(1, at=1:ncol(V), labels=colnames(V), adj= 0.5, tick=FALSE, las = 3, cex.axis=cex.cols, font.axis=1, line=-1) # Add sample names        

   if (!is.null(annot_file)) {
      cols.V3 <- phen.col[match(column.class, all.classes)]
   } else {
      cols.V3 = "black"
   }
   if (cex.cols == "auto") cex.cols <- 0.20 + 200/(ncol(V3) * max(nchar(colnames(V3))) + 200)
   mtext(colnames(V3), at=1:ncol(V3), side = 1, cex=cex.cols, col=cols.V3, line=0, las=3, font=2, family="")

   # Legend

   par(mar = c(3, 35, 1, 6))
   leg.set <- seq(-cutoff, cutoff, 0.05)
   image(1:length(leg.set), 1:1, as.matrix(leg.set), zlim=c(-cutoff, cutoff), col=mycol, axes=FALSE, main="Matrix Standardized Profile",
       sub = "", xlab= "", ylab="",font=2, family="", mgp = c(0, 0, 0), cex.main=0.8)
   ticks <- seq(-cutoff, cutoff, 0.5)
   tick.cols <- rep("black", 5)
   tick.lwd <- 1
   locs <- NULL
   for (k in 1:length(ticks)) locs <- c(locs, which.min(abs(ticks[k] - leg.set)))
   axis(1, at=locs, labels=ticks, adj= 0.5, tick=T, cex=0.6, cex.axis=0.6, line=0, font=2, family="", mgp = c(0.1, 0.1, 0.1))

   # Plot in original order ------------------------------------------------------------------------------

   H <- H_orig
   column.class <- column.class_orig
   
   nf <- layout(matrix(c(1, 2), 2, 1, byrow=T), 1, c(8, 1), FALSE)

   V4 <- apply(H, MARGIN=2, FUN=rev)
   lower.space <-  ceiling(4 + 25/nrow(H))
#   par(mar = c(4, 16, 2, 6))   
   par(mar = c(lower.space, 16, 2, 6))

   image(1:ncol(V4), 1:nrow(V4), t(V4), zlim = c(0, max.cont.color + 3), col=mycol, axes=FALSE, main="Matrix in Original Order",
         sub = "", xlab= "", ylab="", cex.main=0.8)
   if (cex.rows == "auto") cex.rows <- 0.20 + 200/(nrow(V4) * max(nchar(row.names(V4))) + 200)   
   axis(2, at=1:nrow(V4), labels=row.names(V4), adj= 0.5, tick=FALSE, las = 1, cex.axis=cex.rows, font.axis=1, line=-1)
   if (cex.cols == "auto") cex.cols <- 0.20 + 200/(ncol(V4) * max(nchar(colnames(V4))) + 200)   

   if (!is.null(annot_file)) {
      cols.V4 <- phen.col[match(column.class, all.classes)]
   } else {
      cols.V4 = "black"
   }
   if (cex.cols == "auto") cex.cols <- 0.20 + 200/(ncol(V4) * max(nchar(colnames(V4))) + 200)
   mtext(colnames(V4), at=1:ncol(V4), side = 1, cex=cex.cols, col=cols.V4, line=0, las=3, font=2, family="")

   # Legend

   par(mar = c(3, 32, 1, 6))
   leg.set <- seq(-cutoff, cutoff, 0.05)
   image(1:length(leg.set), 1:1, as.matrix(leg.set), zlim=c(-cutoff, cutoff), col=mycol, axes=FALSE, main="Matrix Standardized Profile",
       sub = "", xlab= "", ylab="",font=2, family="", mgp = c(0, 0, 0), cex.main=0.8)
   ticks <- seq(-cutoff, cutoff, 0.5)
   tick.cols <- rep("black", 5)
   tick.lwd <- 1
   locs <- NULL
   for (k in 1:length(ticks)) locs <- c(locs, which.min(abs(ticks[k] - leg.set)))
   axis(1, at=locs, labels=ticks, adj= 0.5, tick=T, cex=0.6, cex.axis=0.6, line=0, font=2, family="", mgp = c(0.1, 0.1, 0.1))

   dev.off()

   # Vertical/Portrait versions
   
   # Plot sorted by phenotype ------------------------------------------------------------------------------

   height <- ceiling(ncol(H)/50)
   if (height < 11) height <- 11
   pdf(file=output_plot_portrait, height=height, width=8.5)
   
   nf <- layout(matrix(c(1, 2, 0, 3), nrow=2, ncol=2, byrow=T), c(2, 5), c(12, 1), FALSE)
   par(mar = c(3, 2, 4, 2))
   image(1:1, 1:length(V1.phen), t(as.matrix(V1.phen)), col=phen.col[1:max(V1.phen)], axes=FALSE, main="Phenotype", sub = "", xlab= "", ylab="")
   if (!is.null(annot_file)) {
      for (i in 1:length(leg.txt)) {
         if (cex.phen == "auto") cex.phen <- 0.05 + 7/ifelse(nchar(leg.txt[i]) < 6, 6, nchar(leg.txt[i]))
        text(1, locs.bound[i], labels=leg.txt[i], adj=c(0.5, 0), srt=0, cex=cex.phen)
      }
    }
   right.space <-  ceiling(2 + 70/nrow(H))
   par(mar = c(3, 8, 4, right.space))
   V2 <- apply(V2, MARGIN=2, FUN=rev)
   image(1:nrow(V2), 1:ncol(V2), V2, zlim = c(0, max.cont.color + 3), col=mycol, axes=FALSE, main="Matrix Sorted by Phenotype",
         sub = "", xlab= "", ylab="", cex.main=1)
   if (cex.rows == "auto") cex.rows <- 0.20 + 150/(nrow(V2) * max(nchar(row.names(V2))) + 200)

   if (!is.null(annot_file)) {   
      for (i in 1:(length(boundaries)-1)) lines(c(0.5, ncol(V2) + 0.5), c(boundaries[i]+0.5, boundaries[i]+0.5), lwd=2, lty=1, col="black")   
    }
      axis(3, at=1:nrow(V2), labels=row.names(V2), adj= 0.5, tick=FALSE, las = 1, cex.axis=cex.rows, font.axis=1, line=-1)   
      if (cex.cols == "auto") cex.cols <- 0.20 + 200/(ncol(V2) * max(nchar(colnames(V2))) + 200)
      mtext(colnames(V2), at=1:ncol(V2), side = 2, cex=cex.cols, col=cols2, line=0, las=1, font=2, family="")
   
   # Legend

   par(mar = c(3, 5, 1, 25))
   leg.set <- seq(-cutoff, cutoff, 0.05)
   image(1:length(leg.set), 1:1, as.matrix(leg.set), zlim=c(-cutoff, cutoff), col=mycol, axes=FALSE, main="Matrix Standardized Profile",
       sub = "", xlab= "", ylab="",font=2, family="", mgp = c(0, 0, 0), cex.main=0.8)
   ticks <- seq(-cutoff, cutoff, 0.5)
   tick.cols <- rep("black", 5)
   tick.lwd <- 1
   locs <- NULL
   for (k in 1:length(ticks)) locs <- c(locs, which.min(abs(ticks[k] - leg.set)))
   axis(1, at=locs, labels=ticks, adj= 0.5, tick=T, cex=0.6, cex.axis=0.6, line=0, font=2, family="", mgp = c(0.1, 0.1, 0.1))

   # Plot sorted by columns and rows ------------------------------------------------------------------------------

   nf <- layout(matrix(c(1, 2), nrow=2, ncol=1, byrow=T), 1, c(12, 1), FALSE)
   right.space <-  ceiling(2 + 70/nrow(H))
   par(mar = c(3, 8, 4, right.space))
   V3 <- apply(V3, MARGIN=2, FUN=rev)
   image(1:nrow(V3), 1:ncol(V3), V3, zlim = c(0, max.cont.color + 3), col=mycol, axes=FALSE,  main="Matrix Sorted (Rows and Columns)",
         sub = "", xlab= "", ylab="", cex.main=1)
   if (cex.rows == "auto") cex.rows <- 0.20 + 150/(nrow(V3) * max(nchar(row.names(V3))) + 200)      
   axis(3, at=1:nrow(V3), labels=row.names(V3), adj= 0.5, tick=FALSE, las = 1, cex.axis=cex.rows, font.axis=1, line=-1)
   if (cex.cols == "auto") cex.cols <- 0.20 + 200/(ncol(V3) * max(nchar(colnames(V3))) + 200)   
   mtext(colnames(V3), at=1:ncol(V3), side = 2, cex=cex.cols, col=cols.V3, line=0, las=1, font=2, family="")

   # Legend

   par(mar = c(3, 5, 1, 25))
   leg.set <- seq(-cutoff, cutoff, 0.05)
   image(1:length(leg.set), 1:1, as.matrix(leg.set), zlim=c(-cutoff, cutoff), col=mycol, axes=FALSE, main="Matrix Standardized Profile",
       sub = "", xlab= "", ylab="",font=2, family="", mgp = c(0, 0, 0), cex.main=0.8)
   ticks <- seq(-cutoff, cutoff, 0.5)
   tick.cols <- rep("black", 5)
   tick.lwd <- 1
   locs <- NULL
   for (k in 1:length(ticks)) locs <- c(locs, which.min(abs(ticks[k] - leg.set)))
   axis(1, at=locs, labels=ticks, adj= 0.5, tick=T, cex=0.6, cex.axis=0.6, line=0, font=2, family="", mgp = c(0.1, 0.1, 0.1))

   # Plot in original order ------------------------------------------------------------------------------
   
   nf <- layout(matrix(c(1, 2), nrow=2, ncol=1, byrow=T), 1, c(12, 1), FALSE)
   right.space <-  ceiling(2 + 70/nrow(H))
   par(mar = c(3, 8, 4, right.space))
   V4 <- apply(V4, MARGIN=2, FUN=rev)
   image(1:nrow(V4), 1:ncol(V4), V4, zlim = c(0, max.cont.color + 3), col=mycol, axes=FALSE, main="Matrix in Original Order",
         sub = "", xlab= "", ylab="", cex.main=1)
   if (cex.rows == "auto") cex.rows <- 0.20 + 150/(nrow(V4) * max(nchar(row.names(V4))) + 200)         
   axis(3, at=1:nrow(V4), labels=row.names(V4), adj= 0.5, tick=FALSE, las = 1, cex.axis=cex.rows, font.axis=1, line=-1)
   if (cex.cols == "auto") cex.cols <- 0.20 + 200/(ncol(V4) * max(nchar(colnames(V4))) + 200)      
   mtext(colnames(V4), at=1:ncol(V4), side = 2, cex=cex.cols, col=cols.V4, line=0, las=1, font=2, family="")

  # Legend

   par(mar = c(3, 5, 1, 25))   
   leg.set <- seq(-cutoff, cutoff, 0.05)
   image(1:length(leg.set), 1:1, as.matrix(leg.set), zlim=c(-cutoff, cutoff), col=mycol, axes=FALSE, main="Matrix Standardized Profile",
       sub = "", xlab= "", ylab="",font=2, family="", mgp = c(0, 0, 0), cex.main=0.8)
   ticks <- seq(-cutoff, cutoff, 0.5)
   tick.cols <- rep("black", 5)
   tick.lwd <- 1
   locs <- NULL
   for (k in 1:length(ticks)) locs <- c(locs, which.min(abs(ticks[k] - leg.set)))
   axis(1, at=locs, labels=ticks, adj= 0.5, tick=T, cex=0.6, cex.axis=0.6, line=0, font=2, family="", mgp = c(0.1, 0.1, 0.1))

   dev.off()
   
 }

   DISSECTOR_project_dataset.v1 <- function(
      #
      # Project a dataset in the space defined by a W matrix
      #
      input_dataset,                    # Input dataset (GCT)
      input_normalization = "rank",     # Normalization for the input dataset: "rank"
      normalize_after_match = T,        # Normalize input dataset after matching with rows of W
      projection_method = "NNLS",       # Projection Method: NNLS=Non Negative Linear Solver, INV= Pseudo Inverse  
      input_W_dataset,                  # Input W matrix (GCT)
      W_normalization = "none",         # Normalization for W                                            
      output_H_dataset,                 # Output dataset H (GCT)
      output_W_dataset = NULL)          # Output dataset normalized W (GCT)                                            
  {

   set.seed(5209761)
       
   # Read input dataset

   dataset.1 <- MSIG.Gct2Frame(filename = input_dataset)
   m <- data.matrix(dataset.1$ds)
   print(dim(m))

   if (normalize_after_match == F) {  # Normalize input data here before matching with W
     if (input_normalization == "rank") {
         print("A before normalization:")

         max.n <- 10000
         for (i in 1:ncol(m)) m[,i] <- (max.n - 1) * (rank(m[,i]) - 1) /(nrow(m) - 1) + 1

         print("A after normalization:")
   
      } else if (input_normalization == "none") {   

      } else {
         stop(paste("ERROR: unknown input normalization:", input_normalization))  
      }
   }
   
   dataset.2 <- MSIG.Gct2Frame(filename = input_W_dataset)
   W <- data.matrix(dataset.2$ds)
   print(dim(W))

   k.comp <- ncol(W)

  # match gene lists

  overlap <- intersect(row.names(W), row.names(m))
  print(paste("overlap:", length(overlap)))
  locs1 <- match(overlap, row.names(m))
  locs2 <- match(overlap, row.names(W))
  m <- m[locs1,]
  W <- W[locs2,]

  ind <- order(row.names(W))
  W <- W[ind,]
  m <- m[ind,]

  if (normalize_after_match == T) {  # Normalize input data here after matching with W
     if (input_normalization == "rank") {

         max.n <- 10000
         for (i in 1:ncol(m)) m[,i] <- (max.n - 1) * (rank(m[,i]) - 1) /(nrow(m) - 1) + 1
 
      } else if (input_normalization == "none") {   

      } else {
         stop(paste("ERROR: unknown input normalization:", input_normalization))  
      }
   }

  # Normalize W

  if (W_normalization == "equal_sum") {
     norm.factors <- apply(W, MARGIN=2, FUN=sum)
     for (i in 1:ncol(W)) {
        W[, i] <- 1000*W[, i]/norm.factors[i]
      }
   }

   H <- matrix(0, nrow=k.comp, ncol= ncol(m), dimnames=list(colnames(W), colnames(m)))
   if (projection_method == "NNLS") {   # non-negative linear solver
      for (i in 1:ncol(H)) H[, i] <- nnls.fit(W, m[, i], wsqrt=1, eps=0, rank.tol=1e-07)
   } else if (projection_method == "INV") {  # Pseudo-inverse
       H <- ginv(W) %*% m
       row.names(H) <- colnames(W)
       colnames(H) <- colnames(m)
       H[H < 0] <- .Machine$double.eps   # Eliminate negative entries
   } else {
       stop(paste("ERROR: Unknown projection method:", projection_method))
   }

   # Save H matrix

   write.gct.2(gct.data.frame = H, descs = row.names(H), filename = output_H_dataset)

   # Save (optional) normalized W
   
   if(!(is.null(output_W_dataset))) write.gct.2(gct.data.frame = W, descs = row.names(W), filename = output_W_dataset)

 }

   DISSECTOR_generate_association_matrix.v1 <- function(
      #
      #  For an input file generate the association matrix between the columns (perturbation/states)
      #
      input_dataset,                    # Input dataset (GCT). This is e.g. an original dataset A or the H matrix
      input_dataset2 = NULL,            # Second input dataset (GCT). This is e.g. an original dataset A or the H matrix                                       
      association_type = "columns",     # Type of association: between "columns" or between "rows"
      exclude_suffix = F,               # Exclude suffix (sub-string after last "_") from row/column names
      annot_file = NULL,                # Column or row annotation file (TXT, optional) in format c(file, name_column, annot_column, use_prefix)
      annot_file2 = NULL,               # Column or row annotation file (TXT, optional) in format c(file, name_column, annot_column, use_prefix)      
      association_metric = "IC",        # Association metric: "IC" (Information Coefficient), "ICR" (IC ranked), "COR" (Pearson), "SPEAR" (Spearman)
      output_assoc_matrix_file,         # Output (GCT) file with association matrix
      output_assoc_plot,                # Output (PDF) file with association plot
      cex.rows = "auto",                # Size of row labels
      cex.cols = "auto",                # Size of col labels
      sort.matrix = T)                  # Sort matrix

   {

   set.seed(5209761)
   
   # Read input dataset

   dataset.1 <- MSIG.Gct2Frame(filename = input_dataset)
   H <- data.matrix(dataset.1$ds)
   print(paste("Dimensions dataset1:", dim(H)))
   if (association_type == "rows") H <- t(H)

   size <- ncol(H)/50
   if (size < 11) size <- 11
   pdf(file=output_assoc_plot, height=size, width=size)

   s <- strsplit(input_dataset, split="/")
   file.name <- s[[1]][length(s[[1]])]

   if (exclude_suffix == T) {
      row.names.H <- vector(length=nrow(H), mode="character")
      for (i in 1:nrow(H)) {
         temp <- unlist(strsplit(row.names(H)[i], split="_"))
         row.names.H[i] <- paste(temp[1:(length(temp)-1)], collaps="_")
     }
   } else {
      row.names.H <- row.names(H)
   }
 
   if (!is.null(input_dataset2)) {
      dataset.2 <- MSIG.Gct2Frame(filename = input_dataset2)
      H2 <- data.matrix(dataset.2$ds)
      print(paste("Dimensions dataset2:", dim(H2)))

     s <- strsplit(input_dataset2, split="/")
     file.name2 <- s[[1]][length(s[[1]])]

      if (association_type == "rows") H2 <- t(H2)

      if (exclude_suffix == T) {
         row.names.H2 <- vector(length=nrow(H2), mode="character")
         for (i in 1:nrow(H2)) {
            temp <- unlist(strsplit(row.names(H2)[i], split="_"))
            row.names.H2[i] <- paste(temp[1:(length(temp)-1)], collaps="_")
         }
      } else {
         row.names.H2 <- row.names(H2)
      }

   } else {
      H2 <- H
      row.names.H2 <- row.names.H
      file.name2 <- file.name
    }
   
   # Read annotation file

   if (!is.null(annot_file)) {
      annot.table <- read.table(annot_file[[1]], header=T, sep="\t", skip=0, colClasses = "character")
      gene.list <- annot.table[, annot_file[[2]]]
      annot.list <- annot.table[, annot_file[[3]]]
      gene.set <- vector(length=ncol(H), mode="character")
      if (annot_file[[4]] == T) {
         for (i in 1:ncol(H)) {
            gene.set[i] <- strsplit(colnames(H)[i], split="_")[[1]]
         }
      } else {
         gene.set <- colnames(H)
      }
      locs <- match(gene.set, gene.list)
      gene.class <- annot.list[locs]
      for (k in 1:length(gene.class)) gene.class[k] <- substr(gene.class[k], 1, 10)
      all.classes <- sort(unique(gene.class))
      colnames(H) <- paste(colnames(H), " (", gene.class, ") ", sep="")
    } else {
      gene.class <- rep(" ", ncol(H))
      all.classes <- " "
   }
   
   if (!is.null(annot_file2)) {
      annot.table2 <- read.table(annot_file2[[1]], header=T, sep="\t", skip=0, colClasses = "character")
      gene.list2 <- annot.table2[, annot_file2[[2]]]
      annot.list2 <- annot.table2[, annot_file2[[3]]]
      gene.set2 <- vector(length=ncol(H2), mode="character")
      if (annot_file2[[4]] == T) {
         for (i in 1:ncol(H2)) {
            gene.set2[i] <- strsplit(colnames(H2)[i], split="_")[[1]]
         }
      } else {
         gene.set2 <- colnames(H2)
      }
      locs <- match(gene.set2, gene.list2)
      gene.class2 <- annot.list2[locs]
      for (k in 1:length(gene.class2)) gene.class2[k] <- substr(gene.class2[k], 1, 10)
      all.classes2 <- sort(unique(gene.class2))
      colnames(H2) <- paste(colnames(H2), " (", gene.class2, ") ", sep="")
    } else if (!is.null(annot_file)) {
       all.classes2 <- all.classes
       gene.class2 <- gene.class
    }

   # Define overlapping set

   overlap <- intersect(row.names.H, row.names.H2)
   print(paste("Size of overlap space:", length(overlap)))
   locs1 <- match(overlap, row.names.H)
   locs2 <- match(overlap, row.names.H2)   
   H <- H[locs1,]
   H2 <- H2[locs2,]

   # Signatures association plot
       
   nf <- layout(matrix(c(1, 2), 2, 1, byrow=T), 1, c(8, 1), FALSE)

   mycol <- vector(length=512, mode = "numeric")   # Red/Blue "pinkogram" color map
   for (k in 1:256) mycol[k] <- rgb(255, k - 1, k - 1, maxColorValue=255)
   for (k in 257:512) mycol[k] <- rgb(511 - (k - 1), 511 - (k - 1), 255, maxColorValue=255)
   mycol <- rev(mycol)
   ncolors <- length(mycol)

   col.classes <- c("darkseagreen2", "mediumorchid2", brewer.pal(7, "Set1"), brewer.pal(7, "Dark2"),
                 brewer.pal(7, "Paired"), brewer.pal(8, "Accent"), brewer.pal(8, "Set2"), brewer.pal(11, "Spectral"), brewer.pal(12, "Set3"),
                 sample(c(brewer.pal(9, "Blues"), brewer.pal(9, "Reds"), brewer.pal(9, "Oranges"), brewer.pal(9, "Greys"),
                          brewer.pal(9, "Purples"), brewer.pal(9, "Greens"))))

   assoc.matrix <- DISSECTOR_compute_assoc_or_dist.v1(input_matrix1 = H, input_matrix2 = H2, object_type = "columns",
                                                     assoc_metric = "IC", distance = F)
   if (sort.matrix == T) {
      dist.matrix <- DISSECTOR_compute_assoc_or_dist.v1(input_matrix1 = assoc.matrix, input_matrix2 = assoc.matrix, object_type = "columns",
                                                     assoc_metric = "IC", distance = T)
      hc <- hclust(dist.matrix, "ward")
      assoc.matrix <- assoc.matrix[, hc$order]
      dist.matrix2 <- DISSECTOR_compute_assoc_or_dist.v1(input_matrix1 = assoc.matrix, input_matrix2 = assoc.matrix, object_type = "rows",
                                                     assoc_metric = "IC", distance = T)
      hc2 <- hclust(dist.matrix2, "ward")
      assoc.matrix <- assoc.matrix[hc2$order,]
  }
   write.gct.2(gct.data.frame = assoc.matrix, descs = row.names(assoc.matrix), filename = output_assoc_matrix_file)
 
   assoc.matrix <- ceiling(ncolors * (assoc.matrix + 1)/2)
   V <- apply(assoc.matrix, MARGIN=2, FUN=rev)
   par(mar = c(3, 10, 9, 4))
   image(1:dim(V)[2], 1:dim(V)[1], t(V), main = "", zlim = c(0, ncolors), col=mycol,
         axes=FALSE, xlab= "", ylab="") 

   mtext("Association Matrix", cex=1.3, side = 3, line = 7, outer=F)   
   mtext(file.name2, cex=1, side = 3, line = 5, outer=F)      
   mtext(file.name, cex=1, side = 2, line = 5, outer=F)

   if (!is.null(annot_file)) {
      cols <- col.classes[match(gene.class[hc$order], all.classes)]
   } else {
      cols <- "black"
   }
   if (!is.null(annot_file2)) {
      cols2 <- col.classes[match(gene.class2[hc2$order], all.classes2)]
   } else {
      cols2 <- cols
   }
   if (cex.rows == "auto") {
       cex.rows <- 0.15 + 180/(nrow(V) * max(nchar(row.names(V))) + 200)
       cex.cols <-cex.rows
   }
   mtext(row.names(V), at=1:nrow(V), side = 2, cex=cex.rows, col=rev(cols), line=0, las=1, font=2, family="")
   mtext(colnames(V), at=1:ncol(V), side = 3, cex=cex.cols, col=cols2, line=0, las=3, font=2, family="")

   # Legend

   par(mar = c(3, 25, 1, 5))
   leg.set <- seq(-1, 1, 0.01)
   image(1:length(leg.set), 1:1, as.matrix(leg.set), zlim=c(-1, 1), col=mycol, axes=FALSE, main=paste("Association Metric [", association_metric, "]", sep=""),
       sub = "", xlab= "", ylab="",font=2, family="", mgp = c(0, 0, 0), cex.main=0.8)
   ticks <- seq(-1, 1, 0.25)
   tick.cols <- rep("black", 5)
   tick.lwd <- c(1,1,2,1,1)
   locs <- NULL
   for (k in 1:length(ticks)) locs <- c(locs, which.min(abs(ticks[k] - leg.set)))
   axis(1, at=locs, labels=ticks, adj= 0.5, tick=T, cex=0.6, cex.axis=0.6, line=0, font=2, family="", mgp = c(0.1, 0.1, 0.1))
#   mtext(paste("Association Metric [", association_metric, "]", sep=""), cex=0.3, side = 1, line = 3.5, outer=F)
   
   dev.off()
 }

   DISSECTOR_compute_assoc_or_dist.v1 <- function(
#
#  Computes the distance between column (row) vector across two matrices
#
       input_matrix1,            # Input matrix 1
       input_matrix2,            # Input matrix 2
       object_type = "columns",  # Object type "columns" or "rows"
       assoc_metric = "IC",      # Association metric: "IC", "ICR", "COR", "SPEAR"
       distance = T)             # Compute distance (T) or association (F)
{
   if (object_type == "rows") {
      input_matrix1 <- t(input_matrix1)
      input_matrix2 <- t(input_matrix2)
   }
   assoc.matrix <- matrix(0, nrow=ncol(input_matrix1), ncol=ncol(input_matrix2),
                          dimnames = list(colnames(input_matrix1), colnames(input_matrix2)))
   for (i in 1:ncol(input_matrix1)) {
      for (j in 1:ncol(input_matrix2)) {
         if (assoc_metric == "IC") {
            assoc.matrix[i, j] <- IC.v1(input_matrix1[,i], input_matrix2[,j])
         } else if (assoc_metric == "ICR") {
            assoc.matrix[i, j] <- IC.v1(rank(input_matrix1[,i]), rank(input_matrix2[,j]))
         } else if (assoc_metric == "COR") {
            assoc.matrix[i, j] <- cor(input_matrix1[,i], input_matrix2[,j], method = "pearson")
         } else if (assoc_metric == "SPEAR") {
            assoc.matrix[i, j] <- cor(input_matrix1[,i], input_matrix2[,j], method = "spearman")
         } else {
            stop(paste("ERROR: unknown association metric:", assoc_metric))
        }
       }
   }
   if (distance == T) {
       return(as.dist(1 - assoc.matrix))
   } else {
       return(assoc.matrix)
   }
}

   DISSECTOR_extract_gene_sets.v1 <- function(
      #
      #  Extract/Define gene sets from an existing W matrix  (A ~ W x H)
      #
      input_dataset,                    # Input W matrix dataset (GCT)
      min.genes.per.comp = 50,          # Minimum number of genes per component gene set
      max.genes.per.comp = 150,         # Maximum number of genes per component gene set
      add.prefix.to.comp.names = NULL,  # Prefix to C_<number> to better identify the gene sets                                        
      output_gene_sets_file,            # Output (GMT) file with gene sets
      up_direction = T,                 # Extract genes with highest component amplitude
      output_plots)                     # Output (PDF) 
 {

   set.seed(5209761)
       
   pdf(file=output_plots, height=8.5, width=11)
    
   # Read input dataset

   dataset.1 <- MSIG.Gct2Frame(filename = input_dataset)
   W <- data.matrix(dataset.1$ds)
   print(dim(W))
   k.comp <- ncol(W)
    
   if (!is.null(add.prefix.to.comp.names)) {
        for (i in 1:k.comp) {
           colnames(W)[i] <- paste(add.prefix.to.comp.names, "_", colnames(W)[i], sep="")
         }
      }

   z.vec <- vector(length=length(k.comp), mode="numeric")
   for (i in 1:k.comp) {

      W.order <- order(W[,i], decreasing=up_direction)
      W.vals <- W[W.order,i]
      W.genes <- row.names(W)[W.order]
      W.index <- seq(1, length(W.order))
      start <- ceiling(0.25*length(W.index))
      end <- ceiling(0.75*length(W.index))         
      x <- W.index[start:end]
      y <- W.vals[start:end]
      model <- lm(y ~ x)
      a <- model[[1]][1]
      b <- model[[1]][2]
      y.mod <- a + b*W.index
      env <- 0.20*mad(y)
      y.up <- y.mod + env
      y.dn <- y.mod - env
      if (up_direction == T) {
         dist <- (W.vals - y.up < 0)
      } else {
         dist <- (y.up - W.vals < 0)
      }
      z  <- match("TRUE", dist)
      if (up_direction == T) {
         z.vec[i] <- z
      } else {
         z.vec[i] <- length(dist) - z
      }
      par(mar = c(10,10,10,10))
      plot(W.index, W.vals, pch=20, cex=0.8, col="gray", main=paste("Component ", colnames(W)[i], " Profile"),
           sub=paste("Component ", colnames(W)[i], "  cutoff z=", z.vec[i], "(genes with rank less than z are included in gene set)"),
           xlab="Gene Rank", ylab="Component Amplitude (W column)")  # plot metagene amplitudes
      points(W.index[seq(1, z.vec[i])], W.vals[seq(1, z.vec[i])], pch=20, cex=0.8, col="black")
      points(W.index, y.up, pch=20, type="l", col="blue", lwd=1)  # plot metagene amplitudes
      points(W.index, y.mod, pch=20, type="l", col="blue", lwd=2)  # plot metagene amplitudes
      points(W.index, y.dn, pch=20, type="l", col="blue", lwd=1)  # plot metagene amplitudes            
      lines(c(z.vec[i], z.vec[i]), range(W.vals), type="l", col = "red", lwd=2)
      lines(c(start, start), range(W.vals), type="l", col = "green", lwd=1)
      lines(c(end, end), range(W.vals), type="l", col = "green", lwd=1)            
    }
   z.vec <- ifelse(z.vec < min.genes.per.comp, min.genes.per.comp, z.vec)
   z.vec <- ifelse(z.vec > max.genes.per.comp, max.genes.per.comp, z.vec)

   # Produce gene sets (each with top.n genes) to represent each component

   gene.sets <- matrix(NA, nrow=k.comp, ncol=max(z.vec))
   for (i in 1:k.comp) {
      ind <- order(W[, i], decreasing=up_direction)
      sorted.genes <- row.names(W)[ind]
      gene.sets[i, 1:z.vec[i]] <- sorted.genes[1:z.vec[i]]
    }

   # Save them as a "GMT" gene set file

   for (i in 1:k.comp) {
      row.header <- colnames(W)[i]
      output.line <- paste(gene.sets[i, 1:z.vec[i]], collapse="\t")
      output.line <- paste(row.header, row.header, output.line, sep="\t")
      if (i == 1) {
         write(noquote(output.line), file = output_gene_sets_file, append = F, ncolumns = length(z.vec[i]) + 2)
      } else {
        write(noquote(output.line), file = output_gene_sets_file, append = T, ncolumns = length(z.vec[i]) + 2)
      }
    }
    dev.off()
 }

   DISSECTOR_create_components.v1 <- function(
      #
      #  Project an input dataset into components using NMF                                            
      #
      input_dataset,                    # Input GCT dataset A where the matrix decomposition takes place (A ~ W x H)
      input_normalization = "rank",     # Normalization for the input dataset: "rank"
      number_of_comp,                   # Number of components to use in the matrix decomposition
      method = "NMF",                   # Method for matrix factorization: NMF, snNMF or NMF_offset (IMF under construction)
      theta = 0.5,                      # For method = nsNMF value of smoothing parameter theta
      prefix = "Comp",                 # Prefix for the component names
      gene_subset = "all-genes",        # Universe of genes to consider for matrix decomposition: "gene-sets", "all-genes"
      gene_sets_files = NULL,           # If gene_subset = "gene-sets" GMT files with gene sets
      gene_sets = NULL,                 # If gene_subset = "gene-sets" then name of the specific gene set(s) in gene_sets_file to use
      normalize_after_selection = T,    # If gene_subset = "gene-sets," normalize after selection the gene subset
      preprojection_dataset = NULL,     # Save pre-projection input dataset in this file
      output_plots,                     # Output PDF file with W and H plots
      output_W_dataset,                 # Output GCT file with W matrix
      output_H_dataset,                 # Output GCT file with H matrix
      output_H_w_dataset,               # Output GCT file with W-derived H matrix
      output_A_dataset = NULL)          # Output GCT file with sorted and normalized A matrix
  {
   set.seed(5209761)
   
   mycol <- vector(length=512, mode = "numeric")   # Red/Blue "pinkogram" color map
   for (k in 1:256) mycol[k] <- rgb(255, k - 1, k - 1, maxColorValue=255)
   for (k in 257:512) mycol[k] <- rgb(511 - (k - 1), 511 - (k - 1), 255, maxColorValue=255)
   mycol <- rev(mycol)
   ncolors <- length(mycol)

   pdf(file=output_plots, height=8.5, width=11)

   comp.names <- paste(prefix, "C", seq(1, number_of_comp), "_", number_of_comp, sep="")
    
   # Read expression dataset

   dataset.1 <- MSIG.Gct2Frame(filename = input_dataset)
   m.1 <- data.matrix(dataset.1$ds)
   print(paste("Dimensions matrix A:", nrow(m.1), ncol(m.1)))

  # heatmap(m.1, scale="row", col=mycol, margins=c(15, 15), cexRow=0.10, cexCol=0.5, main="Sorted A Matrix", xlab = "Components", ylab= "Genes")   

   if (normalize_after_selection == F) {  # Normalize input data here before selection
     if (input_normalization == "rank") {

         max.n <- 10000
         for (i in 1:ncol(m.1)) m.1[,i] <- (max.n - 1) * (rank(m.1[,i]) - 1) /(nrow(m.1) - 1) + 1
   
     } else if (input_normalization == "row_rank") {

         max.n <- 100
         for (i in 1:nrow(m.1)) m.1[i,] <- (max.n - 1) * (rank(m.1[i,]) - 1) /(ncol(m.1) - 1) + 1
   
      } else if (input_normalization == "none") {   

      } else {
         stop(paste("ERROR: unknown input normalization:", input_normalization))  
      }
   }
   
   if (gene_subset == "gene-sets") {  # select relevant genes from gene sets

        print("Selecting relevant genes from gene sets")

	max.G <- 0
	max.N <- 0
	for (gsdb in gene_sets_files) {
		GSDB <- Read.GeneSets.db(gsdb, thres.min = 2, thres.max = 2000, gene.names = NULL)
		max.G <- max(max.G, max(GSDB$size.G))
		max.N <- max.N +  GSDB$N.gs
	}
	N.gs <- 0
	gs <- matrix("null", nrow=max.N, ncol=max.G)
	gs.names <- vector(length=max.N, mode="character")
	gs.descs <- vector(length=max.N, mode="character")
	size.G <- vector(length=max.N, mode="numeric")
	start <- 1
	for (gsdb in gene_sets_files) {  # Read all the gene sets from gene set files
		GSDB <- Read.GeneSets.db(gsdb, thres.min = 2, thres.max = 2000, gene.names = NULL)
		N.gs <- GSDB$N.gs 
		gs.names[start:(start + N.gs - 1)] <- GSDB$gs.names
		gs.descs[start:(start + N.gs - 1)] <- GSDB$gs.desc
		size.G[start:(start + N.gs - 1)] <- GSDB$size.G
		gs[start:(start + N.gs - 1), 1:max(GSDB$size.G)] <- GSDB$gs[1:N.gs, 1:max(GSDB$size.G)]
		start <- start + N.gs
	}
	N.gs <- max.N
	
	# Select desired gene sets
	
	locs <- match(gene_sets, gs.names)
        print(rbind(gene_sets, locs))
	N.gs <- sum(!is.na(locs))
	if(N.gs > 1) { 
           gs <- gs[locs,]
	} else { 
           gs <- t(as.matrix(gs[locs,]))   # Force vector to matrix if only one gene set specified
        }
	gs.names <- gs.names[locs]
	gs.descs <- gs.descs[locs]
	size.G <- size.G[locs]

        genes <- NULL
       	for (gs.i in 1:N.gs) {
   	   gene.set <- gs[gs.i, 1:size.G[gs.i]]
           genes <- c(genes, gene.set)
         }
        print(paste("Number of selected genes:", length(genes)))
        genes <- unique(genes)
        print(paste("Number of unique selected genes:", length(genes)))        
        genes <- intersect(genes, row.names(m.1))
        print(paste("Number of overlapping genes (final set):", length(genes)))        
        m.2 <- m.1[genes,]
        print("Dimensions of selected input data:")
        print(dim(m.2))

   } else if (gene_subset == "all-genes") {

        print("Using all genes from gene sets")
        
      m.2 <- m.1
   } else {
      stop(paste("ERROR: unknown gene subset selection:", gene_subset))
   }

   if (normalize_after_selection == T) {  # Normalize input data here after selection
   
      if (input_normalization == "rank") {

         max.n <- 10000
         for (i in 1:ncol(m.2)) m.2[,i] <- (max.n - 1) * (rank(m.2[,i]) - 1) /(nrow(m.2) - 1) + 1

       } else if (input_normalization == "none") {   

       } else {
         stop(paste("ERROR: unknown input normalization:", input_normalization))  
       }
    }
   
   # Perform Matrix Factorization to find components

   if (!is.null(preprojection_dataset)) {
      write.gct.2(gct.data.frame = m.2, descs = row.names(m.2), preprojection_dataset)
    }

   if (method == "NMF") {
      NMF.out <- NMF.div(V = m.2, k = number_of_comp, maxniter = 1000, seed = 123, stopconv = 40, stopfreq = 10)
      W <- NMF.out$W
      H <- NMF.out$H
      row.names(W) <- row.names(m.2)
      colnames(W) <- row.names(H) <- comp.names
      colnames(H) <- colnames(m.2)

     plot(seq(1, length(NMF.out$error.v)), NMF.out$error.v, xlab="time", ylab="Error [divergence]", pch=20, col="blue")

      
   } else if (method == "IMF") {

    # To be added

   } else if (method == "NMF_offset") {

     library(NMF)
     NMF.out <- nmf(m.2, number_of_comp, "offset", seed=123)
     W <- basis(NMF.out)
     H <- coef(NMF.out)
     row.names(W) <- row.names(m.2)
     colnames(W) <- row.names(H) <- comp.names
     colnames(H) <- colnames(m.2)

   } else if (method == "nsNMF") {

     library(NMF)
     NMF.out <- nmf(m.2, number_of_comp, "nsNMF", theta=theta, seed=123)
     S <- nmfModel(number_of_comp, model='NMFns')
     S <- smoothing(S, theta=theta)
     W <- basis(NMF.out) %*% S
     H <- coef(NMF.out)
     row.names(W) <- row.names(m.2)
     colnames(W) <- row.names(H) <- comp.names
     colnames(H) <- colnames(m.2)
     
   } else if (method == "NMF_fast") {

     library(NMF)
     NMF.out <- nmf(m.2, number_of_comp, "brunet", seed=123)
     W <- basis(NMF.out)
     H <- coef(NMF.out)
     row.names(W) <- row.names(m.2)
     colnames(W) <- row.names(H) <- comp.names
     colnames(H) <- colnames(m.2)
   }
   
   # end of matrix factorization

  ind <- order(row.names(W))
  W <- W[ind,]
  m.2 <- m.2[ind,]
   
   # Obtain H via W: Project original and additional dataset using non-negative solver

   H_w <- matrix(0, nrow=number_of_comp, ncol= ncol(m.2), dimnames=list(row.names(H), colnames(H)))
   for (i in 1:ncol(H_w)) H_w[, i] <- nnls.fit(W, m.2[, i], wsqrt=1, eps=0, rank.tol=1e-07)

   # Save W and H matrices

   write.gct.2(gct.data.frame = W, descs = row.names(W), filename = output_W_dataset)
   write.gct.2(gct.data.frame = H, descs = row.names(H), filename = output_H_dataset)
   write.gct.2(gct.data.frame = H_w, descs = row.names(H_w), filename = output_H_w_dataset)   

   # Plot sorted W, H  and A matrices

   hc <- hclust(dist(t(W)), "complete")
   d1.W <- as.dendrogram(hc)
   hc2 <- hclust(dist(W), "complete")
   d2.W <- as.dendrogram(hc2)
   heatmap(W, Colv=d1.W, Rowv = d2.W,  scale="row", col=mycol, margins=c(15, 15), cexRow=0.10, cexCol=0.5, main="Sorted W Matrix",
             xlab = "Components", ylab= "Genes")

   hc <- hclust(dist(t(H)), "complete")
   d1.H <- as.dendrogram(hc)
   heatmap(H, Colv=d1.H, Rowv = d1.W,  scale="col", col=mycol, margins=c(15, 15), cexRow=0.10, cexCol=0.5, main="Sorted H Matrix",
             xlab = "Components", ylab= "Genes")

   hc <- hclust(dist(t(H_w)), "complete")
   d1.H <- as.dendrogram(hc)
   heatmap(H_w, Colv=d1.H, Rowv = d1.W,  scale="col", col=mycol, margins=c(15, 15), cexRow=0.10, cexCol=0.5, main="Sorted H_w Matrix",
             xlab = "Components", ylab= "Genes")

   hc <- hclust(dist(t(m.2)), "complete")
   d1.A <- as.dendrogram(hc)
   hc2 <- hclust(dist(m.2), "complete")
   d2.A <- as.dendrogram(hc2)

#   heatmap(m.2, Colv=d1.A, Rowv = d2.A,  scale="none", col=mycol, margins=c(15, 15), cexRow=0.10, cexCol=0.5, main="Sorted A Matrix", xlab = "Components", ylab= "Genes")
    heatmap(m.2, scale="row", col=mycol, margins=c(15, 15), cexRow=0.10, cexCol=0.5, main="Sorted A Matrix", xlab = "Components", ylab= "Genes")

   if (!is.null(output_A_dataset)) {
      m.2 <- m.2[hc2$order, hc$order]
      write.gct.2(gct.data.frame = m.2, descs = row.names(m.2), filename = output_A_dataset)
    }
   dev.off()
  
 }

   DISSECTOR_create_components.v2 <- function(
      #
      #  Project an input dataset into components using NMF                                            
      #
      input_dataset,                    # Input GCT dataset A where the matrix decomposition takes place (A ~ W x H)
      input_normalization = "rank",     # Normalization for the input dataset: "rank"
      number_of_comp,                   # Number of components to use in the matrix decomposition
      prefix = "Comp",                  # Prefix for the component names
      method = "NMF",                   # Method for matrix factorization: NMF, snNMF or NMF_offset (IMF under construction)
      theta = 0.5,                      # For method = nsNMF value of smoothing parameter theta
      gene_subset = "all-genes",        # Universe of genes to consider for matrix decomposition: "gene-sets", "all-genes"
      gene_sets_files = NULL,           # If gene_subset = "gene-sets" GMT files with gene sets
      gene_sets = NULL,                 # If gene_subset = "gene-sets" then name of the specific gene set(s) in gene_sets_file to use
      normalize_after_selection = T,    # If gene_subset = "gene-sets," normalize after selection the gene subset
      preprojection_dataset = NULL,     # Save pre-projection input dataset in this file
      output_plots,                     # Output PDF file with W and H plots
      output_W_dataset,                 # Output GCT file with W matrix
      output_H_dataset,                 # Output GCT file with H matrix
      output_H_w_dataset,               # Output GCT file with W-derived H matrix
      output_A_dataset = NULL,          # Output GCT file with sorted and normalized A matrix
      row_classes_dataset = NULL,       # Output GCT with the row classes
      column_classes_dataset = NULL,    # Output GCT with the column classes
      seed = 123)                       # Randon number generator seed
  {
   set.seed(5209761)
   
   mycol <- vector(length=512, mode = "numeric")   # Red/Blue "pinkogram" color map
   for (k in 1:256) mycol[k] <- rgb(255, k - 1, k - 1, maxColorValue=255)
   for (k in 257:512) mycol[k] <- rgb(511 - (k - 1), 511 - (k - 1), 255, maxColorValue=255)
   mycol <- rev(mycol)
   ncolors <- length(mycol)

   pdf(file=output_plots, height=8.5, width=11)

   comp.names <- paste(prefix, "C", seq(1, number_of_comp), "_", number_of_comp, sep="")
    
   # Read expression dataset

   dataset.1 <- MSIG.Gct2Frame(filename = input_dataset)
   m.1 <- data.matrix(dataset.1$ds)
   print(paste("Dimensions matrix A:", nrow(m.1), ncol(m.1)))

  # heatmap(m.1, scale="row", col=mycol, margins=c(15, 15), cexRow=0.10, cexCol=0.5, main="Sorted A Matrix", xlab = "Components", ylab= "Genes")   

   if (normalize_after_selection == F) {  # Normalize input data here before selection
     if (input_normalization == "rank") {

         max.n <- 10000
         for (i in 1:ncol(m.1)) m.1[,i] <- (max.n - 1) * (rank(m.1[,i]) - 1) /(nrow(m.1) - 1) + 1
   
      } else if (input_normalization == "none") {   

      } else {
         stop(paste("ERROR: unknown input normalization:", input_normalization))  
      }
   }
   
   if (gene_subset == "gene-sets") {  # select relevant genes from gene sets

        print("Selecting relevant genes from gene sets")

	max.G <- 0
	max.N <- 0
	for (gsdb in gene_sets_files) {
		GSDB <- Read.GeneSets.db(gsdb, thres.min = 2, thres.max = 2000, gene.names = NULL)
		max.G <- max(max.G, max(GSDB$size.G))
		max.N <- max.N +  GSDB$N.gs
	}
	N.gs <- 0
	gs <- matrix("null", nrow=max.N, ncol=max.G)
	gs.names <- vector(length=max.N, mode="character")
	gs.descs <- vector(length=max.N, mode="character")
	size.G <- vector(length=max.N, mode="numeric")
	start <- 1
	for (gsdb in gene_sets_files) {  # Read all the gene sets from gene set files
		GSDB <- Read.GeneSets.db(gsdb, thres.min = 2, thres.max = 2000, gene.names = NULL)
		N.gs <- GSDB$N.gs 
		gs.names[start:(start + N.gs - 1)] <- GSDB$gs.names
		gs.descs[start:(start + N.gs - 1)] <- GSDB$gs.desc
		size.G[start:(start + N.gs - 1)] <- GSDB$size.G
		gs[start:(start + N.gs - 1), 1:max(GSDB$size.G)] <- GSDB$gs[1:N.gs, 1:max(GSDB$size.G)]
		start <- start + N.gs
	}
	N.gs <- max.N
	
	# Select desired gene sets
	
	locs <- match(gene_sets, gs.names)
        print(rbind(gene_sets, locs))
	N.gs <- sum(!is.na(locs))
	if(N.gs > 1) { 
           gs <- gs[locs,]
	} else { 
           gs <- t(as.matrix(gs[locs,]))   # Force vector to matrix if only one gene set specified
        }
	gs.names <- gs.names[locs]
	gs.descs <- gs.descs[locs]
	size.G <- size.G[locs]

        genes <- NULL
       	for (gs.i in 1:N.gs) {
   	   gene.set <- gs[gs.i, 1:size.G[gs.i]]
           genes <- c(genes, gene.set)
         }
        print(paste("Number of selected genes:", length(genes)))
        genes <- unique(genes)
        print(paste("Number of unique selected genes:", length(genes)))        
        genes <- intersect(genes, row.names(m.1))
        print(paste("Number of overlapping genes (final set):", length(genes)))        
        m.2 <- m.1[genes,]
        print("Dimensions of selected input data:")
        print(dim(m.2))

   } else if (gene_subset == "all-genes") {

        print("Using all genes from gene sets")
        
      m.2 <- m.1
   } else {
      stop(paste("ERROR: unknown gene subset selection:", gene_subset))
   }

   if (normalize_after_selection == T) {  # Normalize input data here after selection
   
      if (input_normalization == "rank") {

         max.n <- 10000
         for (i in 1:ncol(m.2)) m.2[,i] <- (max.n - 1) * (rank(m.2[,i]) - 1) /(nrow(m.2) - 1) + 1

       } else if (input_normalization == "none") {   

       } else {
         stop(paste("ERROR: unknown input normalization:", input_normalization))  
       }
    }
   
   # Perform Matrix Factorization to find components

   if (!is.null(preprojection_dataset)) {
      write.gct.2(gct.data.frame = m.2, descs = row.names(m.2), preprojection_dataset)
    }

   if (method == "NMF") {
      NMF.out <- NMF.div(V = m.2, k = number_of_comp, maxniter = 1000, seed = seed, stopconv = 40, stopfreq = 10)
      W <- NMF.out$W
      H <- NMF.out$H
      row.names(W) <- row.names(m.2)
      colnames(W) <- row.names(H) <- comp.names
      colnames(H) <- colnames(m.2)

     plot(seq(1, length(NMF.out$error.v)), NMF.out$error.v, xlab="time", ylab="Error [divergence]", pch=20, col="blue")

      
   } else if (method == "IMF") {

    # To be added

   } else if (method == "NMF_offset") {

     library(NMF)
     NMF.out <- nmf(m.2, number_of_comp, "offset", seed=seed)
     W <- basis(NMF.out)
     H <- coef(NMF.out)
     row.names(W) <- row.names(m.2)
     colnames(W) <- row.names(H) <- comp.names
     colnames(H) <- colnames(m.2)

   } else if (method == "nsNMF") {

     library(NMF)
     NMF.out <- nmf(m.2, number_of_comp, "nsNMF", theta=theta, seed=seed)
     S <- nmfModel(number_of_comp, model='NMFns')
     S <- smoothing(S, theta=1)
     W <- basis(NMF.out) %*% S
     H <- coef(NMF.out)
     row.names(W) <- row.names(m.2)
     colnames(W) <- row.names(H) <- comp.names
     colnames(H) <- colnames(m.2)
     
   } else if (method == "NMF_fast") {

     library(NMF)
     NMF.out <- nmf(m.2, number_of_comp, "brunet", seed=seed)
     W <- basis(NMF.out)
     H <- coef(NMF.out)
     row.names(W) <- row.names(m.2)
     colnames(W) <- row.names(H) <- comp.names
     colnames(H) <- colnames(m.2)
   }
   
   # end of matrix factorization

  ind <- order(row.names(W))
  W <- W[ind,]
  m.2 <- m.2[ind,]
   
   # Obtain H via W: Project original and additional dataset using non-negative solver

   H_w <- matrix(0, nrow=number_of_comp, ncol= ncol(m.2), dimnames=list(row.names(H), colnames(H)))
   for (i in 1:ncol(H_w)) H_w[, i] <- nnls.fit(W, m.2[, i], wsqrt=1, eps=0, rank.tol=1e-07)

   # Save W and H matrices

   write.gct.2(gct.data.frame = W, descs = row.names(W), filename = output_W_dataset)
   write.gct.2(gct.data.frame = H, descs = row.names(H), filename = output_H_dataset)
   write.gct.2(gct.data.frame = H_w, descs = row.names(H_w), filename = output_H_w_dataset)   

   # Plot sorted W, H  and A matrices

   hc <- hclust(dist.IC(W, mode="cols"), method="ward") 
   d1.W <- as.dendrogram(hc)
   hc2 <- hclust(dist.IC(W, mode="rows"), method="ward") 
   d2.W <- as.dendrogram(hc2)
   heatmap(W, Colv=d1.W, Rowv = d2.W,  scale="row", col=mycol, margins=c(15, 15), cexRow=0.10, cexCol=0.5,
           main="Sorted W Matrix", xlab = "Components", ylab= "Genes")

   row.classes <- cutree(hc2, k = number_of_comp)
   row.order <- order(row.classes, decreasing = F)
   row.classes <- row.classes[row.order]
   row.names <- row.names(W)[row.order]
   
   if (!is.null(row_classes_dataset)) {
      row.classes <- cbind(row.classes, row.classes)
      row.names(row.classes) <- row.names
      colnames(row.classes) <- c("ROW_classes", "ROW_classes2")      
      write.gct.2(gct.data.frame = row.classes, descs = row.names, filename = row_classes_dataset)
   }

   hc <- hclust(dist.IC(H, mode="cols"), method="ward") 
   d1.H <- as.dendrogram(hc)
   heatmap(H, Colv=d1.H, Rowv = d1.W,  scale="col", col=mycol, margins=c(15, 15), cexRow=0.10, cexCol=0.5,
           main="Sorted H Matrix", xlab = "Components", ylab= "Genes")

   col.classes <- cutree(hc, k = number_of_comp)
   col.order <- order(col.classes, decreasing = F)
   col.classes <- col.classes[col.order]
   col.names <- col.names(H)[col.order]
   
   if (!is.null(column_classes_dataset)) {
      col.classes <- rbind(col.classes, col.classes)       
      row.names(col.classes) <- c("COL_classes", "COL_classes2")      
      colnames(col.classes) <- col.names
      write.gct.2(gct.data.frame = col.classes, descs = row.names(col.classes),
                  filename = column_classes_dataset)
   }

   hc <- hclust(dist.IC(H_w, mode="cols"), method="ward") 
   d1.H <- as.dendrogram(hc)
   heatmap(H_w, Colv=d1.H, Rowv = d1.W,  scale="col", col=mycol, margins=c(15, 15), cexRow=0.10, cexCol=0.5,
           main="Sorted H_w Matrix", xlab = "Components", ylab= "Genes")

   hc <- hclust(dist.IC(m.2, mode="cols"), method="ward") 
   d1.A <- as.dendrogram(hc)
   hc2 <- hclust(dist.IC(m.2, mode="rows"), method="ward") 
   d2.A <- as.dendrogram(hc2)

#   heatmap(m.2, Colv=d1.A, Rowv = d2.A,  scale="none", col=mycol, margins=c(15, 15), cexRow=0.10, cexCol=0.5,
#           main="Sorted A Matrix", xlab = "Components", ylab= "Genes")
    heatmap(m.2, scale="row", col=mycol, margins=c(15, 15), cexRow=0.10, cexCol=0.5,
            main="Sorted A Matrix", xlab = "Components", ylab= "Genes")

   if (!is.null(output_A_dataset)) {
      m.2 <- m.2[hc2$order, hc$order]
      write.gct.2(gct.data.frame = m.2, descs = row.names(m.2), filename = output_A_dataset)
    }
   dev.off()
  
 }

dist.IC <- function(A, mode="rows") { # computes the IC distance between the rows of cols of a matrix

     if (mode == "rows") {
        MI.matrix <- matrix(0, nrow=nrow(A), ncol=nrow(A), dimnames = list(row.names(A), row.names(A)))
        for (i in 1:nrow(A)) for (j in 1:nrow(A)) MI.matrix[i, j] <- IC.v1(A[i,], A[j,])
        dist.matrix <- as.dist(1 - MI.matrix)
    } else if (mode == "cols") {
        MI.matrix <- matrix(0, nrow=ncol(A), ncol=ncol(A), dimnames = list(colnames(A), colnames(A)))
        for (i in 1:ncol(A)) for (j in 1:ncol(A)) MI.matrix[i, j] <- IC.v1(A[,i], A[,j])
        dist.matrix <- as.dist(1 - MI.matrix)
    } else {
        stop(paste("Unknown mode:", mode))
    }
    return(dist.matrix)
}

IC.v1 <-  function(x, y, n.grid=25) {  # Information Coefficient

    # For definitions of mutual information and the universal metric (NMI) see the 
    # definition of "Mutual Information" in wikipedia and Thomas and Cover's book

   x.set <- !is.na(x)
   y.set <- !is.na(y)
   overlap <- x.set & y.set

   x <- x[overlap] +  0.000000001*runif(length(overlap))
   y <- y[overlap] +  0.000000001*runif(length(overlap))

   if (length(x) > 2) {
   
      delta = c(bcv(x), bcv(y))
   
      rho <- cor(x, y)
      rho2 <- abs(rho)
      delta <- delta*(1 + (-0.75)*rho2)
      kde2d.xy <- kde2d(x, y, n = n.grid, h = delta)
      FXY <- kde2d.xy$z + .Machine$double.eps
      dx <- kde2d.xy$x[2] - kde2d.xy$x[1]
      dy <- kde2d.xy$y[2] - kde2d.xy$y[1]
      PXY <- FXY/(sum(FXY)*dx*dy)
      PX <- rowSums(PXY)*dy
      PY <- colSums(PXY)*dx
      HXY <- -sum(PXY * log(PXY))*dx*dy
      HX <- -sum(PX * log(PX))*dx
      HY <- -sum(PY * log(PY))*dy
      PX <- matrix(PX, nrow=n.grid, ncol=n.grid)
      PY <- matrix(PY, byrow = TRUE, nrow=n.grid, ncol=n.grid)
      MI <- sum(PXY * log(PXY/(PX*PY)))*dx*dy
      IC <- sign(rho) * sqrt(1 - exp(- 2 * MI))
      if (is.na(IC)) IC <- 0
   } else {
      IC <- 0
   }

   return(IC)
}

   DISSECTOR_extract_signature.v1 <- function(
      #
      # Create a gene set from a signature TXT file
      #
      input_dataset,                    # Input signature dataset (TXT) in format c(file, gene_column, use_prefix)
      n_markers = 200,                  # Number of markers genes to select
      direction = "UP",                 # Take signature from the top (UP) or bottom (DN) of the list
      gene_set_name,                    # Name given to the extracted gene set
      up_and_down = T,                  # Choose n.markers genes from the top and bottom of the list (F = only top)
      reference_dataset = NULL,         # Select only markers genes that overlap the gene list of another dataset (GCT)                                        
      output_dataset)                   # Output dataset (GMT)
  {
       
   # Read input dataset
  
   tab <- read.table(input_dataset[[1]], header=T, sep="\t", skip=0, colClasses = "character")
   gene.names <- as.vector(tab[, input_dataset[[2]] ])
   if (input_dataset[[3]] == T) {
      for (i in 1:length(gene.names)) {
         gene.names[i] <- unlist(strsplit(as.character(gene.names[i]), " "))[1]
      }
    }
   gene.names <- unique(gene.names)
   print(gene.names[1:10])  # print top 10
   print(gene.names[seq(length(gene.names) - 10 + 1, length(gene.names))]) # print bottom 10
                         
   # Read reference dataset

   if (!is.null(reference_dataset)) {                                                                          
      dataset.1 <- MSIG.Gct2Frame(filename = reference_dataset)
      m.1 <- data.matrix(dataset.1$ds)
      print(paste("Dataset dimensions:", dim(m.1)))
      overlap <- intersect(gene.names, row.names(m.1))
      locs <- match(overlap, gene.names)
      locs <- locs[!is.na(locs)]
      print(paste("Overlap with reference dataset:", length(locs)))
      gene.names <- gene.names[locs]
     }
       
   # Select top n.markers (and bottom) n.markers gene markers  (signature)

   if (direction == "DN") gene.names = rev(gene.names)
   
   if (up_and_down == T) { # UP and DOWN genes
      marker.set <- c(seq(1, n_markers), seq(length(gene.names) - n_markers + 1, length(gene.names)))
      gene.names <- gene.names[marker.set]
      print(paste("Marker set size:", length(gene.names)))
      print(gene.names[1:10])
      print(gene.names[seq(length(gene.names) - 10 + 1, length(gene.names))])
    } else {  # Only UP genes
      marker.set <- seq(1, n_markers)
      gene.names <- gene.names[marker.set]
      print(length(gene.names))      
      print(gene.names[1:10])
    }

  # Save them in a GMT file
   
      row.header <- gene_set_name
      output.line <- paste(gene.names, collapse="\t")
      output.line <- paste(row.header, row.header, output.line, sep="\t")
      write(noquote(output.line), file = output_dataset, append = F, ncolumns = length(gene.names) + 2)

 }

                                                                          
Read.GeneSets.db <- function(
   gs.db,
   thres.min = 2,
   thres.max = 2000,
   gene.names = NULL)
  {

   temp <- readLines(gs.db)
   max.Ng <- length(temp)
   temp.size.G <- vector(length = max.Ng, mode = "numeric") 
   for (i in 1:max.Ng) {
      temp.size.G[i] <- length(unlist(strsplit(temp[[i]], "\t"))) - 2
   }
   max.size.G <- max(temp.size.G)      
   gs <- matrix(rep("null", max.Ng*max.size.G), nrow=max.Ng, ncol= max.size.G)
   temp.names <- vector(length = max.Ng, mode = "character")
   temp.desc <- vector(length = max.Ng, mode = "character")
   gs.count <- 1
   for (i in 1:max.Ng) {
      gene.set.size <- length(unlist(strsplit(temp[[i]], "\t"))) - 2
      gs.line <- noquote(unlist(strsplit(temp[[i]], "\t")))
      gene.set.name <- gs.line[1] 
      gene.set.desc <- gs.line[2] 
      gene.set.tags <- vector(length = gene.set.size, mode = "character")
      for (j in 1:gene.set.size) {
         gene.set.tags[j] <- gs.line[j + 2]
      }
      if (is.null(gene.names)) {
         existing.set <- rep(TRUE, length(gene.set.tags))
      } else {
         existing.set <- is.element(gene.set.tags, gene.names)
      }
      set.size <- length(existing.set[existing.set == T])
      if ((set.size < thres.min) || (set.size > thres.max)) next
      temp.size.G[gs.count] <- set.size
      gs[gs.count,] <- c(gene.set.tags[existing.set], rep("null", max.size.G - temp.size.G[gs.count]))
      temp.names[gs.count] <- gene.set.name
      temp.desc[gs.count] <- gene.set.desc
      gs.count <- gs.count + 1
    }
   Ng <- gs.count - 1
   gs.names <- vector(length = Ng, mode = "character")
   gs.desc <- vector(length = Ng, mode = "character")
   size.G <- vector(length = Ng, mode = "numeric") 
   
   gs.names <- temp.names[1:Ng]
   gs.desc <- temp.desc[1:Ng]
   size.G <- temp.size.G[1:Ng]
   
   return(list(N.gs = Ng, gs = gs, gs.names = gs.names, gs.desc = gs.desc, size.G = size.G, max.N.gs = max.Ng))
 }


## ------------- Additional Functions from CNMF.v4 ------------------------


consensusNMF.2 <- function(input.ds, k.init, k.final, num.clusterings, maxniter, error.function, rseed=123456789, directory = "", stopconv = 40, stopfreq = 10, non.interactive.run = F, doc.string = "", ...) {

#
#  GenePattern Methodology for:
#
#  Metagenes and Molecular Pattern Discovery using Matrix Factorization
#  Jean-Philippe Brunet, Pablo Tamayo, Todd. R. Golub, and Jill P. Mesirov
# 
#  Author:  Pablo Tamayo (tamayo@genome.wi.mit.edu)
#
#  Based on the original matlab version written by Jean-Philippe Brunet (brunet@broad.mit.edu) and
#  with additional contributions from: Ted Liefeld (liefeld@broad.mit.edu)   
#  Date:  November 27, 2003
#
#  Last change March 3, 2005: modifications to make the output more readable.
#
#  Execute from an R console window with this command:
#  source("<this file>", echo = TRUE)
#  E.g. someoutput <- mynmf2(input.ds="c:\\nmf\\all_aml.res",k.init=2,k.final=5,num.clusterings=20,maxniter=500) 
#
#  For details on the method see:
#
#  Proc. Natl. Acad. Sci. USA 2004 101: 4164-4169
#  http://www.broad.mit.edu/cgi-bin/cancer/publications/pub_paper.cgi?mode=view&paper_id=89
#
#  Input parameters
#
#   input.ds
#                       input gene expression dataset in GCT or RES format
#   k.init
#                       initial value of k
#   k.final
#                       final value of k
#   num.clusterings
#                       number of NMF clusterings to build consensus matrix
#   maxniter
#                       maximum number of NMF iterations
#   error.function
#                       NMF error function: "divergence" of "euclidean"
#   rseed
#                       random number generator seed
#   directory
#                       file directory where to store the result files
#   stopconv
#                       how many no change checks are needed to stop NMF iterations (convergence)
#   stopfreq
#                       frequency (NMF iterations) of "no change" checks 
#   non.interactive.run 
#                       flag controlling if the plots are produced interatively (Rgui and saved) or only saved in files
#   doc.string
#                       prefix to be added to the output files
#
#  Output files are (prefix with "doc.string")
#
#   params.txt 
#                       run parameters and time of execution
#   membership.gct		
#			membership results for samples at all values of K
#   cophenetic.txt 
#			cophenetic values for each K
#   cophenetic.plot.jpeg
#			plot of cophenetic for each value of K		
#   consensus.k#.gct (for each value of K)
#			consensus matrix for k=#
#   consensus.plot.k#.jpeg (for each value of K)
#			plot of consensus matrix for k=#
#   graphs.k#.jpeg (for each value of K)

# save input parameters

filename <- paste(directory, doc.string, ".params.txt", sep="", collapse="")  

time.string <- as.character(as.POSIXlt(Sys.time(),"GMT"))
write(paste("Run of NMF on ", time.string), file=filename)

write(paste("input.ds =", input.ds, sep=" "), file=filename, append=T) 
write(paste("k.init = ", k.init, sep=" "), file=filename, append=T) 
write(paste("k.final =", k.final, sep=" "), file=filename, append=T) 
write(paste("num.clusterings =", num.clusterings, sep=" "), file=filename, append=T) 
write(paste("maxniter =", maxniter, sep=" "), file=filename, append=T) 
write(paste("error.function =", error.function, sep=" "), file=filename, append=T) 
write(paste("rseed =", rseed, sep=" "), file=filename, append=T) 
write(paste("directory =", directory, sep=" "), file=filename, append=T) 
write(paste("stopconv =", stopconv, sep=" "), file=filename, append=T) 
write(paste("stopfreq =", stopfreq, sep=" "), file=filename, append=T)
write(paste("non.interctive.run =", non.interactive.run, sep=" "), file=filename, append=T) 
write(paste("doc.string =", doc.string, sep=" "), file=filename, append=T) 


k.init<-as.integer(k.init)
k.final<-as.integer(k.final)
num.clusterings<-as.integer(num.clusterings)
n.iter<-as.integer(maxniter)
if (!is.na(rseed)){
     seed <- as.integer(rseed)
}


# library(mva)
# library(MASS)
# library(GenePattern)

D <- CNMF.read.dataset(input.ds)
A <- data.matrix(D)

# Threshold negative values to small quantity 

eps <- .Machine$double.eps
A[A < 0] <- eps



cols <- length(A[1,])
rows <- length(A[,1])

col.names <- names(D)

num.k <- k.final - k.init + 1

rho <- vector(mode = "numeric", length = num.k)
k.vector <- vector(mode = "numeric", length = num.k)
k.index <- 1

connect.matrix.ordered <- array(0, c(num.k, cols, cols))

filename <- paste(directory, doc.string, ".", "graphs.pdf", sep="", collapse="")
pdf(file=filename, width = 9, height = 11)

for (k in k.init:k.final) { 

   nf <- layout(matrix(c(1,2,3,4,5,6,7,8), 2, 4, byrow=T), c(1, 1), c(1, 1, 1, 1), TRUE)
   assign <- matrix(0, nrow = num.clusterings, ncol = cols)

   for (i in 1:num.clusterings) {
	  
        print(paste("Computing clustering number=", i, " for k=", k, sep=""))

        if (error.function == "divergence"){
	    NMF.out <- NMF.div(V = A, k = k, maxniter = n.iter, seed = seed + i, stopconv = stopconv, stopfreq = stopfreq)
	} else if (error.function == "euclidean"){
	    NMF.out <- NMF(V = A, k = k, maxniter = n.iter, seed = seed + i, stopconv = stopconv, stopfreq = stopfreq)
	} else {
            stop(paste("Un-supported error function=", error.function, sep=""))
        }
        print(paste(NMF.out$t, " NMF iterations performed", sep=""))

        for (j in 1:cols) { # Find membership
            class <- order(NMF.out$H[,j], decreasing=T)
            assign[i, j] <- class[1]
        }

	if (i == 1) {  # Plot example for first clustering iteration
            H.saved <- NMF.out$H
            sub.string <- paste(doc.string, " k=", k, sep="")
            plot(1:NMF.out$t, NMF.out$error.v[1:NMF.out$t], pch = 20, cex = 1.5, col = 1, xlab="time", ylab="NMF error", sub=sub.string, main=paste("Convergence plot k=", k, " example", sep=""))


            if (rows < 1000) {
               W <- NMF.out$W
            } else {
               W <- NMF.out$W[sample(x = 1:rows, size = 1000),]
            }
            sub.string <- paste(doc.string, " k=", k, sep="")
            CNMF.matrix.abs.plot(W, sub = sub.string, log = F, main = "Example W matrix (orig. order)", ylab = "genes", xlab ="metasamples")
            CNMF.matrix.abs.plot(H.saved, sub = sub.string, log = F, main = "Example H matrix (orig. order)", ylab = "metagenes", xlab ="samples")
            CNMF.metagene.plot(H = H.saved, main = "Metagenes Example (orig. order)", sub = sub.string, xlab = "samples", ylab = "metagenes")

        }

        rm(NMF.out)

     }  ## end  for (i in 1:num.clusterings)

   
     # compute consensus matrix
     connect.matrix <- matrix(0, nrow = cols, ncol = cols)

     for (i in 1:num.clusterings) {
       for (j in 1:cols) {
          for (p in 1:cols) {
             if (j != p) {
                  if (assign[i, j] == assign[i, p]) {
                    connect.matrix[j, p] <- connect.matrix[j, p] + 1
                  } 
              } else {
                    connect.matrix[j, p] <- connect.matrix[j, p] + 1
              }
           }
       }
     }

     connect.matrix <- connect.matrix / num.clusterings

     dist.matrix <- 1 - connect.matrix
     dist.matrix <- as.dist(dist.matrix)
     HC <- hclust(dist.matrix, method="average")

     dist.coph <- cophenetic(HC)
     k.vector[k.index] <- k
     rho[k.index] <- cor(dist.matrix, dist.coph)
     rho[k.index] <- signif(rho[k.index], digits = 4)
   
#     connect.matrix.ordered <- matrix(0, nrow=cols, ncol = cols)

     for (i in 1:cols) {
        for (j in 1:cols) {
           connect.matrix.ordered[k.index, i, j] <- connect.matrix[HC$order[i], HC$order[j]]
         }
     }

     # compute consensus clustering membership

     membership <- cutree(HC, k = k)

     max.k <- max(membership)
     items.names.ordered <- col.names[HC$order]
     membership.ordered <- membership[HC$order]
     results <- data.frame(cbind(membership.ordered, items.names.ordered))

     if (k > k.init){
          all.membership <- cbind(all.membership, membership);
     } else {
          all.membership <- cbind(membership);
     }

     sub.string <- paste(doc.string, " k=", k, sep="")
     CNMF.matrix.abs.plot(connect.matrix.ordered[k.index,,], sub=sub.string, log = F, main = "Ordered Consensus Matrix", 
                          ylab = "samples", xlab ="samples")
     plot(HC, xlab="samples", cex = 0.75, labels = col.names, sub = sub.string, col = "blue", 
          main = paste("Ordered Linkage Tree. Coph=", rho[k.index]))

     matrixGct <- data.frame(connect.matrix.ordered[k.index,,])
     filename <- paste(directory, doc.string, ".", "matrix.k.",k, ".gct", sep="", collapse="")
     CNMF.write.gct.2(matrixGct, descs = "", filename) 

     resultsGct <- data.frame(membership.ordered)
     row.names(resultsGct) <- items.names.ordered
     filename <- paste(directory, doc.string, ".", "consensus.k.",k, ".gct", sep="", collapse="")
     CNMF.write.gct.2(resultsGct, descs = "", filename) 

     H.sorted <- H.saved[,HC$order]
     sub.string <- paste(doc.string, " k=", k, sep="")
     CNMF.matrix.abs.plot(H.sorted, sub = sub.string, log = F, main = "Example H matrix (ordered)", ylab = "metagenes", xlab ="samples")
     CNMF.metagene.plot(H = H.sorted, sub = sub.string, main = "Metagenes Example (ordered)", xlab = "samples", ylab = "metagenes")

     nf <- layout(matrix(c(1), 1, 1, byrow=T), c(1, 1), c(1, 1), TRUE)

     conlabel <- paste("Consensus k =", k, sep=" ", collapse="")

     sub.string <- paste("Consensus matrix k=", k, "; dataset= ", input.ds, sep="")
     CNMF.ConsPlot(connect.matrix.ordered[k.index,,], col.labels = membership.ordered, col.names = items.names.ordered, 
                   main = " ", sub=sub.string, xlab=" ", ylab=" ")

     k.index <- k.index + 1

} # end of loop over k


# Save consensus matrices in one file

  nf <- layout(matrix(c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16), 4, 4, byrow=T), c(1, 1, 1, 1), c(1, 1, 1, 1), TRUE)

  for (k in 1:num.k) { 
     CNMF.matrix.abs.plot(connect.matrix.ordered[k,,], log = F, main = paste("k=", k.vector[k]), 
                          sub = paste("Cophenetic coef.=", rho[k]), ylab = "samples", xlab ="samples")
  }
   
  y.range <- c(1 - 2*(1 - min(rho)), 1)
  plot(k.vector, rho, main ="Cophenetic Coefficient", xlim=c(k.init, k.final), ylim=y.range, 
                          xlab = "k", ylab="Cophenetic correlation", type = "n")
  lines(k.vector, rho, type = "l", col = "black")
  points(k.vector, rho, pch=22, type = "p", cex = 1.25, bg = "black", col = "black")

# Write the membership matrix

resultsmembership <- data.frame(all.membership)
row.names(resultsmembership) <- col.names
colnames(resultsmembership) <- paste("k=", seq(k.init, k.final))

print("Membership:")

print(resultsmembership)

filename <- paste(directory, doc.string, ".", "membership", ".txt", sep="", collapse="")

col.names <- paste(colnames(resultsmembership), collapse = "\t")
col.names <- paste("SAMPLE", col.names, sep= "\t")
write(noquote(col.names), file = filename, append = F, ncolumns = length(col.names))
write.table(resultsmembership, file=filename, quote=F, col.names = F, row.names = T, append = T, sep="\t")

  nf <- layout(matrix(c(1), 1, 1, byrow=T), c(1), c(1), TRUE)
y.range <- c(1 - 2*(1 - min(rho)), 1)
plot(k.vector, rho, main ="Cophenetic Coefficient", xlim=c(k.init, k.final), ylim=y.range, xlab = "k", ylab="Cophenetic correlation", type = "n")
lines(k.vector, rho, type = "l", col = "black")
points(k.vector, rho, pch=22, type = "p", cex = 1.25, bg = "black", col = "black")

filename <- paste(directory, doc.string, ".", "cophenetic.txt", sep="")

xx <- cbind(k.vector, rho)
write(noquote(c("k", "\t", "Cophenetic Coefficient")), file = filename, append = F, ncolumns = 1000)
write.table(xx, file = filename, append = T, quote = FALSE, sep = "\t", 
            col.names = FALSE, row.names = F)

dev.off()
}


CNMF.read.dataset <- function(file) {
	result <- regexpr(paste(".gct","$",sep=""), tolower(file))
	if(result[[1]] != -1)
		return(CNMF.read.gct(file))
	result <- regexpr(paste(".res","$",sep=""), tolower(file))
	if(result[[1]] != -1)
		return(CNMF.read.res(file))
	stop("Input is not a res or gct file.")	
}

CNMF.matrix.abs.plot <- function(V, axes = F, log = F, norm = T, transpose = T, matrix.order = T, max.v = 1, min.v = 0, main = " ", sub = " ", xlab = " ", ylab = "  ") {
      rows <- length(V[,1])
      cols <- length(V[1,])
      if (log == T) {
         V <- log(V)
      }
      B <- matrix(0, nrow=rows, ncol=cols)
	for (i in 1:rows) {
           for (j in 1:cols) {
                if (matrix.order == T) {
                   k <- rows - i + 1
                } else {
                   k <- i
                }
                if (norm == T) {
                  if ((max.v == 1) && (min.v == 0)) {
                     max.val <- max(V)
                     min.val <- min(V)
                  } else {
		     	   max.val = max.v
                     min.val = min.v
                  }
               }
	     B[k, j] <-  max.val - V[i, j] + min.val
           }
      }
	if (transpose == T) {
	  B <- t(B)
        }
	if (norm == T) {
#            image(z = B, zlim = c(min.val, max.val), axes = axes, col = rainbow(100, s = 1.0, v = 0.75, start = 0.0, end = 0.75, gamma = 1.5), main = main, sub = sub, xlab = xlab, ylab = ylab)
            image(z = B, zlim = c(min.val, max.val), axes = axes, col = rainbow(100, s = 1.0, v = 0.75, start = 0.0, end = 0.75), main = main, sub = sub, xlab = xlab, ylab = ylab)           
      } else {
#            image(z = B, axes = axes, col = rainbow(100, s = 1, v = 0.6, start = 0.1, end = 0.9, gamma = 1), main = main, sub = sub, xlab = xlab, ylab = ylab)
            image(z = B, axes = axes, col = rainbow(100, s = 1, v = 0.6, start = 0.1, end = 0.9), main = main, sub = sub, xlab = xlab, ylab = ylab)         
      }
      return(list(B, max.val, min.val))
    }

CNMF.metagene.plot <- function(H, main = " ", sub = " ", xlab = "samples ", ylab = "amplitude") {
	k <- length(H[,1])
	S <- length(H[1,])
	index <- 1:S
	maxval <- max(H)
        minval <- min(H)
	plot(index, H[1,], xlim=c(1, S), ylim=c(minval, maxval), main = main, sub = sub, ylab = ylab, xlab = xlab, type="n")
	for (i in 1:k) {
	    lines(index, H[i,], type="l", col = i, lwd=2)
        }
}


CNMF.ConsPlot <- function(V, col.labels, col.names, main = " ", sub = " ", xlab=" ", ylab=" ") {

# Plots a heatmap plot of a consensus matrix

     cols <- length(V[1,])
     B <- matrix(0, nrow=cols, ncol=cols)
     max.val <- max(V)
     min.val <- min(V)
     for (i in 1:cols) {
         for (j in 1:cols) {
             k <- cols - i + 1
	     B[k, j] <-  max.val - V[i, j] + min.val
          }
     }

     col.names2 <- rev(col.names)
     col.labels2 <- rev(col.labels)
     D <- matrix(0, nrow=(cols + 1), ncol=(cols + 1))

     col.tag <- vector(length=cols, mode="numeric")
     current.tag <- 0
     col.tag[1] <- current.tag
     for (i in 2:cols) {
        if (col.labels[i] != col.labels[i - 1]) {
             current.tag <- 1 - current.tag
        }
        col.tag[i] <- current.tag
     }
     col.tag2 <- rev(col.tag)
     D[(cols + 1), 2:(cols + 1)] <- ifelse(col.tag %% 2 == 0, 1.02, 1.01)
     D[1:cols, 1] <- ifelse(col.tag2 %% 2 == 0, 1.02, 1.01)
     D[(cols + 1), 1] <- 1.03
     D[1:cols, 2:(cols + 1)] <- B[1:cols, 1:cols]

#     col.map <- c(rainbow(100, s = 1.0, v = 0.75, start = 0.0, end = 0.75, gamma = 1.5), "#BBBBBB", "#333333", "#FFFFFF")
     col.map <- c(rainbow(100, s = 1.0, v = 0.75, start = 0.0, end = 0.75), "#BBBBBB", "#333333", "#FFFFFF")     
     image(1:(cols + 1), 1:(cols + 1), t(D), col = col.map, axes=FALSE, main=main, sub=sub, xlab= xlab, ylab=ylab)
     for (i in 1:cols) {
         col.names[i]  <- paste("      ", substr(col.names[i], 1, 12), sep="")
         col.names2[i] <- paste(substr(col.names2[i], 1, 12), "     ", sep="")
     }

     axis(2, at=1:cols, labels=col.names2, adj= 0.5, tick=FALSE, las = 1, cex.axis=0.50, font.axis=1, line=-1)
     axis(2, at=1:cols, labels=col.labels2, adj= 0.5, tick=FALSE, las = 1, cex.axis=0.65, font.axis=1, line=-1)

     axis(3, at=2:(cols + 1), labels=col.names, adj= 1, tick=FALSE, las = 3, cex.axis=0.50, font.axis=1, line=-1)
     axis(3, at=2:(cols + 1), labels=as.character(col.labels), adj = 1, tick=FALSE, las = 1, cex.axis=0.65, font.axis=1, line=-1)

     return()
   }

CNMF.read.res <- function(filename = "NULL") { 
#
# Reads a gene expression dataset in RES format and converts it into an R data frame
#
   header.cont <- readLines(filename, n = 1)
   temp <- unlist(strsplit(header.cont, "\t"))
   colst <- length(temp)
   header.labels <- temp[seq(3, colst, 2)]
   ds <- read.delim(filename, header=F, row.names = 2, sep="\t", skip=3, blank.lines.skip=T, comment.char="", as.is=T)
   colst <- length(ds[1,])
   cols <- (colst - 1)/2
   rows <- length(ds[,1])
   A <- matrix(nrow=rows - 1, ncol=cols)
   A <- ds[1:rows, seq(2, colst, 2)]
   table1 <- data.frame(A)
   names(table1) <- header.labels
   return(table1)
}

CNMF.read.gct <- function(filename = "NULL") { 
#
# Reads a gene expression dataset in GCT format and converts it into an R data frame
#
   ds <- read.delim(filename, header=T, sep="\t", skip=2, row.names=1, blank.lines.skip=T, comment.char="", as.is=T)
   ds <- ds[-1]
   return(ds)
}

CNMF.write.gct.2 <- function(gct.data.frame, descs = "", filename) 
{
    f <- file(filename, "w")
    cat("#1.2", "\n", file = f, append = TRUE, sep = "")
    cat(dim(gct.data.frame)[1], "\t", dim(gct.data.frame)[2], "\n", file = f, append = TRUE, sep = "")
    cat("Name", "\t", file = f, append = TRUE, sep = "")
    cat("Description", file = f, append = TRUE, sep = "")

    colnames <- colnames(gct.data.frame)
    cat("\t", colnames[1], file = f, append = TRUE, sep = "")

    if (length(colnames) > 1) {
       for (j in 2:length(colnames)) {
           cat("\t", colnames[j], file = f, append = TRUE, sep = "")
       }
     }
    cat("\n", file = f, append = TRUE, sep = "\t")

    oldWarn <- options(warn = -1)
    m <- matrix(nrow = dim(gct.data.frame)[1], ncol = dim(gct.data.frame)[2] +  2)
    m[, 1] <- row.names(gct.data.frame)
    if (length(descs) > 1) {
        m[, 2] <- descs
    } else {
        m[, 2] <- row.names(gct.data.frame)
    }
    index <- 3
    for (i in 1:dim(gct.data.frame)[2]) {
        m[, index] <- gct.data.frame[, i]
        index <- index + 1
    }
    write.table(m, file = f, append = TRUE, quote = FALSE, sep = "\t", eol = "\n", col.names = FALSE, row.names = FALSE)
    close(f)
    options(warn = 0)

}

NMF.div <- function(V, k, maxniter = 2000, seed = 123456, stopconv = 40, stopfreq = 10) {

        N <- length(V[,1])
        M <- length(V[1,])
        set.seed(seed)
        W <- matrix(runif(N*k), nrow = N, ncol = k)  # Initialize W and H with random numbers
        H <- matrix(runif(k*M), nrow = k, ncol = M)
        VP <- matrix(nrow = N, ncol = M)
        error.v <- vector(mode = "numeric", length = maxniter)
        new.membership <- vector(mode = "numeric", length = M)
        old.membership <- vector(mode = "numeric", length = M)
        no.change.count <- 0
        eps <- .Machine$double.eps
        for (t in 1:maxniter) {
                VP = W %*% H
                W.t <- t(W)
                H <- H * (W.t %*% (V/VP)) + eps
                norm <- apply(W, MARGIN=2, FUN=sum)
                for (i in 1:k) {
                    H[i,] <- H[i,]/norm[i]
                }
                VP = W %*% H
                H.t <- t(H)
                W <- W * ((V/(VP + eps)) %*% H.t) + eps
                norm <- apply(H, MARGIN=1, FUN=sum)
                for (i in 1:k) {
                    W[,i] <- W[,i]/norm[i]
                }
               error.v[t] <- sum(V * log((V + eps)/(VP + eps)) - V + VP)/(M * N)
               if (t %% stopfreq == 0) {

                    for (j in 1:M) {
                        class <- order(H[,j], decreasing=T) 
                        new.membership[j] <- class[1]
                     }
                     if (sum(new.membership == old.membership) == M) {
                        no.change.count <- no.change.count + 1
                     } else {
                        no.change.count <- 0
                     }
                     if (no.change.count == stopconv) break
                     old.membership <- new.membership
               }
        }
        return(list(W = W, H = H, t = t, error.v = error.v))
}

MSIG.Preprocess.Dataset <- function(
   input.ds, 
   output.ds,
   thres = NULL, 
   ceil = NULL, 
   shift = NULL,
   fold = NULL, 
   delta = NULL, 
   normalization = NULL,
   cntrl.genes = NULL) {

   print(c("Running MSIG.Preprocess.Dataset... on:", input.ds))
   print(c("output file:", output.ds))
   print(c("normalization =", normalization))
   
# Read dataset

   dataset <- MSIG.Gct2Frame(filename = input.ds)
   m <- data.matrix(dataset$ds)
   gs.names <- dataset$row.names
   gs.descs <- dataset$descs
   sample.names <- dataset$names

# threshold, ceiling and shift

   if (!is.null(thres)) {
     m[m < thres] <- thres
   }
   if (!is.null(ceil)) {
      m[m > ceil] <- ceil
   }
   if (!is.null(shift)) {
      m <- m + shift
   }

   # identify and save control genes

   if (!is.null(cntrl.genes)) {
      gene.names2 <- intersect(cntrl.genes, gs.names)
      locs <- match(gene.names2, gs.names, nomatch=0)
      msig.cntrl <- m[locs, ]
      msig.cntrl.genes <- gs.names[locs]
      msig.cntrl.descs <- gs.descs[locs]
      m <- m[-locs, ]
      gs.names <- gs.names[-locs]
      gs.descs <- gs.descs[-locs]
    }

   # variation filter

   if ((!is.null(fold)) && (!is.null(delta))) {
      temp <- MSIG.VarFilter(V = m, fold = fold, delta = delta, gene.names = gs.names, gene.descs = gs.descs) 
      m <- temp$V
      gs.names <- temp$new.gene.names
      gs.descs <- temp$new.gene.descs
      dim(m) 
   }

   # restore control genes

   if (!is.null(cntrl.genes)) {
      m <- rbind(m, msig.cntrl)
      gs.names <- c(gs.names, msig.cntrl.genes)
      gs.descs <- c(gs.descs, msig.cntrl.descs)
    }

# normalization

   if (!is.null(normalization)) {
      if (normalization == 1) {
         m <- MSIG.NormalizeCols.Rank(m)
      } else if (normalization == 2) {
         m <- MSIG.NormalizeCols.Rank(m)/length(m[,1])
      } else if (normalization == 3) {
         m <- GSEA.NormalizeCols(m) + 3
         m <- GSEA.Threshold(m, 0.001, 100000) 
      } else if (normalization == 4) {
         m <- MSIG.NormalizeCols.Rank(m)/length(m[,1])
      } else if (normalization == 5) {
         m <- MSIG.NormalizeCols.Rescale(m)
      } else if (normalization == 6) {
         cols <- length(m[1,])
         for (j in 1:cols) {  # column rank normalization from 0 to N - 1
            m[,j] <- rank(m[,j], ties.method = "average") - 1
         }
         m <- 10000*m/(length(m[,1]) - 1)
      } else if (normalization == 7) {
         m <- ((100*MSIG.NormalizeCols.Rank(m))%/%length(m[,1]) + 1)
      } else if (normalization == 8) { 
          row.mean <- apply(m, MARGIN=1, FUN=mean)
          for (i in 1:length(m[,1])) {
             m[i,] <- m[i,] / row.mean[i]
          }
      }
   }
   
   V <- data.frame(m)
   names(V) <- sample.names
   row.names(V) <- gs.names
   write.gct(gct.data.frame = V, descs = gs.descs, filename = output.ds)  

 }

GSEA.Threshold <- function(V, thres, ceil) { 
#
# Threshold and ceiling pre-processing for gene expression matrix
#
# The Broad Institute
# SOFTWARE COPYRIGHT NOTICE AGREEMENT
# This software and its documentation are copyright 2003 by the
# Broad Institute/Massachusetts Institute of Technology.
# All rights are reserved.
#
# This software is supplied without any warranty or guaranteed support
# whatsoever. Neither the Broad Institute nor MIT can be responsible for
# its use, misuse, or functionality.

        V[V < thres] <- thres
        V[V > ceil] <- ceil
        return(V)
}

GSEA.VarFilter <- function(V, fold, delta, gene.names = "") { 
#
# Variation filter pre-processing for gene expression matrix
#
# The Broad Institute
# SOFTWARE COPYRIGHT NOTICE AGREEMENT
# This software and its documentation are copyright 2003 by the
# Broad Institute/Massachusetts Institute of Technology.
# All rights are reserved.
#
# This software is supplied without any warranty or guaranteed support
# whatsoever. Neither the Broad Institute nor MIT can be responsible for
# its use, misuse, or functionality.

        cols <- length(V[1,])
        rows <- length(V[,1])
        row.max <- apply(V, MARGIN=1, FUN=max)
               row.min <- apply(V, MARGIN=1, FUN=min)
        flag <- array(dim=rows)
        flag <- (row.max /row.min >= fold) & (row.max - row.min >= delta)
        size <- sum(flag)
        B <- matrix(0, nrow = size, ncol = cols)
        j <- 1
        if (length(gene.names) == 1) {
           for (i in 1:rows) {
              if (flag[i]) {
                 B[j,] <- V[i,]
                 j <- j + 1
               }
           }
        return(B)
        } else {
            new.list <- vector(mode = "character", length = size)
            for (i in 1:rows) {
              if (flag[i]) {
                 B[j,] <- V[i,]
                 new.list[j] <- gene.names[i]
                 j <- j + 1
              }
            }
        return(list(V = B, new.list = new.list))
        }
}

MSIG.VarFilter <- function(V, fold, delta, gene.names = "", gene.descs = "") { 

# Variation filter pre-processing for gene expression matrix

        cols <- length(V[1,])
        rows <- length(V[,1])
        row.max <- apply(V, MARGIN=1, FUN=max)
        row.min <- apply(V, MARGIN=1, FUN=min)
        flag <- array(dim=rows)
        flag <- (row.max /row.min >= fold) & (row.max - row.min >= delta)
        size <- sum(flag)
        B <- matrix(0, nrow = size, ncol = cols)
        j <- 1
        if (length(gene.names) == 1) {
           for (i in 1:rows) {
              if (flag[i]) {
                 B[j,] <- V[i,]
                 j <- j + 1
               }
           }
        return(B)
        } else {
            new.gene.names <- vector(mode = "character", length = size)
            new.gene.descs <- vector(mode = "character", length = size)
            for (i in 1:rows) {
              if (flag[i]) {
                 B[j,] <- V[i,]
                 new.gene.names[j] <- gene.names[i]
                 new.gene.descs[j] <- gene.descs[i]
                 j <- j + 1
              }
            }
        return(list(V = B, new.gene.names = new.gene.names, new.gene.descs = new.gene.descs, locations = flag))
        }
}

GSEA.NormalizeRows <- function(V) { 
#
# Stardardize rows of a gene expression matrix
#
# The Broad Institute
# SOFTWARE COPYRIGHT NOTICE AGREEMENT
# This software and its documentation are copyright 2003 by the
# Broad Institute/Massachusetts Institute of Technology.
# All rights are reserved.
#
# This software is supplied without any warranty or guaranteed support
# whatsoever. Neither the Broad Institute nor MIT can be responsible for
# its use, misuse, or functionality.

        row.mean <- apply(V, MARGIN=1, FUN=mean)
        row.sd <- apply(V, MARGIN=1, FUN=sd)

        row.n <- length(V[,1])
        for (i in 1:row.n) {
             if (row.sd[i] == 0) {
                  V[i,] <- 0
           } else {
              V[i,] <- (V[i,] - row.mean[i])/row.sd[i]
           }
        }
        return(V)
}

GSEA.NormalizeCols <- function(V) { 
#
# Stardardize columns of a gene expression matrix
#
# The Broad Institute
# SOFTWARE COPYRIGHT NOTICE AGREEMENT
# This software and its documentation are copyright 2003 by the
# Broad Institute/Massachusetts Institute of Technology.
# All rights are reserved.
#
# This software is supplied without any warranty or guaranteed support
# whatsoever. Neither the Broad Institute nor MIT can be responsible for
# its use, misuse, or functionality.

        col.mean <- apply(V, MARGIN=2, FUN=mean)
               col.sd <- apply(V, MARGIN=2, FUN=sd)
        col.n <- length(V[1,])
        for (i in 1:col.n) {
             if (col.sd[i] == 0) {
                  V[i,] <- 0
           } else {
              V[,i] <- (V[,i] - col.mean[i])/col.sd[i]
           }
        }
        return(V)
}

GSEA.NormalizeCols.Rank <- function(V) { 
#
      cols <- length(V[1,])
      rows <- length(V[,1])
      for (j in 1:cols) {  # column rank normalization
         V[,j] <- rank(V[,j], ties.method = "average")
      }

      return(V)
}


MSIG.NormalizeCols.Rank <- function(V) { 

      cols <- length(V[1,])
      rows <- length(V[,1])
      for (j in 1:cols) {  # column rank normalization
         V[,j] <- rank(V[,j], ties.method = "average")
      }

      return(V)
}

MSIG.NormalizeCols.Rescale <- function(V) { 

      epsilon <- 0.00001
      cols <- length(V[1,])
      for (j in 1:cols) {  # column rank normalization
         max.v <- max(V[,j])
         min.v <- min(V[,j])
         V[,j] <- (V[,j] - min.v + epsilon)/(max.v - min.v)
      }

      return(V)
    }

MSIG.Gct2Frame <- function(filename = "NULL") { 
#
# Reads a gene expression dataset in GCT format and converts it into an R data frame
#
# The Broad Institute
# SOFTWARE COPYRIGHT NOTICE AGREEMENT
# This software and its documentation are copyright 2003 by the
# Broad Institute/Massachusetts Institute of Technology.
# All rights are reserved.
#
# This software is supplied without any warranty or guaranteed support
# whatsoever. Neither the Broad Institute nor MIT can be responsible for
# its use, misuse, or functionality.

   ds <- read.delim(filename, header=T, sep="\t", skip=2, row.names=1, blank.lines.skip=T, comment.char="", as.is=T, na.strings = "")
   descs <- ds[,1]
   ds <- ds[-1]
   row.names <- row.names(ds)
   names <- names(ds)
   return(list(ds = ds, row.names = row.names, descs = descs, names = names))
}


write.gct <- function(gct.data.frame, descs = "", filename) 
{
    f <- file(filename, "w")
    cat("#1.2", "\n", file = f, append = TRUE, sep = "")
    cat(dim(gct.data.frame)[1], "\t", dim(gct.data.frame)[2], "\n", file = f, append = TRUE, sep = "")
    cat("Name", "\t", file = f, append = TRUE, sep = "")
    cat("Description", file = f, append = TRUE, sep = "")

    names <- names(gct.data.frame)
    cat("\t", names[1], file = f, append = TRUE, sep = "")

    if (length(names) > 1) {
       for (j in 2:length(names)) {
           cat("\t", names[j], file = f, append = TRUE, sep = "")
       }
     }
    cat("\n", file = f, append = TRUE, sep = "\t")

    oldWarn <- options(warn = -1)
    m <- matrix(nrow = dim(gct.data.frame)[1], ncol = dim(gct.data.frame)[2] +  2)
    m[, 1] <- row.names(gct.data.frame)
    if (length(descs) > 1) {
        m[, 2] <- descs
    } else {
        m[, 2] <- row.names(gct.data.frame)
    }
    index <- 3
    for (i in 1:dim(gct.data.frame)[2]) {
        m[, index] <- gct.data.frame[, i]
        index <- index + 1
    }
    write.table(m, file = f, append = TRUE, quote = FALSE, sep = "\t", eol = "\n", col.names = FALSE, row.names = FALSE)
    close(f)
    options(warn = 0)

  }

cluster.and.resort <- function(V, rows, cols) {
        dist.matrix <- dist(t(V))
        HC <- hclust(dist.matrix, method="complete")
        V <- V[, HC$order]
        cols <- cols[HC$order]
        dist.matrix <- dist(V)
        HC <- hclust(dist.matrix, method="complete")
        V <- V[HC$order, ]
        rows <- rows[HC$order]
        return(list(V = V, rows = rows, cols = cols))
      }

HeatMapPlot <- function(
V, 
main = " ", 
sub = " ", 
xlab=" ", 
ylab=" ",
row.norm = TRUE,
cmap.type = 1)   # 1 = red/bluecologram, 2 = scale of violets
{
       n.rows <- length(V[,1])
       n.cols <- length(V[1,])
       row.names <- row.names(V)
       col.names <- colnames(V)       

       if (row.norm == TRUE) {
          row.mean <- apply(V, MARGIN=1, FUN=mean)
          row.sd <- apply(V, MARGIN=1, FUN=sd)
          row.n <- length(V[,1])
          for (i in 1:n.rows) {
	     if (row.sd[i] == 0) {
    	         V[i,] <- 0
             } else {
	         V[i,] <- (V[i,] - row.mean[i])/(0.333 * row.sd[i])
             }
             V[i,] <- ifelse(V[i,] < -6, -6, V[i,])
             V[i,] <- ifelse(V[i,] > 6, 6, V[i,])
           }
        }

       if (cmap.type == 1) { 
           red.blue.palette <- colorRampPalette(c("red", "white", "blue"), space = "rgb")
           mycol <- rev(red.blue.palette(20))
        } else if (cmap.type == 2) {  # range of violet
           violet.palette <- colorRampPalette(c("#400030", "white"), space = "rgb")
           mycol <- rev(violet.palette(20))
        }
        ncolors <- length(mycol) - 2

        heatm <- matrix(0, nrow = n.rows, ncol = n.cols)
        heatm[1:n.rows,] <- V[seq(n.rows, 1, -1),]
        row.names <- rev(row.names)
        maxv <- max(V)
        minv <- min(V)
        rangev <- maxv - minv

#        windows(width=14, height=9)
        par(mar = c(6, 10, 4, 1))
        image(1:n.cols, 1:n.rows, t(heatm), col=mycol, axes=FALSE, main=main, sub = sub, xlab= xlab, ylab=ylab)
        if (!is.null(row.names)) {
            numC <- nchar(row.names)
            size.row.char <- 35/(ifelse(n.rows > 50, 50, n.rows) + 12)
            for (i in 1:n.rows) {
               row.names[i] <- substr(row.names[i], 1, 35)
            }
            axis(2, at=1:n.rows, labels=row.names, adj= 0.5, tick=FALSE, las = 1, cex.axis=size.row.char, font.axis=2, line=-1)
        }
        if (!is.null(col.names)) {
            numC <- nchar(col.names)
            size.col.char <- 20/(n.cols + 15)
            for (i in 1:n.cols) {
               col.names[i] <- substr(col.names[i],  1, 35)
            }
           axis(1, at=1:n.cols, labels=col.names, tick=FALSE, las = 3, cex.axis=size.col.char, font.axis=2, line=-1)
        }

# version with sorted row and cols

#        dist.matrix <- dist(t(heatm))
#        HC <- hclust(dist.matrix, method="complete")
#        heatm <- heatm[, HC$order]
#        col.names <- col.names[HC$order]
#        dist.matrix <- dist(heatm)
#        HC <- hclust(dist.matrix, method="complete")
#        heatm <- heatm[HC$order, ]
#        row.names <- row.names[HC$order]
#        windows(width=14, height=9)
#        par(mar = c(6, 12, 3, 3))
#        image(1:n.cols, 1:n.rows, t(heatm), col=mycol, axes=FALSE, main=main, sub = sub, xlab= xlab, ylab=ylab)
#        if (!is.null(row.names)) {
#            axis(2, at=1:n.rows, labels=row.names, adj= 0.5, tick=FALSE, las = 1, cex.axis=size.row.char, font.axis=2, line=-1)
#        }
#        if (!is.null(col.names)) {
#            axis(1, at=1:n.cols, labels=col.names, tick=FALSE, las = 3, cex.axis=size.col.char, font.axis=2, line=-1)
#        }
       
	return()
}

NMF <- function(V, k, maxniter = 2000, seed = 123456, stopconv = 40, stopfreq = 10) {
        N <- length(V[,1])
        M <- length(V[1,])
        set.seed(seed)
        W <- matrix(runif(N*k), nrow = N, ncol = k)  # Initialize W and H with random numbers
        H <- matrix(runif(k*M), nrow = k, ncol = M)
        VP <- matrix(nrow = N, ncol = M)
        error.v <- vector(mode = "numeric", length = maxniter)
        new.membership <- vector(mode = "numeric", length = M)
        old.membership <- vector(mode = "numeric", length = M)
        eps <- .Machine$double.eps
        for (t in 1:maxniter) {
              VP = W %*% H
              H <- H * (crossprod(W, V)/crossprod(W, VP)) + eps
              VP = W %*% H
              H.t <- t(H)
              W <- W * (V %*% H.t)/(VP %*% H.t) + eps
              error.v[t] <- sqrt(sum((V - VP)^2))/(N * M)
               if (t %% stopfreq == 0) {
                    for (j in 1:M) {
                        class <- order(H[,j], decreasing=T)
                        new.membership[j] <- class[1]
                     }
                     if (sum(new.membership == old.membership) == M) {
                        no.change.count <- no.change.count + 1
                     } else {
                        no.change.count <- 0
                     }
                     if (no.change.count == stopconv) break
                     old.membership <- new.membership
               }
        }
        return(list(W = W, H = H, t = t, error.v = error.v))
}

nnls.fit <- function(x,y,wsqrt=1,eps=0,rank.tol=1e-07) {
  ## Purpose: Nonnegative Least Squares (similar to the S-Plus function
  ## with the same name) with the help of the R-library quadprog
  ## ------------------------------------------------------------------------
  ## Attention:
  ## - weights are square roots of usual weights
  ## - the constraint is coefficient>=eps
  ## ------------------------------------------------------------------------
  ## Author: Marcel Wolbers, July 99
  ##
  ##========================================================================
  require ("quadprog")
  m <- NCOL(x)
  if (length(eps)==1) eps <- rep(eps,m)
  x <- x * wsqrt
  y <- y * wsqrt
#  sometimes a rescaling of x and y helps (if solve.QP.compact fails otherwise)
  xscale <- apply(abs(x),2,mean)
  yscale <- mean(abs(y))
  x <- t(t(x)/xscale)
  y <- y/yscale
  Rinv <- backsolve(qr.R(qr(x)),diag(m))
  cf <- solve.QP.compact(Dmat=Rinv,dvec=t(x)%*%y,Amat=rbind(rep(1,m)),
                   Aind=rbind(rep(1,m),1:m),bvec=eps*xscale/yscale,
                         factorized=TRUE)$sol
  cf <- cf*yscale/xscale  #scale back
  cf
}
                                              
write.gct.2 <- function(gct.data.frame, descs = "", filename) 
{
    f <- file(filename, "w")
    cat("#1.2", "\n", file = f, append = TRUE, sep = "")
    cat(dim(gct.data.frame)[1], "\t", dim(gct.data.frame)[2], "\n", file = f, append = TRUE, sep = "")
    cat("Name", "\t", file = f, append = TRUE, sep = "")
    cat("Description", file = f, append = TRUE, sep = "")

    colnames <- colnames(gct.data.frame)
    cat("\t", colnames[1], file = f, append = TRUE, sep = "")

    if (length(colnames) > 1) {
       for (j in 2:length(colnames)) {
           cat("\t", colnames[j], file = f, append = TRUE, sep = "")
       }
     }
    cat("\n", file = f, append = TRUE, sep = "\t")

    oldWarn <- options(warn = -1)
    m <- matrix(nrow = dim(gct.data.frame)[1], ncol = dim(gct.data.frame)[2] +  2)
    m[, 1] <- row.names(gct.data.frame)
    if (length(descs) > 1) {
        m[, 2] <- descs
    } else {
        m[, 2] <- row.names(gct.data.frame)
    }
    index <- 3
    for (i in 1:dim(gct.data.frame)[2]) {
        m[, index] <- gct.data.frame[, i]
        index <- index + 1
    }
    write.table(m, file = f, append = TRUE, quote = FALSE, sep = "\t", eol = "\n", col.names = FALSE, row.names = FALSE)
    close(f)
    options(warn = 0)

}

DISSECTOR_explode_column_to_augment_table.v1 <- function(
   input_table,
   columns,
   output_table) {

   samples.table <- read.delim(input_table, header=T, row.names=1, sep="\t", skip=0)
   col.names <- colnames(samples.table)
   dim(samples.table)

   col.count <- ncol(samples.table)
   for (col in columns) {
      phenotypes <- samples.table[, col]
      unique.phenotypes <- unique(phenotypes)
      for (phen in unique.phenotypes) {
         if (phen == "" | (is.na(phen))) next
         print(paste("Adding column:", phen, " from original column:", col))
         vec <- rep(0, nrow(samples.table))
         vec[phenotypes == phen] <- 1
         print(paste("Num samples:", sum(vec)))
         samples.table <- cbind(samples.table, vec)
         col.names <- c(col.names, phen)
       }
    }
   vec <- rep(1, nrow(samples.table))
   samples.table <- cbind(samples.table, vec)
   col.names <- c(col.names, "ALL")

   colnames(samples.table) <- col.names
   col.names
   dim(samples.table)

   write.table(samples.table, file=output_table, quote=F, row.names=T, col.names=NA, sep="\t")
}


DISSECTOR_subset_dataset_based_on_feature.v1 <- function(
   input_dataset1,
   input_dataset2,
   feature_dataset2,
   feature_value_dataset2,    
   output_dataset1) {

  # Read input datasets

   dataset1 <- MSIG.Gct2Frame(filename = input_dataset1)
   m1 <- data.matrix(dataset1$ds)
   sample.names.1 <- colnames(m1)
   print(dim(m1))

   dataset2 <- MSIG.Gct2Frame(filename = input_dataset2)
   m2 <- data.matrix(dataset2$ds)
   sample.names.2 <- colnames(m2)   
   print(dim(m2))
   
   # Match samples
   
   overlap <- intersect(colnames(m1), colnames(m2))
   locs1 <- match(overlap, colnames(m1))
   locs2 <- match(overlap, colnames(m2))
   m1 <- m1[, locs1]
   sample.names.1 <- sample.names.1[locs1]
   print(dim(m1))
   m2 <- m2[, locs2]
   sample.names.2 <- sample.names.2[locs2]   
   print(dim(m2))   

  # select subset of m1 where the feature has the right value in m2

   locs3 <- seq(1, ncol(m1))[m2[feature_dataset2,] == feature_value_dataset2]
   m1 <- m1[, locs3]
   sample.names.1 <- sample.names.1[locs3]
   colnames(m1) <- sample.names.1

   print(dim(m1))
   write.gct(gct.data.frame = data.frame(m1), descs = row.names(m1), filename = output_dataset1)

}

DISSECTOR_subset_dataset_based_on_feature.v2 <- function(
#
# This version supports multiple features/values
#
   input_dataset1,
   input_dataset2,
   features,
   values,    
   output_dataset1) {

  # Read input datasets

   dataset1 <- MSIG.Gct2Frame(filename = input_dataset1)
   m1 <- data.matrix(dataset1$ds)
   sample.names.1 <- colnames(m1)
   print(dim(m1))

   dataset2 <- MSIG.Gct2Frame(filename = input_dataset2)
   m2 <- data.matrix(dataset2$ds)
   sample.names.2 <- colnames(m2)   
   print(dim(m2))
   
   # Match samples
   
   overlap <- intersect(colnames(m1), colnames(m2))
   print(paste("Size of overlap", length(overlap)))
   locs1 <- match(overlap, colnames(m1))
   locs2 <- match(overlap, colnames(m2))
   m1 <- m1[, locs1]
   sample.names.1 <- sample.names.1[locs1]
   print(dim(m1))
   m2 <- m2[, locs2]
   sample.names.2 <- sample.names.2[locs2]   
   print(dim(m2))   

  # Select subset of columns in m1 where the features have the right selection values in m2

   locs <- NULL
   for (j in 1: ncol(m1)) {
      for (k in 1:length(features)) {
#         print(paste("j:", j, " k:", k))
#         print(paste("feature:", features[k]))
#         print(paste("content:", m2[features[k], j]))                 
         if (m2[features[k], j] == values[k]) locs <- c(locs, j)
      }
   }
   locs <- unique(locs)
   print(paste("Selected:", length(locs), " from a total of ", ncol(m1), " columns"))
   m1 <- m1[, locs]
   sample.names.1 <- sample.names.1[locs]
   colnames(m1) <- sample.names.1

   print(dim(m1))
   print(colnames(m1))
   write.gct(gct.data.frame = data.frame(m1), descs = row.names(m1), filename = output_dataset1)
}

DISSECTOR_subset_dataset_based_on_phenotype.v1 <- function(
   input_dataset,
   phen_table,
   phenotypes,
   output_dataset,
   exclude_these_samples = NULL)

{
   dataset1 <- MSIG.Gct2Frame(filename = input_dataset)
   m.1 <- data.matrix(dataset1$ds)
   sample.names.1 <- colnames(m.1)
   print(dim(m.1))

   if (!is.null(exclude_these_samples)) {
      locs <- match(exclude_these_samples, colnames(m.1))
      locs <- locs[!is.na(locs)]
      print(paste("Excluding samples:", sample.names.1[locs]))
      m.1 <- m.1[, -locs]
      sample.names.1 <- colnames(m.1)
      Ns.1 <- ncol(m.1)
      print(paste("Total samples after exclusion:", Ns.1))
    }  
   
    if (!is.null(phen_table) & !is.null(phenotypes)) {
         samples.table <- read.delim(phen_table, header=T, row.names=1, sep="\t", skip=0)
         print("colnames sample.table")
         print(colnames(samples.table))         
         
         table.sample.names <- row.names(samples.table)
         print("Subselecting samples with phenotypes: ")
         print(phenotypes)
         overlap <- intersect(colnames(m.1), table.sample.names)
         print(paste("overlap:", length(overlap)))
         locs1 <- match(overlap, table.sample.names)
         locs2 <- match(overlap, colnames(m.1))
         m.1 <- m.1[, locs2]
         sample.phen <- vector(length(locs1), mode="numeric")
         for (i in 1:length(locs1)) {
             sample.phen[i] <- 0
             for (j in 1:length(phenotypes)) {
                 print(paste("i:", i, " j:", j))
                 print(paste("locs1:", locs1[i]))
                 print(paste("phenotypes:", phenotypes[j]))                 
                 print(paste("phenotypes:", phenotypes[j]))                 
                 print(paste("samples.table[locs1[i], phenotypes[j]]:", samples.table[locs1[i], phenotypes[j]]))
                if (!is.na(samples.table[locs1[i], phenotypes[j]])) {
                    if (samples.table[locs1[i], phenotypes[j]] == 1) {
                              sample.phen[i] <- 1
                    }
                }
              }
         }
         print("sample.phen")
         print(sample.phen)
         
         m.1 <- m.1[, sample.phen == 1]
         sample.names.1 <- colnames(m.1)
         Ns.1 <- ncol(m.1) 
         print(paste("Matching phenotypes total number of samples:", ncol(m.1)))
         print(dim(m.1))
         print(sample.names.1)
   }

   print(dim(m.1))
   write.gct(gct.data.frame = data.frame(m.1), descs = row.names(m.1), filename = output_dataset)
}


DISSECTOR_match_and_merge_datasets.v1 <- function(
   input_dataset1,
   input_annot_file1 = NULL,
   input_dataset2,
   input_annot_file2 = NULL,
   output_dataset,
   output_annot_file = NULL) {

# start of methodology

# Read input datasets

   dataset1 <- MSIG.Gct2Frame(filename = input_dataset1)
   m1 <- data.matrix(dataset1$ds)
   gs.names1 <- dataset1$row.names
   gs.descs1 <- dataset1$descs
   sample.names1 <- dataset1$names

   dataset2 <- MSIG.Gct2Frame(filename = input_dataset2)
   m2 <- data.matrix(dataset2$ds)
   gs.names2 <- dataset2$row.names
   gs.descs2 <- dataset2$descs
   sample.names2 <- dataset2$names

# Match features to first dataset and create matching m2 dataset

   gs.names3 <- intersect(gs.names1, gs.names2)

   locations1 <- match(gs.names3, gs.names1, nomatch=0)
   m1 <- m1[locations1, ]
   gs.descs1 <- gs.descs1[locations1]

   locations2 <- match(gs.names3, gs.names2, nomatch=0)
   m2 <- m2[locations2, ]
   gs.descs2 <- gs.descs2[locations2]

# Merge datasets

   m3 <- cbind(m1, m2)
   sample.names3 <- c(sample.names1, sample.names2)

# Save datasets

   V <- data.frame(m3)
   row.names(V) <- gs.names3
   write.gct(gct.data.frame = V, descs = gs.descs1, filename = output_dataset)  

}


DISSECTOR_match_and_merge_datasets.v2 <- function(
   input_dataset1,
   input_annot_file1 = NULL,
   input_dataset2,
   input_annot_file2 = NULL,
   match_rows = T,   # T = combine samples using common rows, F = combine rows using common columns
   output_dataset,
   output_annot_file = NULL) {

# start of methodology

# Read input datasets

   dataset1 <- MSIG.Gct2Frame(filename = input_dataset1)
   m1 <- data.matrix(dataset1$ds)
   gs.names1 <- dataset1$row.names
   gs.descs1 <- dataset1$descs
   sample.names1 <- dataset1$names

   dataset2 <- MSIG.Gct2Frame(filename = input_dataset2)
   m2 <- data.matrix(dataset2$ds)
   gs.names2 <- dataset2$row.names
   gs.descs2 <- dataset2$descs
   sample.names2 <- dataset2$names

# Match features to first dataset and create matching m2 dataset

   if (match_rows == T) {  # combine samples using common rows

      gs.names3 <- intersect(gs.names1, gs.names2)
      print(paste("size of overlap (rows):", length(gs.names3)))
      
      locations1 <- match(gs.names3, gs.names1, nomatch=0)
      m1 <- m1[locations1, ]
      gs.descs1 <- gs.descs1[locations1]

      locations2 <- match(gs.names3, gs.names2, nomatch=0)
      m2 <- m2[locations2, ]
      gs.descs2 <- gs.descs2[locations2]

      # Merge datasets

      m3 <- cbind(m1, m2)
      sample.names3 <- c(sample.names1, sample.names2)

      # Save dataset

     V <- data.frame(m3)
     row.names(V) <- gs.names3
     write.gct(gct.data.frame = V, descs = gs.descs1, filename = output_dataset)

  } else { # combine rows using common columns

      sample.names3 <- intersect(sample.names1, sample.names2)
      print(paste("size of overlap (columns):", length(sample.names3)))
      
      locations1 <- match(sample.names3, sample.names1, nomatch=0)
      m1 <- m1[, locations1]

      locations2 <- match(sample.names3, sample.names2, nomatch=0)
      m2 <- m2[, locations2]

      # Merge datasets

      m3 <- rbind(m1, m2)
      gs.names3 <- c(gs.names1, gs.names2)
      gs.descs3 <- c(gs.descs1, gs.descs2)      

      # Save dataset

      V <- data.frame(m3)
      row.names(V) <- gs.names3
      write.gct(gct.data.frame = V, descs = gs.descs3, filename = output_dataset)
  }
}

   DISSECTOR_generate_mut_vs_wt_landscape_plot.v1 <- function(
      #
      #  For an input file and selected gene generate the mut vs wt landscape plot
      #
      input_dataset,                    # Input dataset (GCT). This is e.g. an original dataset A or the H matrix
      association_metric = "IC",        # Association metric: "IC" (Information Coefficient)
      output_plot)                      # Output (PDF) landscape plot file
   {

   set.seed(5209761)

   pdf(file=output_plot, height=8.5, width=8.5)
   
   # Read input dataset

   dataset.1 <- MSIG.Gct2Frame(filename = input_dataset)
   H <- data.matrix(dataset.1$ds)
   print(paste("Dimensions dataset1:", dim(H)))

   gene.names <- NULL
   alteration.names <- NULL
   for (i in 1:ncol(H)) {
      temp <- unlist(strsplit(colnames(H)[i], split="_"))
      gene.names[i] <- temp[1]
      alteration.names[i] <- temp[2]
   }

   table(gene.names)
   
   gene.sizes <- sort(table(gene.names), decreasing=T)
   u.gene.names <- names(gene.sizes)
   
   for (i in 1:length(u.gene.names)) {
   
   selected_gene <- u.gene.names[i]

   if (gene.sizes[selected_gene] < 4) next
   
   locs <- gene.names == selected_gene
   H2 <- H[,locs]
   gene.names2 <- gene.names[locs]
   alteration.names2 <- alteration.names[locs]

   loc.wt <- match("WT", alteration.names2)

   print(paste("Working on selected gene:", selected_gene, colnames(H2)))
   
   # Landscape plot
       
   mycol <- vector(length=512, mode = "numeric")   # Red/Blue "pinkogram" color map
   for (k in 1:256) mycol[k] <- rgb(255, k - 1, k - 1, maxColorValue=255)
   for (k in 257:512) mycol[k] <- rgb(511 - (k - 1), 511 - (k - 1), 255, maxColorValue=255)
   mycol <- rev(mycol)
   ncolors <- length(mycol)

   col.classes <- c("darkseagreen2", "mediumorchid2", brewer.pal(7, "Set1"), brewer.pal(7, "Dark2"),
                 brewer.pal(7, "Paired"), brewer.pal(8, "Accent"), brewer.pal(8, "Set2"), brewer.pal(11, "Spectral"), brewer.pal(12, "Set3"),
                 sample(c(brewer.pal(9, "Blues"), brewer.pal(9, "Reds"), brewer.pal(9, "Oranges"), brewer.pal(9, "Greys"),
                          brewer.pal(9, "Purples"), brewer.pal(9, "Greens"))))

   assoc.matrix <- DISSECTOR_compute_assoc_or_dist.v1(input_matrix1 = H2, input_matrix2 = H2, object_type = "columns",
                                                     assoc_metric = "IC", distance = F)
   print(assoc.matrix)

   if (is.na(loc.wt)) {
      MI.ref <- rep(0.4, ncol(assoc.matrix))
   } else {
      MI.ref <- assoc.matrix[loc.wt,]
      MI.ref <- MI.ref[-loc.wt]
      assoc.matrix <- assoc.matrix[-loc.wt, -loc.wt]
  }
   nf <- layout(matrix(1, 1, byrow=T), 1, 1, FALSE)

   assoc.matrix2 <-  1 - (assoc.matrix + 1)/2
   for (i in 1:nrow(assoc.matrix2)) assoc.matrix2[i, i] <- 0
   
   smacof.map <- smacofSphere(assoc.matrix2, ndim = 2, weightmat = NULL, init = NULL,
                          ties = "primary", verbose = FALSE, modulus = 1, itmax = 1000, eps = 1e-6)
   x0 <- smacof.map$conf[-1,1]
   y0 <- smacof.map$conf[-1,2]
   r <- sqrt(x0*x0 + y0*y0)
   radius <- 1 - (MI.ref + 1)/2
   max.radius <- 0.75
   
   angles <- atan2(y0, x0)
   par(mar = c(2,2,2,2))
   plot(x, y, pch=20, bty="n", xaxt='n', axes = FALSE, type="n", xlab="", ylab="",
        xlim=1.1*c(-max.radius, max.radius), ylim=1.1*c(-max.radius, max.radius))
   line.angle <- seq(0, 2*pi-0.001, 0.001)

   ref.radius <- seq(max.radius/10, max.radius, max.radius/10)
   for (j in 1:length(ref.radius)) {
      line.max.x <- ref.radius[j] * cos(line.angle)
      line.max.y <- ref.radius[j] * sin(line.angle)
      points(line.max.x, line.max.y, type="l", col="gray80", lwd=1)
      text(0, ref.radius[j], signif((1 - 2*ref.radius[j]), 2), cex=0.7, col="gray60", pos=1)
  }
   text(0, 1.1*max.radius, "IC", cex=0.85, col="gray60", pos=1)   
   for (j in 1:length(x)) {   
      points(c(0, x[j]), c(0, y[j]), type="l", col="gray80", lwd=1)      
   }   
   line.max.x <- 1.1*max.radius * cos(line.angle)
   line.max.y <- 1.1*max.radius * sin(line.angle)
   points(line.max.x, line.max.y, type="l", col="purple", lwd=2)
   points(x, y, pch=21, bg="red", col="red", cex=2)
   if (!is.na(loc.wt)) {
      points(0, 0, pch=21, bg="darkgreen", col="darkgreen", cex=2.0)
      text(0, 0, colnames(H2)[loc.wt], cex=1, col="darkgreen", pos=3)
   }

   pointLabel(x, y, paste("   ", colnames(assoc.matrix2), "   "), cex=1, col="red")
#    text(x, y, paste("   ", colnames(assoc.matrix2), "   "), cex=0.8, col="red", pos=2)


   }  # loop over genes
   
   dev.off()

}

Norm <- function(x, n) {
                x <- (x - min(x))/(max(x) - min(x))
                return((n - 1) * x + 1)
               }


Norm2 <- function(x, n) {
                x <- (x - mean(x))/sd(x)
                x[x > 3] <- 3
                x[x < -3] <- -3
                return((n - 1) * (x + 3)/6 + 1)
               }


   DISSECTOR_make_dataset_with_feature_subset.v1 <- function(
       input_dataset,
       features,
       output_dataset)       
    {
       dataset <- MSIG.Gct2Frame(filename = input_dataset)
       m <- data.matrix(dataset$ds)
       descs <- dataset$descs
       sample.names <- dataset$names

       locs <- match(features, row.names(m))
       locs <- locs[!is.na(locs)]
       print(paste("Number of original features:", length(features)))       
       print(paste("Number of matching features:", length(locs)))

       m <- m[locs,]
       descs <- descs[locs]

       if (length(locs) < 50) print(row.names(m))

       if (length(locs) < 50) {
           print("unmatched features:")
           print(setdiff(features, row.names(m)))
       }
       write.gct.2(gct.data.frame = m, descs = descs, filename = output_dataset)

   }

   DISSECTOR_make_panel_of_genomic_features.v1 <- function(
      input_dataset,
      target,
      feature.files,                           
      features,
      feature.aliases = NULL,
      output.file,
      description            = "",
      sort.by.target         = T,
      direction              = "positive",
      missing.value.color    = "khaki1",                  # Missing feature color
      binary.0_value.color   = "lightgray",                 # Binary feature's 0's color 
      binary.1_value.color   = "black",                 # Binary feature's 1's color
      character.scaling      = 1.5,
      n.perm                 = 10000,
      create.feature.summary = F,
      feature.combination.op = "max",
      exclude.feature.NA.vals = F,
      left_margin            = 20,
      max.entries            = 32,
      pdf.size               = c(14, 11),
      nicknames              = NULL,
      target.style           = "color.bar",          # "color.bar" or "bar.graph"
      show.samples.names     = F,
      sort_features_in_panel = F,
      exclude_flat_features  = F,
      l.panels               = NULL)

 {
   library(maptools)
   library(RColorBrewer)

   set.seed(5209761)

   mycol <- vector(length=512, mode = "numeric")
   for (k in 1:256) mycol[k] <- rgb(255, k - 1, k - 1, maxColorValue=255)
   for (k in 257:512) mycol[k] <- rgb(511 - (k - 1), 511 - (k - 1), 255, maxColorValue=255)
   mycol <- rev(mycol)
   max.cont.color <- 512
   mycol <- c(mycol,
              missing.value.color,                  # Missing feature color
              binary.0_value.color,                 # Binary feature's 0's color 
              binary.1_value.color)                 # Binary feature's 1's color 

   categ.col <- c("#9DDDD6", # dusty green
                     "#F0A5AB", # dusty red
                     "#9AC7EF", # sky blue
                     "#F970F9", # violet
                     "#FFE1DC", # clay
                     "#FAF2BE", # dusty yellow
                     "#AED4ED", # steel blue
                     "#C6FA60", # green
                     "#D6A3FC", # purple
                     "#FC8962", # red
                     "#F6E370", # orange
                     "#F0F442", # yellow
                     "#F3C7F2", # pink
                     "#D9D9D9", # grey
                     "#FD9B85", # coral
                     "#7FFF00", # chartreuse
                     "#FFB90F", # goldenrod1
                     "#6E8B3D", # darkolivegreen4
                     "#8B8878", # cornsilk4
                     "#7FFFD4") # aquamarine

   binary.col <- c(binary.0_value.color,  binary.1_value.color)

   cex.size.table <- c(1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9,   # 1-10 characters
                       0.9, 0.9, 0.9, 0.9, 0.8, 0.8, 0.8, 0.8, 0.7, 0.7, # 11-20 characters
                       0.7, 0.7, 0.7, 0.7, 0.7, 0.6, 0.6, 0.6, 0.6, 0.6)

   pdf(file=output.file, height=pdf.size[1], width=pdf.size[2])
#   tiff(filename = output.file, width = 1200, height = 1200, compression = "lzw")
#    png(filename = output.file, width = 1200, height = 1200)

   if (is.null(l.panels)) {
      n.panels <- length(feature.files) 
      l.panels <- NULL

      if (target.style == "color.bar") {          
         for (l in 1:n.panels) l.panels <- c(l.panels, 1.5, length(features[[l]]))
     } else if (target.style == "bar.graph") {                   
         for (l in 1:n.panels) l.panels <- c(l.panels, 2, length(features[[l]]))
     } else {
           stop(paste("ERROR: unknown target style", target.style))
     }
      l.panels[l.panels < 2] <- 1.5
      empty.panel <- max.entries - sum(unlist(l.panels))
      l.panels <- c(l.panels, empty.panel)
   }       
   n.panels <- length(l.panels)

   print(paste("n.panels", n.panels))
   print("l.panels")
   print(paste(l.panels, collapse=","))
      
   nf <- layout(matrix(c(seq(1, n.panels - 1), 0), n.panels, 1, byrow=T), 1, l.panels,  FALSE)
                      
   for (f in 1:length(feature.files)) {   # loop over feature types
      print(paste("Processing feature file:", feature.files[[f]]))
      dataset <- MSIG.Gct2Frame(filename = input_dataset)
      m.1 <- data.matrix(dataset$ds)
      sample.names.1 <- colnames(m.1)
      Ns.1 <- ncol(m.1)
      print(paste("Total samples in input file:", Ns.1))

      target.vec <- m.1[target,]
      non.nas <- !is.na(target.vec)
      sample.names.1 <- sample.names.1[non.nas]
      m.1 <- m.1[, non.nas]
      Ns.1 <- ncol(m.1)
      
      print(paste("Total non-NAs target samples in input file:", Ns.1))
      
      dataset.2 <- MSIG.Gct2Frame(filename = feature.files[[f]])
      m.2 <- data.matrix(dataset.2$ds)
      dim(m.2)
      row.names(m.2) <- dataset.2$row.names
      Ns.2 <- ncol(m.2)  
      sample.names.2 <- colnames(m.2) <- dataset.2$names

      print(paste("Total samples in features file:", Ns.2))

      if (exclude.feature.NA.vals == T) {

         feature.non.nas <- rep(1, ncol(m.2))
       
         for (feat.n in 1:length(features[[f]])) { 
           feature.name <- unlist(features[[f]][feat.n])
           for (j in 1:ncol(m.2)) {
               print(paste("feature.name:", feature.name, " j:", j, " dim m.2:", dim(m.2)))
               flush.console()
               if (is.na(m.2[feature.name, j])) feature.non.nas[j] <- 0
           }
         }
         m.2 <- m.2[, feature.non.nas == 1]
         Ns.2 <- ncol(m.2)  
         sample.names.2 <- colnames(m.2) 

         print(paste("Total non-NAs samples in feature file:", Ns.2))
     }
      
      overlap <- intersect(sample.names.1, sample.names.2)
      locs1 <- match(overlap, sample.names.1)
      locs2 <- match(overlap, sample.names.2)
      m.1 <- m.1[, locs1]
      m.2 <- m.2[, locs2]
      Ns.1 <- ncol(m.1)
      Ns.2 <- ncol(m.2)
      sample.names.1 <- colnames(m.1)
      sample.names.2 <- colnames(m.2)
      
      print(paste("feature file overlap with target samples:", length(overlap)))

      target.vec <- m.1[target,]

      if (sort.by.target == T) {
         ind <- order(target.vec, decreasing=T)
         target.vec <- target.vec[ind]
         sample.names.1 <- sample.names.1[ind]
         m.1 <- m.1[, ind]
         m.2 <- m.2[, ind]         
         sample.names.2 <- sample.names.2[ind]
      }
      if (direction == "negative") {
         if (length(table(target.vec)) > length(target.vec)*0.5) { # continuous target
            target.vec <- -target.vec
         } else {
            target.vec <-  1 - target.vec
         }
      } else if (direction == "positive") {

      } else {
         stop(paste("Unknown direction:", direction))
      }

    # normalize target
      unique.target.vals <- unique(target.vec)
      n.vals <- length(unique.target.vals)
      if (n.vals >= length(target.vec)*0.5) {    # Continuous value color map        
         cutoff <- 2.5
         x <- target.vec
         x <- (x - mean(x))/sd(x)         
         target.vec.norm <- x
         x[x > cutoff] <- cutoff
         x[x < - cutoff] <- - cutoff
         x <- ceiling((max.cont.color - 1) * (x + cutoff)/(cutoff*2)) + 1
         target.vec <- x
      }
  #    if (f == 1) {
  #        main <- description
  #    } else {
  #        main <- ""
  #    }
      main <- names(feature.files)[[f]]
#      par(mar = c(0, 16, 2, 12))
      par(mar = c(0, left_margin, 4, 12))

      target.nchar <- ifelse(nchar(target) > 30, 30, nchar(target))
#      cex.axis <- cex.size.table[target.nchar]
      cex.axis <- 1
#      print(paste("cex.axis:", cex.axis))      
      
      if (n.vals >= length(target.vec)*0.5) {    # Continuous value color map

       if (target.style == "color.bar") {          
          image(1:Ns.1, 1:1, as.matrix(target.vec), zlim = c(0, max.cont.color), col=mycol[1: max.cont.color],
                axes=FALSE, main=main, sub = "", xlab= "", ylab="", cex.main=1.35*character.scaling)
          ref1 <- 1
          ref2 <- 1
          
       } else if (target.style == "bar.graph") {
            V1.vec <- as.vector(target.vec.norm)
            V1.vec <- (V1.vec - min(V1.vec))/(max(V1.vec) - min(V1.vec))
            barplot(V1.vec, xaxs="i", ylim=c(-0.25, 1), col="darkgrey", border="darkgrey", xaxt='n', yaxt='n',
                    ann=FALSE, bty='n', width=1, space=0)
           points(seq(1, length(V1.vec)), V1.vec, type="l", col=1)
           points(rep(0, 11), seq(0, 1, 0.1), type="l", col=1)
           points(seq(1, length(V1.vec)), rep(0, length(V1.vec)), type="l", col=1)
           ref1 <- 0.5
            ref2 <- -0.25
           
       } else {
           stop(paste("ERROR: unknown target style", target.style))
       }


      } else if (n.vals == 2) {  # binary
         image(1:Ns.1, 1:1, as.matrix(target.vec), zlim = range(target.vec), col=binary.col, axes=FALSE, cex.main=1.35*character.scaling, main=main, sub = "", xlab= "", ylab="",
                cex.main=2)
          ref1 <- 1
          ref2 <- 1
          target.vec.norm <- target.vec         
   
      } else {  # categorical
         image(1:Ns.1, 1:1, as.matrix(target.vec), zlim = range(target.vec), col=categ.col[1:n.vals], cex.main=1.35*character.scaling, axes=FALSE, main=main, sub = "",
               xlab= "", ylab="", cex.main=2)
          ref1 <- 1
          ref2 <- 1
          target.vec.norm <- target.vec                  

      }

      if (!is.na(match(target, names(nicknames)))) {
          target.name <- nicknames[target]
      } else {
           target.name <- target
      }
      axis(2, at=ref1, labels=target.name, adj= 0.5, tick=FALSE, las = 1, cex=1, cex.axis=cex.axis*character.scaling,
            line=0, font=2, family="",font.axis=1)
      axis(4, at=ref2, labels=paste(" IC     p-value"), adj= 0.5, tick=FALSE, las = 1, cex=1, cex.axis=cex.axis*character.scaling,
           font.axis=1, line=0, font=2, family="")

      feature.mat <- feature.names <- NULL
      
     for (feat.n in 1:length(features[[f]])) { 
        len <- length(unlist(features[[f]][feat.n]))         
        feature.name <- unlist(features[[f]][feat.n])
        print(paste("      Feature:", feature.name))
        if (is.na(match(feature.name, row.names(m.2)))) next

        if (exclude_flat_features == T & sum(m.2[feature.name,]) == 0) next
        
        feature.mat <- rbind(feature.mat,  m.2[feature.name,])
        if (!is.null(feature.aliases[1])) {
           if (!is.na(match(feature.name, names(feature.aliases)))) {
               feature.name <- unlist(feature.aliases[feature.name])
           }
       }
        if (!is.na(match(feature.name, names(nicknames)))) {
           feature.name <- nicknames[feature.name]
        } 
        feature.names <- c(feature.names, feature.name)
      }
      feature.mat <- as.matrix(feature.mat)
      row.names(feature.mat) <- feature.names

      if (create.feature.summary == T) {
         summary.feature <- apply(feature.mat, MARGIN=2, FUN=feature.combination.op)
         feature.mat <- rbind(feature.mat, summary.feature)
         row.names(feature.mat) <- c(feature.names, "SUMMARY FEATURE")
     }

            # compute IC association with target

      IC.vec <- p.val.vec <- stats.vec <- NULL
      
      for (i in 1:nrow(feature.mat)) {
           feature.vec <- feature.mat[i,]
           IC <- IC.v1(feature.vec, target.vec.norm)
#           print(paste("Feature:", row.names(feature.mat)[i], " IC=", IC))
           IC <- signif(IC, 3)
           null.IC <- vector(length=n.perm, mode="numeric")
           for (h in 1:n.perm) null.IC[h] <- IC.v1(feature.vec, sample(target.vec))
           if (IC >= 0) {
             p.val <- sum(null.IC >= IC)/n.perm
           } else {
             p.val <- sum(null.IC <= IC)/n.perm
           }
           p.val <- signif(p.val, 3)
           if (p.val == 0) {
#             p.val <- paste("< ", signif(1/n.perm, 3), sep="")
              p.val <- signif(1/n.perm, 3)
           }
           IC.vec <- c(IC.vec, IC)
           p.val.vec <- c(p.val.vec, p.val)
           space.chars <- "           "
           IC.char <- nchar(IC)
           pad.char <- substr(space.chars, 1, 10 - IC.char)
           stats.vec <- c(stats.vec, paste(IC, pad.char, p.val, sep=""))
       }

     for (i in 1:nrow(feature.mat)) {

           feature.vec <- feature.mat[i,]
           unique.feature.vals <- unique(sort(feature.vec))
           non.NA.vals <- sum(!is.na(feature.vec))
           n.vals <- length(unique.feature.vals)
           if (n.vals > 2) {    # Continuous value color map        
              feature.vals.type <- "continuous"
              cutoff <- 2.5
              x <- feature.vec
              locs.non.na <- !is.na(x)
              x.nonzero <- x[locs.non.na]
              x.nonzero <- (x.nonzero - mean(x.nonzero))/sd(x.nonzero)         
              x.nonzero[x.nonzero > cutoff] <- cutoff
              x.nonzero[x.nonzero < - cutoff] <- - cutoff      
              feature.vec[locs.non.na] <- x.nonzero
              feature.vec2 <- feature.vec
              feature.vec[locs.non.na] <- ceiling((max.cont.color - 2) * (feature.vec[locs.non.na] + cutoff)/(cutoff*2)) + 1
              feature.vec[is.na(x)] <- max.cont.color + 1
              feature.mat[i,] <- feature.vec              
           }
      }
      feature.mat <- as.matrix(feature.mat)

      

      if (sort_features_in_panel == T & nrow(feature.mat) > 1) {
          ind <- order(IC.vec, decreasing=T)
          IV.vec <- IC.vec[ind]
          stats.vec <- stats.vec[ind]
          feature.mat <- feature.mat[ind,]
      }
      
      print("feature matrix dimensions:")
      print(paste(nrow(feature.mat), ncol(feature.mat)))
      
      if (nrow(feature.mat) > 1) {
          V <- apply(feature.mat, MARGIN=2, FUN=rev)
      } else {
          V <- as.matrix(feature.mat)
      }
      
      features.max.nchar <- max(nchar(row.names(V)))
      features.nchar <- ifelse(features.max.nchar > 30, 30, features.max.nchar)
#      cex.axis <- cex.size.table[features.nchar]
#      print(paste("cex.axis:", cex.axis))

#      par(mar = c(1, 2, 1, 12))
#      par(mar = c(3, left_margin, 1, 12))
      par(mar = c(1.5, left_margin, 1, 12))            

      main <- names(feature.files)[[f]]
      
     if (n.vals > 2) {    # Continuous value color map        
         image(1:dim(V)[2], 1:dim(V)[1], t(V), zlim = c(0, max.cont.color + 3), col=mycol, axes=FALSE, main="", cex.main=0.8, sub = "", xlab= "", ylab="")
     } else {  # binary
         image(1:dim(V)[2], 1:dim(V)[1], t(V), zlim = c(0, 1), col=binary.col, axes=FALSE, main="", cex.main=0.4,  sub = "", xlab= "", ylab="")
     }
     axis(2, at=1:dim(V)[1], labels=row.names(V), adj= 0.5, tick=FALSE, las = 1, cex=1, cex.axis=cex.axis*character.scaling, font.axis=1, line=0, font=2, family="")
     axis(4, at=1:dim(V)[1], labels=rev(stats.vec), adj= 0.5, tick=FALSE, las = 1, cex=1, cex.axis=cex.axis*character.scaling, font.axis=1, line=0, font=2, family="")
      if (show.samples.names == T) {
           axis(1, at=1:dim(V)[2], labels=colnames(V), adj= 0.5, tick=FALSE, las = 3, cex=1, cex.axis=0.05*cex.axis*character.scaling, font.axis=1, line=-1, font=2, family="")
           col.names <- colnames(V)
#           for (k in 1:length(col.names)) print(paste(k, col.names[k]))
      }

 
     }
   dev.off()
}

DISSECTOR_gene_sets_overlap <- function(
    gmt.file1,
    gmt.file2,
    gene.set1,
    gene.set2,
    gmt.name,
    gmt.output)

    {
       if (gmt.file1 == gmt.file2) {
          gene.set.files <- gmt.file1
       } else {
          gene.set.files <- c(gmt.file1, gmt.file2)
       }
        
	# Read gene set files
	
	max.G <- 0
	max.N <- 0
	for (gsdb in gene.set.files) {
		GSDB <- Read.GeneSets.db(gsdb, thres.min = 2, thres.max = 2000, gene.names = NULL)
		max.G <- max(max.G, max(GSDB$size.G))
		max.N <- max.N +  GSDB$N.gs
	}
	N.gs <- 0
	gs <- matrix("null", nrow=max.N, ncol=max.G)
	gs.names <- vector(length=max.N, mode="character")
	gs.descs <- vector(length=max.N, mode="character")
	size.G <- vector(length=max.N, mode="numeric")
	start <- 1
	for (gsdb in gene.set.files) {
		GSDB <- Read.GeneSets.db(gsdb, thres.min = 2, thres.max = 2000, gene.names = NULL)
		N.gs <- GSDB$N.gs 
		gs.names[start:(start + N.gs - 1)] <- GSDB$gs.names
		gs.descs[start:(start + N.gs - 1)] <- GSDB$gs.desc
		size.G[start:(start + N.gs - 1)] <- GSDB$size.G
		gs[start:(start + N.gs - 1), 1:max(GSDB$size.G)] <- GSDB$gs[1:N.gs, 1:max(GSDB$size.G)]
		start <- start + N.gs
	}
	N.gs <- max.N

        loc1 <- match(gene.set1, gs.names)
        set1 <- gs[loc1,]
        set1 <- gs[loc1, 1:size.G[loc1]]
        loc2 <- match(gene.set2, gs.names)
        set2 <- gs[loc2,]
        set2 <- gs[loc2, 1:size.G[loc2]]

        print(paste("Size of gene set 1", gene.set1, " = ", length(set1)))
        print(paste("Size of gene set 2", gene.set2, " = ", length(set2)))       
        overlap <- intersect(set1, set2)
        print(paste("Size of overlap = ", length(overlap)))
        print("Overlap:")
        print(overlap)                     

        row.header <- gmt.name
        output.line <- paste(overlap, collapse="\t")
        output.line <- paste(row.header, row.header, output.line, sep="\t")
        write(noquote(output.line), file = gmt.output, append = F, ncolumns = length(overlap) + 2)

   }


DISSECTOR_features_overlap <- function(
   file1,
   file2,
   direction_file2 = "positive", # "negative"
   exclude_suffix1 = F,
   exclude_suffix2 = F,    
   n.markers = 50,
   output.file,
   gmt.names = NULL,
   gmt.file = NULL,
   append.gmt = F)
{

   write("Overlap Analysis", file = output.file, ncolumns = 50, append = FALSE, sep = "")
   write(file1, file = output.file, ncolumns = nchar(file1), append  =TRUE, sep = "\t")
   write(file2, file =output.file, ncolumns = nchar(file2), append =TRUE, sep = "\t")

   df1 <- read.table(file1, header=T, row.names=1, sep="\t", skip=0)
   df2 <- read.table(file2, header=T, row.names=1, sep="\t", skip=0)

  features1 <- df1[,"Feature"]
  features2 <- df2[,"Feature"]

  if (direction_file2 == "negative") features2 <- rev(features2)

  up.markers1.orig <- up.markers1 <- as.character(features1[1:n.markers])
  dn.markers1.orig <- dn.markers1 <- as.character(features1[seq(length(features1) - n.markers + 1, length(features1))])

  for (i in 1:length(up.markers1)) up.markers1[i] <- strsplit(up.markers1[i], " ")[[1]]
  for (i in 1:length(dn.markers1)) dn.markers1[i] <- strsplit(dn.markers1[i], " ")[[1]]   
   
  if (exclude_suffix1 == T) {
     for (i in 1:length(up.markers1)) up.markers1[i] <- strsplit(up.markers1[i], "_")[[1]]
     for (i in 1:length(dn.markers1)) dn.markers1[i] <- strsplit(dn.markers1[i], "_")[[1]]
  }

  up.markers2.orig <- up.markers2 <- as.character(features2[1:n.markers])
  dn.markers2.orig <- dn.markers2 <- as.character(features2[seq(length(features2) - n.markers + 1,  length(features2))])

  for (i in 1:length(up.markers2)) up.markers2[i] <- strsplit(up.markers2[i], " ")[[1]]
  for (i in 1:length(dn.markers2)) dn.markers2[i] <- strsplit(dn.markers2[i], " ")[[1]]   
   
  if (exclude_suffix2 == T) {
     for (i in 1:length(up.markers2)) up.markers2[i] <- strsplit(up.markers2[i], "_")[[1]]
     for (i in 1:length(dn.markers2)) dn.markers2[i] <- strsplit(dn.markers2[i], "_")[[1]]
  }
   
  print("                 ")
  write("          ", file =output.file, ncolumns = 50, append =TRUE, sep = "\t")
  print("Up Markers Overlap")
  write("Up Markers Overlap", file =output.file, ncolumns = 50, append =TRUE, sep = "\t")
  up.overlap <- intersect(up.markers1, up.markers2)
  print(paste("Size of up overlap:", length(up.overlap)))
  write(paste("Size of up overlap:", length(up.overlap)), file =output.file, ncolumns = 50, append =TRUE, sep = "\t")
  print(cbind(up.overlap))
  write.table(cbind(up.overlap), file=output.file, quote=F, col.names = T, row.names = F, append = T, sep="\t")

  if (!is.null(gmt.names)) {
      row.header <- gmt.names[1]
      output.line <- paste(up.overlap, collapse="\t")
      output.line <- paste(row.header, row.header, output.line, sep="\t")
      write(noquote(output.line), file = gmt.file, append = append.gmt, ncolumns = length(up.overlap) + 2)
  }
   
  print("                 ")
  write("          ", file =output.file, ncolumns = 50, append =TRUE, sep = "\t")
  print("Down Markers Overlap")
  write("Down Markers Overlap", file =output.file, ncolumns = 50, append =TRUE, sep = "\t")
  dn.overlap <- intersect(dn.markers1, dn.markers2)
  print(paste("Size of down overlap:", length(dn.overlap)))
  write(paste("Size of down overlap:", length(dn.overlap)), file =output.file, ncolumns = 50, append =TRUE, sep = "\t")
  print(cbind(dn.overlap))
  write.table(cbind(dn.overlap), file=output.file, quote=F, col.names = T, row.names = F, append = T, sep="\t")

  if (!is.null(gmt.names)) {
      row.header <- gmt.names[2]
      output.line <- paste(dn.overlap, collapse="\t")
      output.line <- paste(row.header, row.header, output.line, sep="\t")
      write(noquote(output.line), file = gmt.file, append = T, ncolumns = length(dn.overlap) + 2)
  }

  print("                 ")
  write("          ", file =output.file, ncolumns = 50, append =TRUE, sep = "\t")
  print("Up Marker Features")
  write("Up Markers Features", file =output.file, ncolumns = 50, append =TRUE, sep = "\t")
  locs <- match(up.markers1.orig, features2)

  up.table <- cbind(as.character(up.markers1.orig), seq(1, n.markers),locs, ifelse(locs <= rep(n.markers, n.markers), rep("*", n.markers),rep(" ", n.markers)))
  colnames(up.table) <- c("Feature", "Rank in file1", "Rank in file2", "Overlap")
  print(noquote(up.table))
  write.table(cbind(up.table), file=output.file, quote=F, col.names = T, row.names = F, append = T, sep="\t")

  print("                 ")
  write("          ", file =output.file, ncolumns = 50, append =TRUE, sep = "\t")
  print("Down Marker Features")
  write("Down Markers Features", file =output.file, ncolumns = 50, append =TRUE, sep = "\t")
  locs <- match(dn.markers1.orig, features2)
  locs <- length(features2) - locs + 1
  dn.table <- cbind(as.character(dn.markers1.orig), seq(1, n.markers), locs, ifelse(locs <= rep(n.markers, n.markers), rep("*", n.markers),  rep(" ", n.markers)))
  colnames(dn.table) <- c("Feature", "Rank in file1", "Rank in file2", "Overlap")
  print(noquote(dn.table))
  write.table(cbind(dn.table), file=output.file, quote=F, col.names = T, row.names = F, append = T, sep="\t")

}

  DISSECTOR_produce_OncoGPS_Map.v2 <- function(
       reference_dataset,
       projection_dataset,
       nodes                   = "ALL",
       node.nicknames          = NULL,
       zero_nodes_above        = NULL,
       feature.files,
       features,
       n.perm                  = 1000, 
       k.classes               = 10,    # Number of classes for clusering (0 indicates to read them from the k.classes.file)
       k.classes.file          = NULL,  # File with the states to be used in the OncoGPS
       k.classes.sample_column = NULL,  # Column with sample names             
       k.classes.class_column  = NULL,  # Column with class names             
       size.grid               = 150, 
       ncol                    = 20, 
       color.factor            = 1.0, 
       sample_names            = F,
       show_missing_samples    = T,
       description             = NULL,
       exclude_these_samples   = NULL,
       projection_method       = "sammon",  # "sammon" or "tsne"
       type_of_diagram         = "color.contours", 
       point.cex               = 2.5, 
       kernel.width            = 0.20,
       contour.tone            = 5, 
       contour.levels          = 30,
       low.range.color         = 2,
       high.range.color        = 6,
       projection.set.norm     = "wrt_train",
       norm.thres              = 3,
       output.file,
       membership.file,
       OPM.objects.file,
       phen.table              = NULL,
       phenotypes              = NULL,
       output.features.file    = NULL,
       output_dist_matrix_file = NULL,
       produce.boxplots        = T,
       plot.dist.matrix        = F)
    {

   library(maptools)
   library(RColorBrewer)
   library(spatstat)

   set.seed(5209761)

   # Color map
 
   mycol <- vector(length=512, mode = "numeric")
   for (k in 1:256) mycol[k] <- rgb(255, k - 1, k - 1, maxColorValue=255)
   for (k in 257:512) mycol[k] <- rgb(511 - (k - 1), 511 - (k - 1), 255, maxColorValue=255)
   mycol <- rev(mycol)
   max.cont.color <- 511
   mycol <- c(mycol,
              "black",  # brewer.pal(9, "YlGn")[1],     # Missing feature color (light yellow)
              mycol[256 - 75],                          # Binary feature's 0's color (blue)
              mycol[256 + 220])                         # Binary feature's 1's color (red)
   cex.axis = 1

         categ.col <- c("lightgray", # zero color
                     "green",   # green
                     "blue",    # blue
                     "red",     # red
                     "purple", # purple
                     "#C6DA60", # green
                     "#AED4ED", # steel blue
                     "#FFE370", # orange                        
                     "#D6A3FC", # purple
                     "#FFE1DC", # clay
                     "#FAF2BE", # dusty yellow
                     "#F3C7F2", # pink
                     "#FD9B85", # coral                                                
                     "#F970F9", # violet
                     "#F0F442", # yellow
                     "#9DDDD6", # dusty green
                     "#FC8962", # red
                     "#9AC7EF", # sky blue
                     "#D9D9D9", # grey
                     "#7FFF00", # chartreuse
                     "#FFB90F") # goldenrod1
#                     "#6E8B3D", # darkolivegreen4
#                     "#8B8878", # cornsilk4
#                     "#F0A5AB", # dusty red                        
#                     "#7FFFD4") # aquamarine                     
   
      categ.col2 <- c(
                      brewer.pal(9, "Blues")[6],
                      brewer.pal(9, "Greens")[6],
                      brewer.pal(9, "Reds")[6],
                      brewer.pal(9, "Purples")[6],          
                     "#9DDDD6", # dusty green
                     "#F0A5AB", # dusty red
                     "#9AC7EF", # sky blue
                     "#D6A3FC", # purple
                     "#FFE1DC", # clay
                     "#FAF2BE", # dusty yellow
                     "#F3C7F2", # pink
                     "#C6FA60", # green
                     "#F970F9", # violet
                     "#FC8962", # red                     
                     "#F6E370", # orange
                     "#F0F442", # yellow
                     "#AED4ED", # steel blue
                     "#D9D9D9", # grey
                     "#FD9B85", # coral
                     "#7FFF00", # chartreuse
                     "#FFB90F", # goldenrod1
                     "#6E8B3D", # darkolivegreen4
                     "#8B8878", # cornsilk4
                     "#7FFFD4") # aquamarine                     

   binary.col <- c("lightgray", # zero color
                   "black")     # one color

     mycol.class <- matrix(0, nrow=ncol, ncol=ncol)

   
      colfunc <- colorRampPalette(c("white", brewer.pal(9, "Blues")[6])) # blue
      mycol.class[,1] <- colfunc(color.factor*ncol)[1:ncol]
      colfunc <- colorRampPalette(c("white", brewer.pal(9, "Greens")[6])) # green
      mycol.class[,2] <- colfunc(color.factor*ncol)[1:ncol]
      colfunc <- colorRampPalette(c("white", brewer.pal(9, "Reds")[6])) # red
      mycol.class[,3] <- colfunc(color.factor*ncol)[1:ncol]
      colfunc <- colorRampPalette(c("white", brewer.pal(9, "Purples")[6])) # purple
      mycol.class[,4] <- colfunc(color.factor*ncol)[1:ncol]
      colfunc <- colorRampPalette(c("white", "#2D6D66")) # dusty green
      mycol.class[,5] <- colfunc(color.factor*ncol)[1:ncol]
      colfunc <- colorRampPalette(c("white", "#90353B")) # dusty red
      mycol.class[,6] <- colfunc(color.factor*ncol)[1:ncol]
      colfunc <- colorRampPalette(c("white", "#2A577F")) # sky blue
      mycol.class[,7] <- colfunc(color.factor*ncol)[1:ncol]
      colfunc <- colorRampPalette(c("white", "#6633CC")) # purple
      mycol.class[,8] <- colfunc(color.factor*ncol)[1:ncol]
      colfunc <- colorRampPalette(c("white", "#8F716C")) # clay 
      mycol.class[,9] <- colfunc(color.factor*ncol)[1:ncol]
      colfunc <- colorRampPalette(c("white", "#9A924E")) # dusty yellow
      mycol.class[,10] <- colfunc(color.factor*ncol)[1:ncol]
      colfunc <- colorRampPalette(c("white", "#E377C2")) # pink
      mycol.class[,11] <- colfunc(color.factor*ncol)[1:ncol]
      colfunc <- colorRampPalette(c("white", "#569A00")) # green
      mycol.class[,12] <- colfunc(color.factor*ncol)[1:ncol]
      colfunc <- colorRampPalette(c("white", "#990099")) # violet
      mycol.class[,13] <- colfunc(color.factor*ncol)[1:ncol]
      colfunc <- colorRampPalette(c("white", "#CC2902")) # red
      mycol.class[,14] <- colfunc(color.factor*ncol)[1:ncol]
      colfunc <- colorRampPalette(c("white", "#E67300")) # orange
      mycol.class[,15] <- colfunc(color.factor*ncol)[1:ncol]
      colfunc <- colorRampPalette(c("white", "#F0E442")) # yellow
      mycol.class[,16] <- colfunc(color.factor*ncol)[1:ncol]
      colfunc <- colorRampPalette(c("white", "#9EC4DD")) # steel blue
      mycol.class[,17] <- colfunc(color.factor*ncol)[1:ncol]
      colfunc <- colorRampPalette(c("white", "#A9A9A9")) # grey
      mycol.class[,18] <- colfunc(color.factor*ncol)[1:ncol]
      colfunc <- colorRampPalette(c("white", "#CD5B45")) # coral
      mycol.class[,19] <- colfunc(color.factor*ncol)[1:ncol]
      colfunc <- colorRampPalette(c("white", "#7FFF00")) # chartreuse
      mycol.class[,20] <- colfunc(color.factor*ncol)[1:ncol]
   
#      colfunc <- colorRampPalette(c("white", "#FFB90F")) # goldenrod1
#      mycol.class[,17] <- colfunc(color.factor*ncol)[1:ncol]
#      colfunc <- colorRampPalette(c("white", "#6E8B3D")) # darkolivegreen4
#      mycol.class[,18] <- colfunc(color.factor*ncol)[1:ncol]
#      colfunc <- colorRampPalette(c("white", "#8B8878")) # cornsilk4
#      mycol.class[,19] <- colfunc(color.factor*ncol)[1:ncol]
#      colfunc <- colorRampPalette(c("white", "#7FFFD4")) # aquamarine
#      mycol.class[,20] <- colfunc(color.factor*ncol)[1:ncol]
   
   myncolors <- ncol

   pdf(file=output.file, height=8.5, width=11)
   dataset <- MSIG.Gct2Frame(filename = reference_dataset)
   m.1 <- data.matrix(dataset$ds)
   sample.names.1 <- colnames(m.1)
   Ns.1 <- ncol(m.1)
   print(paste("Total samples in input file:", Ns.1))

   # Filter samples with only the selected phenotypes 

   if (!is.null(exclude_these_samples)) {
      locs <- match(exclude_these_samples, colnames(m.1))
      locs <- locs[!is.na(locs)]
      print(paste("Excluding samples:", sample.names.1[locs]))
      m.1 <- m.1[, -locs]
      sample.names.1 <- colnames(m.1)
      Ns.1 <- ncol(m.1)
      print(paste("Total samples after exclusion:", Ns.1))
    }  
   
    if (!is.null(phen.table) & !is.null(phenotypes)) {
         samples.table <- read.delim(phen.table, header=T, row.names=1, sep="\t", skip=0)
         table.sample.names <- row.names(samples.table)
         print("Subselecting samples with phenotypes: ")
         print(phenotypes)
         overlap <- intersect(colnames(m.1), table.sample.names)
         locs1 <- match(overlap, table.sample.names)
         locs2 <- match(overlap, colnames(m.1))
         m.1 <- m.1[, locs2]
         sample.phen <- vector(length(locs1), mode="numeric")
         for (i in 1:length(locs1)) {
             sample.phen[i] <- 0
             for (j in 1:length(phenotypes)) {
                if (!is.na(samples.table[locs1[i], phenotypes[j]])) {
                    if (samples.table[locs1[i], phenotypes[j]] == 1) {
                              sample.phen[i] <- 1
                    }
                }
              }
         }
         m.1 <- m.1[, sample.phen == 1]
         sample.names.1 <- colnames(m.1)
         Ns.1 <- ncol(m.1) 
         print(paste("Matching phenotypes total number of samples:", ncol(m.1)))
         print(dim(m.1))
         print(sample.names.1[1:3])
   }

   if (point.cex == "auto") point.cex <- ifelse(Ns.1 < 10, 1.5, (1.5 - 10/990) + 1/990*Ns.1)

   if (nodes == "ALL") nodes <- row.names(m.1)
   if (is.null(node.nicknames)) node.nicknames <-  nodes

   H <- m.1[nodes,]

  if (!is.null(zero_nodes_above)) {
     for (j in 1:ncol(H)) {
        ind <- order(H[,j], decreasing=T)
        H[ind[seq(zero_nodes_above + 1, nrow(H))], j] <- 0.0
    }
  }
#---------------------------------------------------------------------------------------------
#
# Define states by clustering or read them from file

#########################################################
    print("Performing normalization")

    print(dim(H))
    flush.console()
    for (k in 1:nrow(H)) {
        row.mean <- mean(H[k,])
        row.sd <- sd(H[k,])
        H[k,] <- (H[k,] - row.mean)/row.sd
        for (j in 1:ncol(H)) {
           if (H[k, j] > 3)  H[k, j] <- norm.thres
           if (H[k, j] < -3) H[k, j] <- -norm.thres
       }
    }
    nodes.min <- apply(H, MARGIN=1, FUN=min)
    nodes.max <- apply(H, MARGIN=1, FUN=max)       
    for (j in 1:nrow(H)) H[j,] <- (H[j,] - nodes.min[j])/(nodes.max[j] - nodes.min[j])

    print(dim(H))   
    flush.console()   
#########################################################
    print(H[,1:10])
    flush.console()
   
   if (k.classes > 0) {
      H.1 <- H
#      row.min <- apply(H.1, MARGIN=1, FUN=min)
#      row.max <- apply(H.1, MARGIN=1, FUN=max)       
#      for (i in 1:nrow(H)) H.1[i,] <- (H.1[i,] - row.min[i])/(row.max[i] - row.min[i])

      print("Compute distance matrix")
      dist.matrix <- DISSECTOR_compute_assoc_or_dist.v1(input_matrix1 = t(H.1), input_matrix2 = t(H.1), object_type = "rows",
                                                       assoc_metric = "IC", distance = T)
      dist.matrix.out <- as.matrix(dist.matrix)
#      print(dim(dist.matrix.out))
      if (!is.null(output_dist_matrix_file)) {
         print("Saving distance matrix")          
         write.gct.2(gct.data.frame = dist.matrix.out, descs = row.names(dist.matrix), filename = output_dist_matrix_file)
      }

      print("Performing Clustering of matrix H")      
     flush.console()   
      
      HC <- hclust(dist.matrix, method="ward")
      cutree.model <- cutree(HC, k = k.classes, h = NULL)

      plot(HC)
      
      cutree.model <- paste("S", cutree.model, sep="")
      all.classes <- unique(cutree.model)      

      flush.console()
      
      print("Table of states membership: (from k.classes clustering)")
      print(table(cutree.model))

      if (plot.dist.matrix == T) {
         dist.matrix2 <- DISSECTOR_compute_assoc_or_dist.v1(input_matrix1 = dist.matrix,
                        input_matrix2 = dist.matrix, object_type = "columns", assoc_metric = "IC", distance = T)
         hc <- hclust(dist.matrix2, "ward")
         assoc.matrix.sorted <- dist.matrix[, hc$order]
         dist.matrix2 <- DISSECTOR_compute_assoc_or_dist.v1(input_matrix1 = dist.matrix, input_matrix2 = dist.matrix,
                              object_type = "rows", assoc_metric = "IC", distance = T)
       
         hc2 <- hclust(dist.matrix2, "ward")
         dist.matrix.sorted <- dist.matrix.sorted[hc2$order,]
 
         dist.matrix.sorted <- ceiling(ncolors * (dist.matrix.sorted + 1)/2)
         V <- apply(dist.matrix.sorted, MARGIN=2, FUN=rev)
         par(mar = c(3, 10, 9, 4))
         image(1:dim(V)[2], 1:dim(V)[1], t(V), main = "", zlim = c(0, ncolors), col=mycol,
             axes=FALSE, xlab= "", ylab="") 

         mtext("Distance Matrix", cex=1.3, side = 3, line = 7, outer=F)   
         mtext(file.name2, cex=1, side = 3, line = 5, outer=F)      
         mtext(file.name, cex=1, side = 2, line = 5, outer=F)
         cols <- "black"
         cols2 <- cols
         cex.rows <- 0.15 + 180/(nrow(V) * max(nchar(row.names(V))) + 200)
         cex.cols <-cex.rows
         mtext(row.names(V), at=1:nrow(V), side = 2, cex=cex.rows, col=rev(cols), line=0, las=1, font=2, family="")
         mtext(colnames(V), at=1:ncol(V), side = 3, cex=cex.cols, col=cols2, line=0, las=3, font=2, family="")

         # Legend

         par(mar = c(3, 25, 1, 5))
         leg.set <- seq(-1, 1, 0.01)
         image(1:length(leg.set), 1:1, as.matrix(leg.set), zlim=c(-1, 1), col=mycol, axes=FALSE,
               main="Association Metric IC", sub = "", xlab= "", ylab="",font=2, family="", mgp = c(0, 0, 0), cex.main=0.8)
         ticks <- seq(-1, 1, 0.25)
         tick.cols <- rep("black", 5)
         tick.lwd <- c(1,1,2,1,1)
         locs <- NULL
         for (k in 1:length(ticks)) locs <- c(locs, which.min(abs(ticks[k] - leg.set)))
       }
  } else if (k.classes == 0) {

   # Read states from class file (k.classes.file)

         print("Reading pre-defined states")      
         flush.console()   
      
         class.table <- read.delim(k.classes.file, header=T, row.names=NULL, sep="\t", skip=0)
         
         class.table.samples <- class.table[, k.classes.sample_column]
         class.table.classes <- as.character(class.table[, k.classes.class_column])

         print("Matching sample names")
         print(colnames(H)[1:3])
         flush.console()   

         locs <- match(colnames(H), class.table.samples)
         if (sum(is.na(locs) > 0)) {
             print("ERROR: samples mismatch against the ones in k.classes.file")
             print(locs)
             print(colnames(H)[is.na(locs)])
             flush.console()                         
             stop("STOP:ERROR: samples mismatch against the ones in k.classes.file ")
         }
         cutree.model <- class.table.classes[locs]
         all.classes <- unique(cutree.model)
         k.classes <- length(all.classes)

         print(cutree.model[1:10])

         print("Table of states membership: (from k.classes file)")
         print(table(cutree.model))
         flush.console()            
  } else {
      stop(paste("ERROR: Undefined number of classes:", k.classes))
  }

#  Make heatmap of H matrix

   print("Making heatmap of H matrix")      
   flush.console()   

   H3 <- H
   cutoff <- 2
   for (i in 1:nrow(H3)) {
      x <- H3[i,]
      locs.non.na <- !is.na(x)
      x.nonzero <- x[locs.non.na]
      x.nonzero2 <- (x.nonzero - mean(x.nonzero))/sd(x.nonzero)         
      x.nonzero2[x.nonzero2 > cutoff] <- cutoff
      x.nonzero2[x.nonzero2 < - cutoff] <- - cutoff      
      s <- strsplit(row.names(H3)[i], "_")[[1]]
      suffix <- s[length(s)]
      if (suffix == "MUT" | suffix == "AMP" | suffix == "DEL" | suffix == "AMP_2" | suffix == "AMP_3" | suffix == "DEL_2" | suffix == "DEL_3" |
          suffix == "all" | length(table(x.nonzero)) == 2) {  # Binary feature
         H3[i,locs.non.na] <- x.nonzero + max.cont.color + 2   # binary feature colors
       } else {
         H3[i, locs.non.na] <- x.nonzero2
         H3[i, locs.non.na] <- ceiling(max.cont.color * (H3[i,locs.non.na] + cutoff)/(2*cutoff))
         H3[i, locs.non.na] <- ifelse (H3[i, locs.non.na] > max.cont.color, max.cont.color, H3[i, locs.non.na])
       }
      H3[i, is.na(x)] <- max.cont.color + 1 # missing feature color 
    }

   column.class <- match(cutree.model, all.classes)
   ind <- order(column.class, decreasing=F)
   column.class <- column.class[ind]
   H3 <- H3[, ind]
   all.column.classes <- unique(column.class)

   V4 <- apply(H3, MARGIN=2, FUN=rev)
   lower.space <-  ceiling(4 + 100/nrow(H))
   par(mar = c(lower.space, 16, 2, 6))
   image(1:ncol(V4), 1:nrow(V4), t(V4), zlim = c(0, max.cont.color + 3), col=mycol, axes=FALSE, main="",
         sub = "", xlab= "", ylab="", cex.main=0.8)
   cex.rows <- 0.20 + 200/(nrow(V4) * max(nchar(row.names(V4))) + 200)   
   axis(2, at=1:nrow(V4), labels=row.names(V4), adj= 0.5, tick=FALSE, las = 1, cex.axis=cex.rows, font.axis=1, line=-1)
   cex.cols <- 0.20 + 200/(ncol(V4) * max(nchar(colnames(V4))) + 200)   
   cols.V4 <- categ.col2[match(column.class, all.column.classes)]
   cex.cols <- 0.20 + 200/(ncol(V4) * max(nchar(colnames(V4))) + 200)
   mtext(colnames(V4), at=1:ncol(V4), side = 1, cex=cex.cols, col=cols.V4, line=0, las=3, font=2, family="")

   print("Making heatmap of H matrix")      
   flush.console()   

#---------------------------------------------------------------------------------------------
# Save states variables

   x2 <- cbind(t(H), cutree.model)

#   print(x2)

   states <- matrix(0, nrow=k.classes, ncol=ncol(H), dimnames=list(all.classes, colnames(H)))
   for (k in all.classes) {
      states[k, cutree.model == k] <- 1
   }

   # Make logistic predictive model for each state

    print("Making logistic predictive model for each state")
    flush.console()
   
    library(e1071)
    print("H matrix in training phase:")
    print(H[, 1:3])
    svm.mod <- svm(x = t(H), y = cutree.model, type = "C-classification")
    predicted.state <- predict(svm.mod, newdata = t(H))

    print("Training confussion matrix")
    print(table(predicted.state, cutree.model))
      
   col <- categ.col2[match(cutree.model, all.classes)]
   
   x2[, "cutree.model"] <- cutree.model
   states.names <- all.classes

   print("Saving state information")      
   flush.console()   
   
   all.features <- t(x2)
   all.features <- rbind(all.features, states, col)
   nodes2 <- paste("C", seq(1, length(nodes)), "_", nodes, sep = "")
   all.features.names <- c(nodes2, "states", states.names, "color")
   all.features.descs <- c(nodes2, "states", states.names, "color")
   row.names(all.features) <- all.features.names

   col.names <- paste(row.names(all.features), collapse = "\t")
   col.names <- paste("SAMPLE", col.names, sep= "\t")
   write(noquote(col.names), file = membership.file, append = F, ncolumns = length(col.names))
   write.table(t(all.features), file=membership.file, quote=F, col.names = F, row.names = T, append = T, sep="\t")

   # Define centroids

   centroids <- matrix(0, nrow=nrow(H), ncol=k.classes, dimnames = list(nodes, all.classes))
   for (i in nodes) {
      for (j in all.classes) {
           centroids[i, j] <- median(H[i, states[j,] == 1])
      }
   }   

#-------------
   print("Computing node and simplex statistics")      
   flush.console()   

   top_3_nodes <- matrix(NA, nrow=3, ncol=ncol(centroids), dimnames = list(c("T1", "T2", "T3"), all.classes))
   selected_nodes <- match(nodes, row.names(H))
   for (j in all.classes) {
      top_3_nodes[,j] <- order(centroids[,j], decreasing=T)[1:3]
   }
   simplex <- rep(NA, ncol(centroids))
   for (j in 1:k.classes) {
      simplex[j] <- paste(top_3_nodes[,j], collapse="_")
   }
   print(sort(table(simplex)))

#------------------------------------------
# Project rows 

   print("Projecting rows")      
   flush.console()   

   if (length(nodes) > 3) {

      if (projection_method == "sammon") {
     
         library(rgr)
         proj <- gx.2dproj(H, proc = "sam", ifilr = FALSE, log = FALSE, rsnd = FALSE, snd = FALSE,   # proc= sam or iso
	                   range = FALSE, main = "", setseed = FALSE, row.omits = NULL)
         row.objects <- cbind(proj$x, proj$y)
         row.objects <- (row.objects - min(row.objects))/(max(row.objects) - min(row.objects))
     } else if (projection_method == "tsne") {
         library(Rtsne)
         set.seed(971268) 
         tsne_out <- Rtsne(H, perplexity=2, theta=0.5, pca=F) # Run TSNE
         row.objects <- tsne_out$Y
         row.objects <- (row.objects - min(row.objects))/(max(row.objects) - min(row.objects))
     } else {
         stop("unknon projection method")
     }
     print(paste("Projection method:", projection_method))
     print(row.objects[1:3,])
     flush.console()   

### Manual setings
#      row.objects <- matrix(c(-0.5, sqrt(3)/2,  # node 1: C6
#                              0,    0,       # node 2: C3
#                             0.5, sqrt(3)/2,  # node 3: C7
#                              1,    0),      # node 4: C8
#                             nrow=4, ncol=2, byrow=T)

     # Define simplexes using delaunay triangulation

   print("Defining simplexes using delaunay triangulation")      
   flush.console()   

     X <- ppp(row.objects[,1], row.objects[,2], range(row.objects[,1]), range(row.objects[,2]))
     X2 <- delaunay(X)
     X3 <- tiles(X2)
     triangles.matrix <- matrix(NA, nrow=length(X3), ncol=3)
     for (tri in 1:length(X3)) {
        X4 <- unlist(X3[[tri]])
        node1 <- c(X4["bdry.x1"], X4["bdry.y1"])
        node2 <- c(X4["bdry.x2"], X4["bdry.y2"])
        node3 <- c(X4["bdry.x3"], X4["bdry.y3"])            

        for (i in 1:nrow(row.objects)) { 
           if (sum(node1 == row.objects[i,]) == 2) node.iden1 <- i
           if (sum(node2 == row.objects[i,]) == 2) node.iden2 <- i
           if (sum(node3 == row.objects[i,]) == 2) node.iden3 <- i
        }
        triangles.matrix[tri,] <- c(node.iden1, node.iden2, node.iden3)
     }
     triangles <- NULL
     for (tri in 1:length(X3)) {
        triangles <- c(triangles, list(triangles.matrix[tri,]))
     }
     w <- convexhull.xy(X)

### Manual settings
#    triangles <- list(c(1, 2, 3), c(2, 3, 4))
      
   } else { # one triangle
    triangles <- list(c(1, 2, 3))
    row.objects <- matrix(c(  0,    0,       # node 1
                            0.5, sqrt(3)/2,  # node 2
                              1,    0),      # node 3
                            nrow=3, ncol=2, byrow=T)
    X <- ppp(row.objects[,1], row.objects[,2], range(row.objects[,1]), range(row.objects[,2]))
    w <- convexhull.xy(X)    
   }

    tri.weig <- matrix(0, nrow=ncol(H), ncol=length(triangles))
    tri.member <- rep(0, ncol(H))

    # Assign samples to triangles

   print("Assign samples to triangles")
   flush.console()   

    for (i in 1:ncol(H)) {
       for (tri in 1:length(triangles)) {
          tri.weig[i, tri] <- sum(H[triangles[[tri]], i])
       }
       tri.member[i] <- which.max(tri.weig[i,])
   }
   xp <- yp <- xp.local <- yp.local <- rep(0, ncol(H))

   P <- c(0, 0)
   Q <- c(1, 0)
   R <- c(1/2, sqrt(3)/2)
   Tran <- rbind(c(P - R, 0), c(Q - R, 0), c(R, 1))

#    nodes.min <- apply(H, MARGIN=1, FUN=min)
#    nodes.max <- apply(H, MARGIN=1, FUN=max)       
#    for (j in 1:nrow(H)) H[j,] <- (H[j,] - nodes.min[j])/(nodes.max[j] - nodes.min[j])      

   print("Computing Sample locations on OncoGPS")   
   flush.console()   
                       
    for (i in 1:ncol(H)) {
      tri <- tri.member[i]
      vals <-H[triangles[[tri]], i]
      vals <- vals/sum(vals)
      xp.local[i] <- vals[2] + vals[3]/2
      yp.local[i] <- vals[3] * sqrt(3)/2
      if (i < 5) print(paste(i, xp.local[i], yp.local[i]))

      # Affine transformation

      P_p <- row.objects[triangles[[tri]][1], ]
      Q_p <- row.objects[triangles[[tri]][2], ]
      R_p <- row.objects[triangles[[tri]][3], ]      

      T_p <- rbind(c(P_p - R_p, 0), c(Q_p - R_p, 0), c(R_p, 1))
      U <-  ginv(Tran) %*% T_p

      FT <- (c(xp.local[i], yp.local[i], 1) %*%  ginv(Tran)) %*% T_p
      xp[i] <- FT[1]
      yp[i] <- FT[2]

      if (i < 5) print(paste(i, xp[i], yp[i]))
      flush.console()   
      
 }

   print("Computing OncoGPS layout")   
   flush.console()   

   nf <- layout(matrix(1, 1, 1, byrow=T), 1, 1, FALSE)

      x.min <- min(c(xp, row.objects[,1]))
      x.max <- max(c(xp, row.objects[,1]))
      x.len <- x.max - x.min
      x.min <- x.min - x.len/10
      x.max <- x.max + x.len/10
      y.min <- min(c(yp, row.objects[,2]))
      y.max <- max(c(yp, row.objects[,2]))
      y.len <- y.max - y.min
      y.min <- y.min - y.len/9
      y.max <- y.max + y.len/10
   lims <- c(x.min, x.max, y.min, y.max)
   print("lims")
   print(lims)   
   flush.console()      
   kernel.width <- kernel.width*(max(lims) - min(lims))
#   size.grid <- ceiling(size.grid*(max(lims) - min(lims)))
   print("kernel.width:")
   print(kernel.width)
   print("size.grid:")
   print(size.grid)
   
#   print("cutree.model")
#   print(cutree.model)   

   print("Compute state densities")   
   flush.console()   

   Pxy <- array(0, dim= c(size.grid, size.grid, k.classes), dimnames=list(NULL, NULL, all.classes))

   for (k in all.classes) {

       print(paste("k:", k))
       class.size <-  sum(cutree.model == k)
       if (class.size == 0) stop(paste("ERROR: state ", k, " has no samples"))
       print(paste("class size:", sum(cutree.model == k)))
       flush.console()          
       x.sub <- xp[cutree.model == k]
       y.sub <- yp[cutree.model == k]
       kde2d.xy <- kde2d(x.sub, y.sub, n = size.grid, h = c(kernel.width, kernel.width), lims=lims)
       x.coor <-  kde2d.xy$x
       y.coor <-  kde2d.xy$y
       Pxy[,, k] <- kde2d.xy$z
   }

   print("Compute winning state density per grid point")   
   flush.console()   
   winning.class <- matrix(NA, nrow=size.grid, ncol=size.grid)
   final.Pxy <- matrix(0, nrow=size.grid, ncol=size.grid)                       
   for (i in 1:size.grid) {
       for (j in 1:size.grid) {
           winning.class[i, j] <- dimnames(Pxy)[[3]][which.max(Pxy[i, j, ])]
           final.Pxy[i, j] <- Pxy[i, j, winning.class[i, j]]
       }
   }
   final.Pxy <- (final.Pxy - min(final.Pxy))/(max(final.Pxy) - min(final.Pxy))

  # Make mask for outside of the convex hull

   print("Make mask for outside of the convex hull")
   flush.console()   

      mask <- matrix(0, nrow=size.grid, ncol=size.grid)
      for (i in 1:size.grid) {
         for (j in 1:size.grid) {
            x.p <- x.coor[i]
            y.p <- y.coor[j]
            if (inside.owin(x.p, y.p, w)) mask[i, j] <- 1
         }
      }

   print("Making layout plots")
   flush.console()   

   for (k in 1:3)  { # make plot 3 times (one with just domains, one with domains and points and the last one with samples names)
      par(mar=c(2,3,1,3))

      plot(c(0,0), c(0,0), type="n", xlim=c(x.min, x.max), ylim=c(y.min , 1.1*y.max), bty="n", axes=FALSE, xlab="", ylab="")         
      for (i in 1:size.grid) {
         for (j in 1:size.grid) {
            x.p <- x.coor[i]
            y.p <- y.coor[j]
            col <- mycol.class[ceiling((myncolors - 1) * final.Pxy[i, j] + 1), match(winning.class[i, j], all.classes)]
            points(x.p, y.p, col=col, pch=15, cex=1)
         }
      }
      levels <- seq(0, 1, 1/contour.levels)
      lc <- contourLines(x=x.coor, y=y.coor, z=final.Pxy, levels=levels)
#      for (i in 1:length(lc)) points(lc[[i]]$x, lc[[i]]$y, type="l", col=brewer.pal(9, "Greys")[contour.tone], lwd=1)
      for (i in 1:length(lc)) points(lc[[i]]$x, lc[[i]]$y, type="l", col="darkblue", lwd=1)      
      
      for (i in 1:size.grid) {
         for (j in 1:size.grid) {
            x.p <- x.coor[i]
            y.p <- y.coor[j]
            if (mask[i,j] == 0) {
               points(x.p, y.p, col="white", pch=15, cex=1)
            }
         }
      }
      
         text(x.min + 0.05*x.len, 1.08*y.max, "OncoGenic Positional System (Onco-GPS) Map",
           cex= 1.35, family="Times", fontface="italic", pos=4, font=4, col="darkblue")                 
         if (k > 1) {         
            text(x.min + 0.05*x.len, 1.02*y.max, paste("Basic Layout: Samples (", length(xp),
                                       ") and States (", k.classes, ")", sep=""), cex = 1.1, font=2, family="", pos=4, col="darkred")
        } else {
            text(x.min + 0.05*x.len, 1.02*y.max, "Basic Layout", cex = 1.1, font=2, family="", pos=4, col="darkred")
        }
        text(x.min, y.min, description, cex = 1, font=2, family="", pos=4, col="darkblue")
         
            for (tri in 1:length(triangles)) {
              triangle.nodes.x  <- c(row.objects[triangles[[tri]][1], 1], row.objects[triangles[[tri]][2], 1], row.objects[triangles[[tri]][3], 1],
                                     row.objects[triangles[[tri]][1], 1])
              triangle.nodes.y  <- c(row.objects[triangles[[tri]][1], 2], row.objects[triangles[[tri]][2], 2], row.objects[triangles[[tri]][3], 2],
                                     row.objects[triangles[[tri]][1], 2])
              points(triangle.nodes.x, triangle.nodes.y, type="l", col="black", lwd=1, cex=1.25)              
            }
             
         for (i in 1:nrow(row.objects)) {
            pos <- ifelse(row.objects[i,2] < 0.5, 1, 3)
            text(row.objects[i,1], row.objects[i,2], labels = node.nicknames[i], col="darkblue", cex=1.35, pos=pos, offset=1)        
         }
         points(row.objects[,1], row.objects[,2], col="darkblue", bg="darkblue", pch=21, cex=point.cex)
      
         # Onco-GPS Map
         if (k > 1) {
             for (i in 1:length(xp)) {
               col <- categ.col2[match(cutree.model[i], all.classes)]
               points(xp[i], yp[i], col="black", bg=col, pch=21, cex=point.cex)
             }

              # Add legend to show states

#            leg.txt <- states.names
            leg.txt <- all.classes
            pch.vec <- rep(21, length(leg.txt))
            col <- unique(categ.col2[match(cutree.model, all.classes)])
                        
            legend(x.max - 0.05*x.len, y.max, legend=leg.txt, bty="n", xjust=0, yjust= 1, pch = pch.vec, title="States",   
                   pt.bg = col, col = "black", cex = 1, pt.cex = 1.5)

            if (k == 3) pointLabel(xp, yp, labels=colnames(m.1), cex=0.85, col="darkgreen")

         }
  }

#--------------------------------------------------
  # Plot feature set on top of Onco-GPS Map

   print("Processing feature set")   
   flush.console()   

   
  save(description, Ns.1, nodes, node.nicknames, sample.names.1, k.classes, cutree.model, size.grid, xp, yp, x.coor, y.coor, row.objects, mycol, categ.col, categ.col2,  X, mask, n.perm, binary.col, max.cont.color, mycol.class, myncolors, final.Pxy, winning.class, file = OPM.objects.file)

      dataset.1.projection <- MSIG.Gct2Frame(filename = projection_dataset)
      m.1.projection <- data.matrix(dataset.1.projection$ds)
      dim(m.1.projection)
      Ns.1.projection <- ncol(m.1.projection)
      print(paste("Total samples in projection file:", Ns.1.projection))
      sample.names.1.projection <- colnames(m.1.projection) <- dataset.1.projection$names

      # check if all the nodes can be mapped

      locs <- match(nodes, row.names(m.1.projection))
      H.projection <- m.1.projection[locs,]
   
      # Normalization options

      print("H.projecting matrix before norm:")
      print(H.projection)
      flush.console()   
   
      if (projection.set.norm == "wrt_train") {
         for (i in 1:nrow(H.projection)) H.projection[i,] <- (H.projection[i,] - nodes.min[i])/(nodes.max[i] - nodes.min[i])          
      } else if (projection.set.norm == "wrt_projection") {
#         for (i in 1:nrow(H.projection)) H.projection[i,] <- (H.projection[i,] - min(H.projection[i,]))/(max(H.projection[i,]) - min(H.projection[i,]))

          for (i in 1:nrow(H.projection)) {
             row.mean <- mean(H.projection[i,])
             row.sd <- sd(H.projection[i,])
             print(paste("row:", i))
             print(paste("row.mean:", row.mean))
             print(paste("row.sd:", row.sd))             
             H.projection[i,] <- (H.projection[i,] - row.mean)/row.sd
             
             for (j in 1:ncol(H.projection)) {
                if (H.projection[i,j] >  3) H.projection[i,j] <- 3
                if (H.projection[i,j] < -3) H.projection[i,j] <- -3
             }
#             print(H.projection[i,])
           }
           print(H.projection)
           nodes.min <- apply(H.projection, MARGIN=1, FUN=min)
           nodes.max <- apply(H.projection, MARGIN=1, FUN=max)
           print(paste("nodes.min:", nodes.min))
           print(paste("nodes.max:", nodes.max))          
           for (j in 1:nrow(H.projection)) H.projection[j,] <- (H.projection[j,] - nodes.min[j])/(nodes.max[j] - nodes.min[j])
      }

      print(dim(H.projection))
#      print("H projection:")
#      print(H.projection)

      print("H.projecting matrix after norm, in test mode:")
      flush.console()      
      print(H.projection[, 1:3])

      predicted.state.test <- predict(svm.mod, newdata = t(H.projection))
      print("predicted state test")
      print(predicted.state.test[1:10])
      print(table(predicted.state.test))
      flush.console()   
      
# compute triangle membership and xp, yp 2D coordinates

    tri.weig.projection <- matrix(0, nrow=ncol(H.projection), ncol=length(triangles))
    tri.member.projection <- rep(0, ncol(H.projection))

    # Assign samples to triangles

    for (i in 1:ncol(H.projection)) {
       for (tri in 1:length(triangles)) {
          tri.weig.projection[i, tri] <- sum(H.projection[triangles[[tri]], i])
       }
       tri.member.projection[i] <- which.max(tri.weig.projection[i,])
   }
   xp.projection <- yp.projection <- xp.local.projection <- yp.local.projection <- rep(0, ncol(H.projection))

   P <- c(0, 0)
   Q <- c(1, 0)
   R <- c(1/2, sqrt(3)/2)
   Tran <- rbind(c(P - R, 0), c(Q - R, 0), c(R, 1))

    for (i in 1:ncol(H.projection)) {
      tri <- tri.member.projection[i]
      vals <-H.projection[triangles[[tri]], i]
      vals <- vals/sum(vals)
      xp.local.projection[i] <- vals[2] + vals[3]/2
      yp.local.projection[i] <- vals[3] * sqrt(3)/2
      if (i < 5) print(paste(i, xp.local.projection[i], yp.local.projection[i]))

      # Affine transformation

      P_p <- row.objects[triangles[[tri]][1], ]
      Q_p <- row.objects[triangles[[tri]][2], ]
      R_p <- row.objects[triangles[[tri]][3], ]      

      T_p <- rbind(c(P_p - R_p, 0), c(Q_p - R_p, 0), c(R_p, 1))
      U <-  ginv(Tran) %*% T_p

      FT <- (c(xp.local.projection[i], yp.local.projection[i], 1) %*%  ginv(Tran)) %*% T_p
      xp.projection[i] <- FT[1]
      yp.projection[i] <- FT[2]
 }
  flush.console()   

  for (f in 1:length(feature.files)) {   # loop over feature types
      print(paste("Processing feature file:", feature.files[[f]][1]))
      dataset.2 <- MSIG.Gct2Frame(filename = feature.files[[f]][1])
      m.2 <- data.matrix(dataset.2$ds)
      dim(m.2)
      row.names(m.2) <- dataset.2$row.names
      sample.names.2 <- colnames(m.2) <- dataset.2$names
      if (feature.files[[f]][2] != "ALL") {
          overlap <- intersect(sample.names.2, feature.files[[f]][2:length(feature.files[[f]])])
          locs0 <- match(overlap, sample.names.2)
          m.2 <- m.2[, locs0]
      }
      sample.names.2 <- colnames(m.2) 
      Ns.2 <- ncol(m.2)  
      locs <- match(sample.names.1.projection, sample.names.2)
      locs1 <- seq(1, length(locs))[!is.na(locs)]
      locs2 <- locs[!is.na(locs)]
      m <- matrix(NA, nrow=nrow(m.2), ncol=Ns.1.projection, dimnames=list(row.names(m.2), sample.names.1.projection))
      m[, locs1] <- m.2[, locs2]
      m.2 <- m

      print(paste("feature file overlap with projection dataset:", ncol(m.2)))

      if (length(features[[f]]) == 1 & is.numeric(features[[f]])) {    # search for top matching features from that feature file 
         print(paste("Search for top features for feature file:", feature.files[[f]][1]))
         print(paste("samples:", feature.files[[f]][2]))         
         feat.IC <- rep(0, nrow(m.2))
         for (h in 1:nrow(m.2)) feat.IC[h] <- abs(IC.v1(m.2[h,], match(predicted.state.test, all.classes)))
         ind <- order(feat.IC, decreasing=T)
         feat.IC <- feat.IC[ind]
         feat.IC.names <- row.names(m.2)[ind]
         features[[f]] <- feat.IC.names[1:features[[f]]]
         print("Top matching features:")
         print(features[[f]])
      }
      flush.console()
      
     if (length(features[[f]]) == 1 & features[[f]] == "ALL") {    # display all features from that feature file 
        features[[f]] <- row.names(m.2)
     }

     for (feat.n in 1:length(features[[f]])) { 

        len <- length(unlist(features[[f]][feat.n]))         
        if (len > 1) {   # is this a combined feature?
            comb.feature <- T
            f.set <- unlist(features[[f]][feat.n])
            f.type <- f.set[length(f.set)]
            f.set <- f.set[seq(1, length(f.set) - 1)]
            print(paste("combined feature:", f.set))
            print(paste("combined type:", f.type))
            feature.name <- paste(f.set, collapse=" ")
            print(paste("feature.name:", feature.name))
            if (f.type == "comb.binary") {
               feature.vec <- apply(m.2[f.set,], MARGIN=2, FUN=max)
            } else {     # comb.categ
               feature.vec0 <- apply(m.2[f.set,], MARGIN=2, FUN=paste, collapse="")
               print("feature.vec0:")
               print(feature.vec0[1:10])               

               feature.vec <- strtoi(feature.vec0, base = 2L)
               print("feature.vec:")
               print(feature.vec)
               ind <- order(feature.vec, decreasing=F)
               u.vals <- unique(feature.vec[ind])
               feature.vec <- match(feature.vec, u.vals) - 1
               print("feature.vec (final):")
               print(feature.vec)

               f.names <- rep("other", ncol(m.2))
               for (h in 1:ncol(m.2)) {
                  for (l in 1:length(f.set)) {
                      if (m.2[f.set[l], h] == 1) f.names[h] <- f.set[l]
                   }
               }
               f.names <- f.names[ind]
               f.names <- unique(f.names)
               print("f.names:")
               print(f.names)
            }
         } else {
            comb.feature <- F
            f.type <- "single"                         
            feature.name <- unlist(features[[f]][feat.n])
            print(paste("      Feature:", feature.name))
            if (is.na(match(feature.name, row.names(m.2)))) {
                print(paste("Feature not found:", feature.name))
                next
            }
            feature.vec <- m.2[feature.name,]
            f.names <- unique(feature.vec)
         }
        flush.console()
        
        # Add feature to all features array

        print("adding features... to all.features array")
        print(dim(all.features))
        print(length(feature.vec))
        
        all.features <- rbind(all.features, feature.vec)
        all.features.names <- c(all.features.names, feature.name)
        all.features.descs <- c(all.features.descs, names(features)[[f]])        

#         unique.feature.vals <- unique(sort(feature.vec))
         unique.feature.vals <- unique(sort(feature.vec))
         unique.feature.vals <-  unique.feature.vals[!is.na(unique.feature.vals)]
#         print(paste(" unique.feature.vals:",  unique.feature.vals))
        
         non.NA.vals <- sum(!is.na(feature.vec))
         n.vals <- length(unique.feature.vals)
         if (n.vals >= 3*non.NA.vals/4) {    # Continuous value color map
            feature.vals.type <- "continuous"
            cutoff <- 2
            x <- feature.vec
            locs.non.na <- !is.na(x)
            x.nonzero <- x[locs.non.na]
            x.nonzero <- (x.nonzero - mean(x.nonzero))/sd(x.nonzero)         
            x.nonzero[x.nonzero > cutoff] <- cutoff
            x.nonzero[x.nonzero < - cutoff] <- - cutoff      
            feature.vec[locs.non.na] <- x.nonzero
            feature.vec2 <- feature.vec
            feature.vec[locs.non.na] <- ceiling((max.cont.color - 2) * (feature.vec[locs.non.na] + cutoff)/(cutoff*2)) + 1
            feature.vec[is.na(x)] <- max.cont.color
            col.points <- mycol[feature.vec]
         } else if (n.vals > 2 & n.vals < 3*non.NA.vals/4 | (comb.feature == T) & (f.type == "comb.categ")) {   # Categorical color map
            feature.vec2 <- feature.vec            
            feature.vec[is.na(feature.vec)] <- max.cont.color
            feature.vals.type <- "categorical"             
            col.points <- categ.col[match(feature.vec, unique.feature.vals)]
         } else if (n.vals == 2 | (comb.feature == T) & (f.type == "comb.binary")) {   # Categorical color map
            feature.vec2 <- feature.vec            
            feature.vec[is.na(feature.vec)] <- max.cont.color
            feature.vals.type <- "binary"
            col.points <- binary.col[match(feature.vec, unique.feature.vals)]
         } else if (n.vals == 1) {
            feature.vec2 <- feature.vec            
            feature.vec[is.na(feature.vec)] <- max.cont.color
            feature.vals.type <- "binary"
            col.points <- binary.col[match(feature.vec, unique.feature.vals) + 1]
         } else {
            feature.vec2 <- feature.vec            
            feature.vec[is.na(feature.vec)] <- max.cont.color
            feature.vals.type <- "binary"
            col.points <- binary.col[match(feature.vec, unique.feature.vals)]
         }

         num.classes <- match(predicted.state.test, all.classes)        
         IC <- IC.v1(feature.vec, num.classes)
         null.IC <- vector(length=n.perm, mode="numeric")
         for (h in 1:n.perm) null.IC[h] <- IC.v1(feature.vec, sample(num.classes))
         if (IC >= 0) {
             p.val <- sum(null.IC >= IC)/n.perm
         } else {
             p.val <- sum(null.IC <= IC)/n.perm
         }
         if (p.val == 0) {
             p.val <- paste("<", signif(1/n.perm, 3))
        } else {
             p.val <- signif(p.val, 3)
         }
#        IC <- 0
#        p.val <- 0

  # Make plot

      par(mar=c(2,3,1,3))        
      plot(c(0,0), c(0,0), type="n", xlim=c(x.min, x.max), ylim=c(y.min - 0.065*y.len, 1.12*y.max), bty="n", axes=FALSE, xlab="", ylab="")                 
      for (i in 1:size.grid) {
         for (j in 1:size.grid) {
            x.p <- x.coor[i]
            y.p <- y.coor[j]
            col <- mycol.class[ceiling((myncolors - 1) * final.Pxy[i, j] + 1), match(winning.class[i, j], all.classes)]
            points(x.p, y.p, col=col, pch=15, cex=1)
         }
      }
      levels <- seq(0, 1, 1/contour.levels)
      lc <- contourLines(x=x.coor, y=y.coor, z=final.Pxy, levels=levels)
#      for (i in 1:length(lc)) points(lc[[i]]$x, lc[[i]]$y, type="l", col=brewer.pal(9, "Greys")[contour.tone], lwd=1)
      for (i in 1:length(lc)) points(lc[[i]]$x, lc[[i]]$y, type="l", col="darkblue", lwd=1)        

      for (i in 1:size.grid) {
         for (j in 1:size.grid) {
            x.p <- x.coor[i]
            y.p <- y.coor[j]
            if (mask[i,j] == 0) {
               points(x.p, y.p, col="white", pch=15, cex=1)
            }
         }
      }
            for (tri in 1:length(triangles)) {
              triangle.nodes.x  <- c(row.objects[triangles[[tri]][1], 1], row.objects[triangles[[tri]][2], 1], row.objects[triangles[[tri]][3], 1],
                                     row.objects[triangles[[tri]][1], 1])
              triangle.nodes.y  <- c(row.objects[triangles[[tri]][1], 2], row.objects[triangles[[tri]][2], 2], row.objects[triangles[[tri]][3], 2],
                                     row.objects[triangles[[tri]][1], 2])
              points(triangle.nodes.x, triangle.nodes.y, type="l", col="black", lwd=1, cex=1.25)              
            }

         for (i in 1:nrow(row.objects)) {
            pos <- ifelse(row.objects[i,2] < 0.5, 1, 3)
            text(row.objects[i,1], row.objects[i,2], labels = node.nicknames[i], col="darkblue", cex=1.35, pos=pos, offset=1)        
         }
         points(row.objects[,1], row.objects[,2], col="darkblue", bg="darkblue", pch=21, cex=point.cex)

         # Onco-GPS Map

         feature.name.short <- substr(feature.name, 1, 23)
         if (nchar(feature.name) > 25) feature.name.short <- paste(feature.name.short, "...", sep="")
#         text(x.min, 1.1*y.max + 0.04*y.len, description, cex = 1, font=2, family="", pos=4, col="darkgrey")
         text(x.min, 1.1*y.max + 0.03*y.len, paste(feature.name.short, " (",  names(features)[[f]], ")"), cex = 1.3, font=2, family="", pos=4, col="darkblue")
         text(x.min, 1.1*y.max - 0.06*y.len, paste("IC:", signif(IC, 3), " p-val:", p.val), cex = 1.1, font=2, family="", pos=4, col="darkgreen")

         for (i in 1:length(xp.projection)) {   # Missing value
             if (feature.vec[i] == max.cont.color) {
                if (show_missing_samples  == T) points(xp.projection[i], yp.projection[i], col="white", pch=4, cex=0.2)
            } else { # Present value
                points(xp.projection[i], yp.projection[i], col="black", bg=col.points[i], pch=21, cex=point.cex)
                if (sample_names == T) {
                        pointLabel(xp.projection[i], yp.projection[i],
                            labels=colnames(m.1.projection)[i], cex=1.2, col="black")
                    }
            }
         }
#         if (sample_names == T) pointLabel(xp.projection, yp.projection, labels=colnames(m.1.projection), cex=0.85, col="darkgreen")

      # Legend

       locs <- !is.na(feature.vec2)
       feature.vec3 <- feature.vec2[locs]
       min.val <- signif(min(feature.vec3), 2)
       max.val <- signif(max(feature.vec3), 2)
       mid.val <- signif(min(feature.vec3) + 0.5*(max(feature.vec3) - min(feature.vec3)), 2)
 
         if (produce.boxplots == T) {
            # par(mar = c(1, 1, 1, 1))         
            predicted.state.test3 <- match(predicted.state.test[locs], all.classes)
            if (sd(feature.vec3) == 0) {
                feature.vec4 <- y.max*1.05 - 0.02*y.len + 0.5*y.len/6 + rep(0, length(feature.vec3))
            } else {
#                feature.vec4 <-  y.max*1.05 - 0.02*y.len +
                 feature.vec4 <-  y.max*1.05 - 0.06*y.len +                
                               (y.len/5.5)*(feature.vec3 - min(feature.vec3))/(max(feature.vec3) - min(feature.vec3))
            }
            classes <- sort(unique(predicted.state.test3))
            boxplot(feature.vec4 ~ predicted.state.test3, main="", boxwex = 0.04*5/k.classes,
                    at = x.max - 0.38*x.len + (x.len/2.75)*classes/k.classes, names = classes,
                    col = categ.col2[classes] , axes=F, xlab=NA, ylab=NA, add=T)
            
            points(c(x.max - 0.38*x.len, x.max - 0.38*x.len), c(y.max*1.05 - 0.02*y.len, y.max*1.05 - 0.02*y.len + y.len/7),
                   type="l", lwd=1, col="black")
            points(c(x.max - 0.39*x.len, x.max - 0.38*x.len), c(y.max*1.05 - 0.02*y.len, y.max*1.05 - 0.02*y.len),
                   type="l", lwd=1, col="black")
            points(c(x.max - 0.39*x.len, x.max - 0.38*x.len), c(y.max*1.05 - 0.02*y.len + 0.5*y.len/7, y.max*1.05 - 0.02*y.len + 0.5*y.len/7),
                   type="l", lwd=1, col="black")
            points(c(x.max - 0.39*x.len, x.max - 0.38*x.len), c(y.max*1.05 - 0.02*y.len + y.len/7, y.max*1.05 - 0.02*y.len + y.len/7),
                   type="l", lwd=1, col="black")

            text(x.max - 0.39*x.len, y.max*1.05 - 0.02*y.len, min.val, cex = 0.6, font=2, family="", pos=2, col="black")
            text(x.max - 0.39*x.len, y.max*1.05 - 0.02*y.len + 0.5*y.len/7, mid.val, cex = 0.6, font=2, family="", pos=2, col="black")
            text(x.max - 0.39*x.len, y.max*1.05 - 0.02*y.len + y.len/7, max.val, cex = 0.6, font=2, family="", pos=2, col="black")                 
        }

#      legend.x <- x.min + 0.05*x.len
      legend.x <- x.max - 0.2*x.len        
      legend.y <- y.max - 0.075*y.len

      if (feature.vals.type == "continuous") {
          
          for (k in 1:20) {
              points(legend.x + k*x.len/100, legend.y - 0.020*y.len, col=mycol[floor(k*512/20)], pch=15, cex=1)
              points(legend.x + k*x.len/100, legend.y - 0.030*y.len, col=mycol[floor(k*512/20)], pch=15, cex=1)
              points(legend.x + k*x.len/100, legend.y - 0.040*y.len, col=mycol[floor(k*512/20)], pch=15, cex=1)              
          }
          points(c(legend.x + x.len/100, legend.x + 20.5*x.len/100), c(legend.y - 0.045*y.len, legend.y - 0.045*y.len), type="l", lwd=1, col="black")
          points(c(legend.x + x.len/100, legend.x + x.len/100), c(legend.y - 0.045*y.len, legend.y - 0.05*y.len), type="l", lwd=1, col="black")
          points(c(legend.x + 10*x.len/100, legend.x + 10*x.len/100), c(legend.y - 0.045*y.len, legend.y - 0.05*y.len), type="l", lwd=1, col="black")
          points(c(legend.x + 20.5*x.len/100, legend.x + 20.5*x.len/100), c(legend.y - 0.045*y.len, legend.y - 0.05*y.len), type="l", lwd=1, col="black")
          
          text(legend.x + x.len/100, legend.y - 0.045*y.len, min.val, cex = 0.6, font=2, family="", pos=1, col="black")
          text(legend.x + 10*x.len/100, legend.y - 0.045*y.len, mid.val, cex = 0.6, font=2, family="", pos=1, col="black")
          text(legend.x + 20.5*x.len/100, legend.y - 0.045*y.len, max.val, cex = 0.6, font=2, family="", pos=1, col="black")                 
         
      } else if (feature.vals.type == "categorical") {
         leg.txt <- f.names # f.set
         pch.vec <- rep(21, length(leg.txt))

#         print("leg.txt:") 
#         print(leg.txt)         
#         print("pch.vec:") 
#         print(pch.vec)         
                        
         legend(x=legend.x, y=legend.y, legend=leg.txt, bty="n", xjust=0, yjust= 1, pch = pch.vec, title="",   
                pt.bg = categ.col[1:length(f.names)], col = "black", cex = 1, pt.cex = 2.25)
         
      } else if (feature.vals.type == "binary") {
            leg.txt <- c("Absent", "Present")
            legend(x=legend.x, y=legend.y, legend=leg.txt, bty="n", xjust=0, yjust= 1, pch = c(21, 21), title="",
                 pt.bg = c(binary.col[1], binary.col[2]), col = "black", cex = 1, pt.cex = 2.25)
        }
      text(x.min + 0.65*x.len, y.min - 0.02*y.len, "OncoGenic Positional System (Onco-GPS) Map",
           cex= 1, family="Times", fontface="italic", pos=1, font=4, col="darkblue")                 

      } # End loop over features
   flush.console()
      
   } # End loop over feature files

   if (!is.null(output.features.file)) {
      row.names(all.features) <- all.features.names
      ind <- order(all.features["states",], decreasing=F)
      all.features <- all.features[, ind]
      write.gct.2(gct.data.frame = all.features, descs = all.features.descs, filename = output.features.file)
  }

dev.off()
}

DISSECTOR_merge_signatures <- function(
      gene_sets_files,
      gene_sets,
      output_signature_name,
      output_file)
    {
        print("Selecting relevant genes from gene sets")

	max.G <- 0
	max.N <- 0
	for (gsdb in gene_sets_files) {
		GSDB <- Read.GeneSets.db(gsdb, thres.min = 2, thres.max = 2000, gene.names = NULL)
		max.G <- max(max.G, max(GSDB$size.G))
		max.N <- max.N +  GSDB$N.gs
	}
	N.gs <- 0
	gs <- matrix("null", nrow=max.N, ncol=max.G)
	gs.names <- vector(length=max.N, mode="character")
	gs.descs <- vector(length=max.N, mode="character")
	size.G <- vector(length=max.N, mode="numeric")
	start <- 1
	for (gsdb in gene_sets_files) {  # Read all the gene sets from gene set files
		GSDB <- Read.GeneSets.db(gsdb, thres.min = 2, thres.max = 2000, gene.names = NULL)
		N.gs <- GSDB$N.gs 
		gs.names[start:(start + N.gs - 1)] <- GSDB$gs.names
		gs.descs[start:(start + N.gs - 1)] <- GSDB$gs.desc
		size.G[start:(start + N.gs - 1)] <- GSDB$size.G
		gs[start:(start + N.gs - 1), 1:max(GSDB$size.G)] <- GSDB$gs[1:N.gs, 1:max(GSDB$size.G)]
		start <- start + N.gs
	}
	N.gs <- max.N
	
	# Select desired gene sets
	
	locs <- match(gene_sets, gs.names)
        print(rbind(gene_sets, locs))
	N.gs <- sum(!is.na(locs))
	if(N.gs > 1) { 
           gs <- gs[locs,]
	} else { 
           gs <- t(as.matrix(gs[locs,]))   # Force vector to matrix if only one gene set specified
        }
	gs.names <- gs.names[locs]
	gs.descs <- gs.descs[locs]
	size.G <- size.G[locs]

        genes <- NULL
       	for (gs.i in 1:N.gs) {
   	   gene.set <- gs[gs.i, 1:size.G[gs.i]]
           genes <- c(genes, gene.set)
         }
        print(paste("Number of selected genes:", length(genes)))
        genes <- unique(genes)
        print(paste("Number of unique selected genes:", length(genes)))

        # save signature in GMT file

       output.line <- paste(genes, collapse="\t")
       output.line <- paste(output_signature_name, output_signature_name,  output.line, sep="\t")
       write(noquote(output.line), file = output_file, append = F, ncolumns = length(genes)+2)
}    


DISSECTOR_produce_mutation_file.v1 <- function(

# This produces genes x samples GCT files with mutations entries for "All,
# "All_Nonsilent" and "variant class" and "protein changes" entries for
# "maf" formatted mutations files (e.g. TCGA's LUAD-TP.final_analysis_set.maf)
    
      maf.mut.input_file,
      gct.output.file,
      format_sample_names = "yes",   # Reformat (TCGA) sample names replacing "-" with"." and truncate to 12 characters
      variant.thres = 3,  # threshold in sample counts to define entries for variant classes (e.g. Missense_Mutation)
      change.thres = 3,  # threshold in sample counts to define entries for protein changes (e.g. p.S768I )
      genes_with_all_entries = NULL, # for this list of genes create entries for all protein changes (disregard change.threshold)
      exclude_flat_features  = F) # exclude flat features
    {
        
   ds <- read.delim(maf.mut.input_file, header=T, row.names = NULL, sep="\t", blank.lines.skip=T,
                    comment.char="", as.is=T)

   if (format_sample_names == "yes") {
      for (i in 1:nrow(ds)) {
          ds[i,"Tumor_Sample_Barcode"] <- substr(paste(strsplit(ds[i,"Tumor_Sample_Barcode"], "-")[[1]], collapse="."), 1, 12)
      }
   } 

   print("ds[i,Tumor_Sample_Barcode]:")   
   print(ds[i,"Tumor_Sample_Barcode"])
   
   gene.list <- ds[,"Hugo_Symbol"]

   N.gene.list <- length(gene.list)
   gene.names <- unique(gene.list)
   N.genes <- length(gene.names)

   sample.names <- ds[,"Tumor_Sample_Barcode"]
   
   u.sample.names <- unique(sample.names)
   N.samples <- length(u.sample.names)

   mut.table <- NULL
   mut.table.row.names <- NULL

   genes_with_all_entries_list <- NULL
   
   for (g in 1:N.genes) {

      gene <- gene.names[g]

      if (g %% 100 == 0) print(paste("processing gene number", g, " out of ", N.genes))
      locs <- seq(1, N.gene.list)[gene.list == gene]
      samples <- ds[locs,"Tumor_Sample_Barcode"]
      variant.classes <- ds[locs,"Variant_Classification"]
      u.variant.classes <- table(variant.classes)
      prot.change.classes<- ds[locs,"Protein_Change"]
      u.prot.change.classes <- table(prot.change.classes)

# Make entry for "All" mutations

      row.entry <- rep(0, N.samples)
      locs3 <- match(samples, u.sample.names)
      row.entry[locs3] <- 1
      mut.table <- rbind(mut.table, row.entry)
      row.entry.count <- sum(row.entry)
      entry.name <- paste(gene, "_MUT_All", sep="")
      mut.table.row.names <- c(mut.table.row.names, entry.name)

      if (!is.na(match(gene, genes_with_all_entries))) {
          print(paste(entry.name, row.entry.count))          
          genes_with_all_entries_list <- c(genes_with_all_entries_list, entry.name)
      }

# Make entry for "Nonsilent" mutations

      locs2 <- seq(1, length(locs))[variant.classes != "Silent"]        
      selected.samples <- samples[locs2]
      row.entry <- rep(0, N.samples)
      locs3 <- match(selected.samples, u.sample.names)
      row.entry[locs3] <- 1
      mut.table <- rbind(mut.table, row.entry)
      row.entry.count <- sum(row.entry)
      entry.name <- paste(gene, "_MUT_Nonsilent", sep="")
      mut.table.row.names <- c(mut.table.row.names, entry.name)

      if (!is.na(match(gene, genes_with_all_entries))) {
          print(paste(entry.name, row.entry.count))
          genes_with_all_entries_list <- c(genes_with_all_entries_list, entry.name)
      }

# Make entries for variant classes 

      variant.classes.above.thres <- names(u.variant.classes)[u.variant.classes >= variant.thres]
      variant.classes.above.thres  <- setdiff(variant.classes.above.thres, "Silent") # exclude Silent mutations
 
      for (var in variant.classes.above.thres) {
         locs2 <- seq(1, length(locs))[variant.classes == var]        
         selected.samples <- samples[locs2]
         row.entry <- rep(0, N.samples)
         locs3 <- match(selected.samples, u.sample.names)
         row.entry[locs3] <- 1
         row.entry.count <- sum(row.entry)
         
         if (exclude_flat_features == T & row.entry.count == 0) next         

         mut.table <- rbind(mut.table, row.entry)         
         entry.name <- paste(gene, "_MUT_", var, sep="")
         mut.table.row.names <- c(mut.table.row.names, entry.name)

         if (!is.na(match(gene, genes_with_all_entries))) {
             print(paste(entry.name, row.entry.count))                       
             genes_with_all_entries_list <- c(genes_with_all_entries_list, entry.name)
         }
         
      } # loop over variant classes

# Make entries for protein change classes 

      if (!is.na(match(gene, genes_with_all_entries))) { # for genes in the list include all protein changes
         print(paste("Making all entries for gene:", gene))
         prot.change.classes.above.thres <- names(u.prot.change.classes)
      } else {
         prot.change.classes.above.thres <- names(u.prot.change.classes)[u.prot.change.classes >= change.thres]
      }

      for (change in prot.change.classes.above.thres) {
         locs2 <- seq(1, length(locs))[prot.change.classes == change]        
         selected.samples <- samples[locs2]
         row.entry <- rep(0, N.samples)
         locs3 <- match(selected.samples, u.sample.names)
         row.entry[locs3] <- 1
         row.entry.count <- sum(row.entry)

         if (exclude_flat_features == T & row.entry.count == 0) next         

         mut.table <- rbind(mut.table, row.entry)
         entry.name <- paste(gene, "_MUT_", change, sep="")
         mut.table.row.names <- c(mut.table.row.names, entry.name)

         if (!is.na(match(gene, genes_with_all_entries))) {
             print(paste(entry.name, row.entry.count))                                    
             genes_with_all_entries_list <- c(genes_with_all_entries_list, entry.name)
         }

     } # loop over prot. change classes

   } # loop over genes

   row.names(mut.table) <-  mut.table.row.names 
   colnames(mut.table) <- u.sample.names

   write.gct.2(gct.data.frame = mut.table, descs =row.names(mut.table), filename = gct.output.file)

   print(paste("Dimensions of input mut table:", N.genes, N.samples))
   print(paste("Dimensions of output mut table:", nrow(mut.table), ncol(mut.table)))

   print(paste(genes_with_all_entries_list, collapse="','"))
   
} # end of DISSECTOR_produce_mutation_file 



DISSECTOR_explode_columns_in_table <- function(
     phen.table.in,    # Input phenotype table
     phen.table.out,   # Output phenotype table
     phen.columns)     # phenotype columns to explode

{
   samples.table <- read.delim(phen.table.in, header=T, row.names=1, sep="\t", skip=0)
   col.names <- colnames(samples.table)
   dim(samples.table)

   col.count <- ncol(samples.table)
   for (col in phen.columns) {
      phenotypes <- samples.table[, col]
      unique.phenotypes <- unique(phenotypes)
      for (phen in unique.phenotypes) {
         if (phen == "" | (is.na(phen))) next
         print(paste("Adding column:", phen, " from original column:", col))
         vec <- rep(0, nrow(samples.table))
         vec[phenotypes == phen] <- 1
         print(paste("Num samples:", sum(vec)))
         samples.table <- cbind(samples.table, vec)
         col.names <- c(col.names, phen)
       }
    }
   vec <- rep(1, nrow(samples.table))
   samples.table <- cbind(samples.table, vec)
   col.names <- c(col.names, "ALL")

   colnames(samples.table) <- col.names
   col.names
   dim(samples.table)

   write.table(samples.table, file=phen.table.out, quote=F, row.names=T, col.names=NA, sep="\t")

}

DISSECTOR_extract_subset_from_dataset <- function(
    #
    #  Extracts a subset of features and samples and makes a dataset containing only those
    #
   input.ds,           # Input dataset
   features = "ALL",   # Subset of features (row names) to extract. Default is "ALL"
   samples = "ALL",    # Subset of samples (column names) to extract. Default is "ALL"
   output.ds           # Output dataset with desired subset
    ) {
  
# Read dataset

   dataset <- MSIG.Gct2Frame(filename = input.ds)
   A <- data.matrix(dataset$ds)
   g.names <- dataset$row.names
   g.descs <- dataset$descs
   sample.names <- dataset$names

  dim(A) 

  if (features == "ALL") {
     row.locs <- seq(1, nrow(A))
  } else {
     row.locs <- match(features, g.names)
  }

  if (samples == "ALL") {
     col.locs <- rep(T, ncol(A))
  } else {
     col.locs <- match(samples, sample.names)
  }

  B <- A[row.locs, col.locs]
  colnames(B) <- colnames(A)[col.locs]
  row.names(B) <- row.names(A)[row.locs]

#  print(B[1:5,1:5])
        
  write.gct.2(gct.data.frame = data.frame(B), descs = row.names(B), filename = output.ds)

}

DISSECTOR_explode_columns_in_annot_table <- function(
#
# Explodes a set of columns in a phenotype table and creates a new table
# with one binary-valued column per value
#
   table.in,
   table.out.txt,
   table.out.gct,
   columns)
{
   samples.table <- read.delim(table.in, header=T, row.names=1, sep="\t", skip=0)
   col.names <- colnames(samples.table)
   dim(samples.table)

   col.count <- ncol(samples.table)
   for (col in columns) {
      phenotypes <- samples.table[, col]
      unique.phenotypes <- unique(phenotypes)
      for (phen in unique.phenotypes) {
         if (phen == "" | (is.na(phen))) next
         print(paste("Adding column:", phen, " from original column:", col))
         vec <- rep(0, nrow(samples.table))
         vec[phenotypes == phen] <- 1
         print(paste("Number of samples with phenotype ", phen, " = ", sum(vec)))
         print(paste("Num samples:", sum(vec)))
         samples.table <- cbind(samples.table, vec)
         col.names <- c(col.names, phen)
       }
    }
   vec <- rep(1, nrow(samples.table))
   samples.table <- cbind(samples.table, vec)
   col.names <- c(col.names, "ALL")

   colnames(samples.table) <- col.names
   col.names
   dim(samples.table)

   write.table(samples.table, file=table.out.txt, quote=F, row.names=T, col.names=NA, sep="\t")

   samples.table <- t(samples.table)

   write.gct.2(gct.data.frame = samples.table, descs = row.names(samples.table), filename=table.out.gct)   
}

         
   

